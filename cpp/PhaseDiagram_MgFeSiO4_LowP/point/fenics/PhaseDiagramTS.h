// This code conforms with the UFC specification version 2018.1.0
// and was automatically generated by FFC version 2019.1.0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
//
// This code was generated with the following parameters:
//

//  add_tabulate_tensor_timing:     False
//  convert_exceptions_to_warnings: False
//  cpp_optimize:                   True
//  cpp_optimize_flags:             '-O2'
//  epsilon:                        1e-14
//  error_control:                  False
//  external_include_dirs:          ''
//  external_includes:              ''
//  external_libraries:             ''
//  external_library_dirs:          ''
//  form_postfix:                   True
//  format:                         'dolfin'
//  generate_dummy_tabulate_tensor: False
//  max_signature_length:           0
//  optimize:                       True
//  precision:                      None
//  quadrature_degree:              None
//  quadrature_rule:                None
//  representation:                 'auto'
//  split:                          False

#ifndef __PHASEDIAGRAMTS_H
#define __PHASEDIAGRAMTS_H
#include <algorithm>
#include <cmath>
#include <iostream>
#include <stdexcept>
#include <ufc.h>

class phasediagramts_finite_element_0: public ufc::finite_element
{
public:

  phasediagramts_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  ~phasediagramts_finite_element_0() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FiniteElement('Lagrange', interval, 1)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::interval;
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t geometric_dimension() const final override
  {
    return 1;
  }

  std::size_t space_dimension() const final override
  {
    return 2;
  }

  std::size_t value_rank() const final override
  {
    return 0;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t value_size() const final override
  {
    return 1;
  }

  std::size_t reference_value_rank() const final override
  {
    return 0;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t reference_value_size() const final override
  {
    return 1;
  }

  std::size_t degree() const final override
  {
    return 1;
  }

  const char * family() const final override
  {
    return "Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][2] = { { 0.7071067811865475, -0.4082482904638631 } };
    static const double coefficients1[1][2] = { { 0.7071067811865475, 0.4082482904638631 } };
    for (std::size_t k = 0; k < num_points * 2; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[1] = { 2.0 * X[ip] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[2] = {};
        basisvalues1[0] = 1.0;
        basisvalues1[1] = Y[0];
        for (std::size_t p = 0; p < 2; ++p)
            basisvalues1[p] *= std::sqrt(0.5 + p);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 2; ++r)
            reference_values[2 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 2; ++r)
            reference_values[2 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(1, order);
    std::fill_n(reference_values, num_points * 2 * num_derivatives, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[1][2][2] =
        { { { 0.0, 0.0 },
            { 3.464101615137754, 0.0 } } };
    static const double coefficients0[1][2] = { { 0.7071067811865475, -0.4082482904638631 } };
    static const double coefficients1[1][2] = { { 0.7071067811865475, 0.4082482904638631 } };
    const std::size_t reference_offset[2] = {};
    const std::size_t num_components[2] = { 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][1][1] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[1] = { 2.0 * X[ip] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[2] = {};
        basisvalues1[0] = 1.0;
        basisvalues1[1] = Y[0];
        for (std::size_t p = 0; p < 2; ++p)
            basisvalues1[p] *= std::sqrt(0.5 + p);
        // Loop over all dofs
        for (std::size_t i = 0; i < 2; ++i)
        {
            double derivatives[1] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[2] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[2][2] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 4, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[2][2];
                        std::copy_n(&dmats[0][0], 4, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 4, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 2; ++t)
                            for (std::size_t u = 0; u < 2; ++u)
                                for (std::size_t tu = 0; tu < 2; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 2; ++s)
                        for (std::size_t t = 0; t < 2; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 2; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[2] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[2][2] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 4, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[2][2];
                        std::copy_n(&dmats[0][0], 4, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 4, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 2; ++t)
                            for (std::size_t u = 0; u < 2; ++u)
                                for (std::size_t tu = 0; tu < 2; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 2; ++s)
                        for (std::size_t t = 0; t < 2; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 2; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[2 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    const std::size_t num_derivatives = std::pow(1, order);
    // Precomputed combinations
    const std::size_t combinations[1][1][1] = {};
    std::fill_n(values, num_points * 2 * num_derivatives, 0.0);
    const std::size_t reference_offsets[2] = {};
    const std::size_t physical_offsets[2] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[ip + combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 2; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[2 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[2 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[1] = {};
    double J[1];
    double detJ;
    double K[1];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_interval_1d(J, coordinate_dofs);
        compute_jacobian_inverse_interval_1d(K, detJ, J);
        // Get coordinates and map to the reference (FIAT) element
        double Y[1] = { (2 * x[0] - coordinate_dofs[0] - coordinate_dofs[1]) / J[0] };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 1; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[2];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[2];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold value of a single dof.
    double dof_values = 0.0;
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 2; ++r)
    {
        evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
        values[r] = dof_values;
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(1, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[1];
    compute_jacobian_interval_1d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[1];
    double detJ;
    compute_jacobian_inverse_interval_1d(K, detJ, J);
    // Get coordinates and map to the reference (FIAT) element
    double Y[1] = { (2 * x[0] - coordinate_dofs[0] - coordinate_dofs[1]) / J[0] };
    // Precomputed combinations
    const std::size_t combinations[1][1][1] = {};
    // Declare transformation matrix
    double transform[1][1] = { { 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[2] = {};
            basisvalues[0] = 1.0;
            basisvalues[1] = Y[0];
            for (std::size_t p = 0; p < 2; ++p)
                basisvalues[p] *= std::sqrt(0.5 + p);
            // Table(s) of coefficients
            static const double coefficients0[2] = { 0.7071067811865475, -0.4082482904638631 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[2][2] =
                { { 0.0, 0.0 },
                  { 3.464101615137754, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[1] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[2][2] =
                { { 1.0, 0.0 },
                  { 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[2][2] =
                { { 1.0, 0.0 },
                  { 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 4, 0.0);
                for (std::size_t t = 0; t < 2; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 4, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 4, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 2; ++t)
                            for (std::size_t u = 0; u < 2; ++u)
                                for (std::size_t tu = 0; tu < 2; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 2; ++s)
                    for (std::size_t t = 0; t < 2; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[2] = {};
            basisvalues[0] = 1.0;
            basisvalues[1] = Y[0];
            for (std::size_t p = 0; p < 2; ++p)
                basisvalues[p] *= std::sqrt(0.5 + p);
            // Table(s) of coefficients
            static const double coefficients0[2] = { 0.7071067811865475, 0.4082482904638631 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[2][2] =
                { { 0.0, 0.0 },
                  { 3.464101615137754, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[1] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[2][2] =
                { { 1.0, 0.0 },
                  { 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[2][2] =
                { { 1.0, 0.0 },
                  { 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 4, 0.0);
                for (std::size_t t = 0; t < 2; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 4, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 4, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 2; ++t)
                            for (std::size_t u = 0; u < 2; ++u)
                                for (std::size_t tu = 0; tu < 2; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 2; ++s)
                    for (std::size_t t = 0; t < 2; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(1, n);
    // Set values equal to zero.
    std::fill_n(values, num_derivatives * 2, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[1] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 2; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < num_derivatives; ++s)
            values[num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[1];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[1];
    y[0] = coordinate_dofs[0];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[2] = { 0.0, 1.0 };
    std::copy_n(dof_X, 2, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 0;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::finite_element * create() const final override
  {
    return new phasediagramts_finite_element_0();
  }

};


class phasediagramts_finite_element_1: public ufc::finite_element
{
public:

  phasediagramts_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  ~phasediagramts_finite_element_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "VectorElement(FiniteElement('Lagrange', interval, 1), dim=1)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::interval;
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t geometric_dimension() const final override
  {
    return 1;
  }

  std::size_t space_dimension() const final override
  {
    return 2;
  }

  std::size_t value_rank() const final override
  {
    return 1;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 1 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 1;
  }

  std::size_t reference_value_rank() const final override
  {
    return 1;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 1 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 1;
  }

  std::size_t degree() const final override
  {
    return 1;
  }

  const char * family() const final override
  {
    return "Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][2] = { { 0.7071067811865475, -0.4082482904638631 } };
    static const double coefficients1[1][2] = { { 0.7071067811865475, 0.4082482904638631 } };
    for (std::size_t k = 0; k < num_points * 2; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[1] = { 2.0 * X[ip] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[2] = {};
        basisvalues1[0] = 1.0;
        basisvalues1[1] = Y[0];
        for (std::size_t p = 0; p < 2; ++p)
            basisvalues1[p] *= std::sqrt(0.5 + p);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 2; ++r)
            reference_values[2 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 2; ++r)
            reference_values[2 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(1, order);
    std::fill_n(reference_values, num_points * 2 * num_derivatives, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[1][2][2] =
        { { { 0.0, 0.0 },
            { 3.464101615137754, 0.0 } } };
    static const double coefficients0[1][2] = { { 0.7071067811865475, -0.4082482904638631 } };
    static const double coefficients1[1][2] = { { 0.7071067811865475, 0.4082482904638631 } };
    const std::size_t reference_offset[2] = {};
    const std::size_t num_components[2] = { 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][1][1] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[1] = { 2.0 * X[ip] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[2] = {};
        basisvalues1[0] = 1.0;
        basisvalues1[1] = Y[0];
        for (std::size_t p = 0; p < 2; ++p)
            basisvalues1[p] *= std::sqrt(0.5 + p);
        // Loop over all dofs
        for (std::size_t i = 0; i < 2; ++i)
        {
            double derivatives[1] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[2] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[2][2] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 4, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[2][2];
                        std::copy_n(&dmats[0][0], 4, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 4, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 2; ++t)
                            for (std::size_t u = 0; u < 2; ++u)
                                for (std::size_t tu = 0; tu < 2; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 2; ++s)
                        for (std::size_t t = 0; t < 2; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 2; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[2] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[2][2] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 4, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[2][2];
                        std::copy_n(&dmats[0][0], 4, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 4, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 2; ++t)
                            for (std::size_t u = 0; u < 2; ++u)
                                for (std::size_t tu = 0; tu < 2; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 2; ++s)
                        for (std::size_t t = 0; t < 2; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 2; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[2 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    const std::size_t num_derivatives = std::pow(1, order);
    // Precomputed combinations
    const std::size_t combinations[1][1][1] = {};
    std::fill_n(values, num_points * 2 * num_derivatives, 0.0);
    const std::size_t reference_offsets[2] = {};
    const std::size_t physical_offsets[2] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[ip + combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 2; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[2 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[2 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[1] = {};
    double J[1];
    double detJ;
    double K[1];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_interval_1d(J, coordinate_dofs);
        compute_jacobian_inverse_interval_1d(K, detJ, J);
        // Get coordinates and map to the reference (FIAT) element
        double Y[1] = { (2 * x[0] - coordinate_dofs[0] - coordinate_dofs[1]) / J[0] };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 1; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[2];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[2];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold value of a single dof.
    double dof_values = 0.0;
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 2; ++r)
    {
        evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
        values[r] = dof_values;
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(1, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[1];
    compute_jacobian_interval_1d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[1];
    double detJ;
    compute_jacobian_inverse_interval_1d(K, detJ, J);
    // Get coordinates and map to the reference (FIAT) element
    double Y[1] = { (2 * x[0] - coordinate_dofs[0] - coordinate_dofs[1]) / J[0] };
    // Precomputed combinations
    const std::size_t combinations[1][1][1] = {};
    // Declare transformation matrix
    double transform[1][1] = { { 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[2] = {};
            basisvalues[0] = 1.0;
            basisvalues[1] = Y[0];
            for (std::size_t p = 0; p < 2; ++p)
                basisvalues[p] *= std::sqrt(0.5 + p);
            // Table(s) of coefficients
            static const double coefficients0[2] = { 0.7071067811865475, -0.4082482904638631 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[2][2] =
                { { 0.0, 0.0 },
                  { 3.464101615137754, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[1] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[2][2] =
                { { 1.0, 0.0 },
                  { 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[2][2] =
                { { 1.0, 0.0 },
                  { 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 4, 0.0);
                for (std::size_t t = 0; t < 2; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 4, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 4, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 2; ++t)
                            for (std::size_t u = 0; u < 2; ++u)
                                for (std::size_t tu = 0; tu < 2; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 2; ++s)
                    for (std::size_t t = 0; t < 2; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[2] = {};
            basisvalues[0] = 1.0;
            basisvalues[1] = Y[0];
            for (std::size_t p = 0; p < 2; ++p)
                basisvalues[p] *= std::sqrt(0.5 + p);
            // Table(s) of coefficients
            static const double coefficients0[2] = { 0.7071067811865475, 0.4082482904638631 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[2][2] =
                { { 0.0, 0.0 },
                  { 3.464101615137754, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[1] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[2][2] =
                { { 1.0, 0.0 },
                  { 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[2][2] =
                { { 1.0, 0.0 },
                  { 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 4, 0.0);
                for (std::size_t t = 0; t < 2; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 4, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 4, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 2; ++t)
                            for (std::size_t u = 0; u < 2; ++u)
                                for (std::size_t tu = 0; tu < 2; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 2; ++s)
                    for (std::size_t t = 0; t < 2; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(1, n);
    // Set values equal to zero.
    std::fill_n(values, num_derivatives * 2, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[1] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 2; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < num_derivatives; ++s)
            values[num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[1];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[1];
    y[0] = coordinate_dofs[0];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[2] = { 0.0, 1.0 };
    std::copy_n(dof_X, 2, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 1;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_finite_element_0();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new phasediagramts_finite_element_1();
  }

};


class phasediagramts_finite_element_2: public ufc::finite_element
{
public:

  phasediagramts_finite_element_2() : ufc::finite_element()
  {
    // Do nothing
  }

  ~phasediagramts_finite_element_2() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FiniteElement('Discontinuous Lagrange', interval, 0)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::interval;
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t geometric_dimension() const final override
  {
    return 1;
  }

  std::size_t space_dimension() const final override
  {
    return 1;
  }

  std::size_t value_rank() const final override
  {
    return 0;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t value_size() const final override
  {
    return 1;
  }

  std::size_t reference_value_rank() const final override
  {
    return 0;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t reference_value_size() const final override
  {
    return 1;
  }

  std::size_t degree() const final override
  {
    return 0;
  }

  const char * family() const final override
  {
    return "Discontinuous Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][1] = { { 1.414213562373095 } };
    for (std::size_t k = 0; k < num_points; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        for (std::size_t p = 0; p < 1; ++p)
            basisvalues0[p] *= std::sqrt(0.5 + p);
        // Accumulate products of coefficients and basisvalues
        reference_values[ip] += coefficients0[0][0] * basisvalues0[0];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(1, order);
    std::fill_n(reference_values, num_points * num_derivatives, 0.0);
    if (order > 0)
        return;
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    std::fill_n(values, num_points, 0.0);
    const std::size_t reference_offsets[1] = {};
    const std::size_t physical_offsets[1] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 1; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[ip + d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[ip + d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[1] = {};
    double J[1];
    double detJ;
    double K[1];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_interval_1d(J, coordinate_dofs);
        compute_jacobian_inverse_interval_1d(K, detJ, J);
    }
    // Evaluate basis on reference element
    double ref_values[1];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[1];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, x, coordinate_dofs, cell_orientation);
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(1, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, x, coordinate_dofs, cell_orientation);
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[1];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[1] = { 0.5 };
    std::copy_n(dof_X, 1, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 0;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::finite_element * create() const final override
  {
    return new phasediagramts_finite_element_2();
  }

};


class phasediagramts_finite_element_3: public ufc::finite_element
{
public:

  phasediagramts_finite_element_3() : ufc::finite_element()
  {
    // Do nothing
  }

  ~phasediagramts_finite_element_3() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=6)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::interval;
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t geometric_dimension() const final override
  {
    return 1;
  }

  std::size_t space_dimension() const final override
  {
    return 6;
  }

  std::size_t value_rank() const final override
  {
    return 1;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 6 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 6;
  }

  std::size_t reference_value_rank() const final override
  {
    return 1;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 6 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 6;
  }

  std::size_t degree() const final override
  {
    return 0;
  }

  const char * family() const final override
  {
    return "Discontinuous Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][1] = { { 1.414213562373095 } };
    for (std::size_t k = 0; k < num_points * 6 * 6; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        for (std::size_t p = 0; p < 1; ++p)
            basisvalues0[p] *= std::sqrt(0.5 + p);
        // Accumulate products of coefficients and basisvalues
        reference_values[6 * 6 * ip] += coefficients0[0][0] * basisvalues0[0];
        reference_values[6 * 6 * ip + 6 + 1] += coefficients0[0][0] * basisvalues0[0];
        reference_values[6 * 6 * ip + 6 * 2 + 2] += coefficients0[0][0] * basisvalues0[0];
        reference_values[6 * 6 * ip + 6 * 3 + 3] += coefficients0[0][0] * basisvalues0[0];
        reference_values[6 * 6 * ip + 6 * 4 + 4] += coefficients0[0][0] * basisvalues0[0];
        reference_values[6 * 6 * ip + 6 * 5 + 5] += coefficients0[0][0] * basisvalues0[0];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(1, order);
    std::fill_n(reference_values, num_points * 6 * num_derivatives * 6, 0.0);
    if (order > 0)
        return;
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    std::fill_n(values, num_points * 6 * 6, 0.0);
    const std::size_t reference_offsets[6] = { 0, 1, 2, 3, 4, 5 };
    const std::size_t physical_offsets[6] = { 0, 1, 2, 3, 4, 5 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 6; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[6 * 6 * ip + 6 * d + 6 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[6 * 6 * ip + 6 * d + 6 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[1] = {};
    double J[1];
    double detJ;
    double K[1];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_interval_1d(J, coordinate_dofs);
        compute_jacobian_inverse_interval_1d(K, detJ, J);
    }
    // Evaluate basis on reference element
    double ref_values[36];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[36];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 6; ++k)
        values[k] = physical_values[6 * i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold values of a single dof.
    double dof_values[6] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 6; ++s)
            values[r * 6 + s] = dof_values[s];
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(1, n);
    std::fill_n(values, 6 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(1, n);
    // Set values equal to zero.
    std::fill_n(values, 6 * num_derivatives * 6, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[6] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 6 * num_derivatives; ++s)
            values[6 * num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[6];
    // Declare variable for physical coordinates
    double y[1];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 2:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 3:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 4:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 5:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[6];
    // Declare variable for physical coordinates
    double y[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[1] = vals[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[2] = vals[2];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[3];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[4] = vals[4];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[5] = vals[5];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[6] = dof_values[0];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[1];
    vertex_values[7] = dof_values[1];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[2];
    vertex_values[8] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[3] = dof_values[3];
    vertex_values[9] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[4] = dof_values[4];
    vertex_values[10] = dof_values[4];
    // Evaluate function and change variables
    vertex_values[5] = dof_values[5];
    vertex_values[11] = dof_values[5];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[1] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[2] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[3] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[4] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[5] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[6] = { 0.5, 0.5, 0.5, 0.5, 0.5, 0.5 };
    std::copy_n(dof_X, 6, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 6;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_finite_element_2();
    case 1:
        return new phasediagramts_finite_element_2();
    case 2:
        return new phasediagramts_finite_element_2();
    case 3:
        return new phasediagramts_finite_element_2();
    case 4:
        return new phasediagramts_finite_element_2();
    case 5:
        return new phasediagramts_finite_element_2();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new phasediagramts_finite_element_3();
  }

};


class phasediagramts_finite_element_4: public ufc::finite_element
{
public:

  phasediagramts_finite_element_4() : ufc::finite_element()
  {
    // Do nothing
  }

  ~phasediagramts_finite_element_4() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=11)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::interval;
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t geometric_dimension() const final override
  {
    return 1;
  }

  std::size_t space_dimension() const final override
  {
    return 11;
  }

  std::size_t value_rank() const final override
  {
    return 1;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 11 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 11;
  }

  std::size_t reference_value_rank() const final override
  {
    return 1;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 11 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 11;
  }

  std::size_t degree() const final override
  {
    return 0;
  }

  const char * family() const final override
  {
    return "Discontinuous Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][1] = { { 1.414213562373095 } };
    for (std::size_t k = 0; k < num_points * 11 * 11; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        for (std::size_t p = 0; p < 1; ++p)
            basisvalues0[p] *= std::sqrt(0.5 + p);
        // Accumulate products of coefficients and basisvalues
        reference_values[11 * 11 * ip] += coefficients0[0][0] * basisvalues0[0];
        reference_values[11 * 11 * ip + 11 + 1] += coefficients0[0][0] * basisvalues0[0];
        reference_values[11 * 11 * ip + 11 * 2 + 2] += coefficients0[0][0] * basisvalues0[0];
        reference_values[11 * 11 * ip + 11 * 3 + 3] += coefficients0[0][0] * basisvalues0[0];
        reference_values[11 * 11 * ip + 11 * 4 + 4] += coefficients0[0][0] * basisvalues0[0];
        reference_values[11 * 11 * ip + 11 * 5 + 5] += coefficients0[0][0] * basisvalues0[0];
        reference_values[11 * 11 * ip + 11 * 6 + 6] += coefficients0[0][0] * basisvalues0[0];
        reference_values[11 * 11 * ip + 11 * 7 + 7] += coefficients0[0][0] * basisvalues0[0];
        reference_values[11 * 11 * ip + 11 * 8 + 8] += coefficients0[0][0] * basisvalues0[0];
        reference_values[11 * 11 * ip + 11 * 9 + 9] += coefficients0[0][0] * basisvalues0[0];
        reference_values[11 * 11 * ip + 11 * 10 + 10] += coefficients0[0][0] * basisvalues0[0];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(1, order);
    std::fill_n(reference_values, num_points * 11 * num_derivatives * 11, 0.0);
    if (order > 0)
        return;
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    std::fill_n(values, num_points * 11 * 11, 0.0);
    const std::size_t reference_offsets[11] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    const std::size_t physical_offsets[11] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 11; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[11 * 11 * ip + 11 * d + 11 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[11 * 11 * ip + 11 * d + 11 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[1] = {};
    double J[1];
    double detJ;
    double K[1];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_interval_1d(J, coordinate_dofs);
        compute_jacobian_inverse_interval_1d(K, detJ, J);
    }
    // Evaluate basis on reference element
    double ref_values[121];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[121];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 11; ++k)
        values[k] = physical_values[11 * i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold values of a single dof.
    double dof_values[11] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 11; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 11; ++s)
            values[r * 11 + s] = dof_values[s];
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(1, n);
    std::fill_n(values, 11 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(1, n);
    // Set values equal to zero.
    std::fill_n(values, 11 * num_derivatives * 11, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[11] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 11; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 11 * num_derivatives; ++s)
            values[11 * num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[11];
    // Declare variable for physical coordinates
    double y[1];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 2:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 3:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 4:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 5:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 6:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 7:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 8:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 9:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[9];
        }
        break;
    case 10:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[10];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[11];
    // Declare variable for physical coordinates
    double y[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[1] = vals[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[2] = vals[2];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[3];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[4] = vals[4];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[5] = vals[5];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[6] = vals[6];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[7] = vals[7];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[8] = vals[8];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[9] = vals[9];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[10] = vals[10];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[11] = dof_values[0];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[1];
    vertex_values[12] = dof_values[1];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[2];
    vertex_values[13] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[3] = dof_values[3];
    vertex_values[14] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[4] = dof_values[4];
    vertex_values[15] = dof_values[4];
    // Evaluate function and change variables
    vertex_values[5] = dof_values[5];
    vertex_values[16] = dof_values[5];
    // Evaluate function and change variables
    vertex_values[6] = dof_values[6];
    vertex_values[17] = dof_values[6];
    // Evaluate function and change variables
    vertex_values[7] = dof_values[7];
    vertex_values[18] = dof_values[7];
    // Evaluate function and change variables
    vertex_values[8] = dof_values[8];
    vertex_values[19] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[9] = dof_values[9];
    vertex_values[20] = dof_values[9];
    // Evaluate function and change variables
    vertex_values[10] = dof_values[10];
    vertex_values[21] = dof_values[10];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[1] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[2] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[3] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[4] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[5] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[6] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[7] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[8] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[9] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[10] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[11] = { 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5 };
    std::copy_n(dof_X, 11, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 11;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_finite_element_2();
    case 1:
        return new phasediagramts_finite_element_2();
    case 2:
        return new phasediagramts_finite_element_2();
    case 3:
        return new phasediagramts_finite_element_2();
    case 4:
        return new phasediagramts_finite_element_2();
    case 5:
        return new phasediagramts_finite_element_2();
    case 6:
        return new phasediagramts_finite_element_2();
    case 7:
        return new phasediagramts_finite_element_2();
    case 8:
        return new phasediagramts_finite_element_2();
    case 9:
        return new phasediagramts_finite_element_2();
    case 10:
        return new phasediagramts_finite_element_2();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new phasediagramts_finite_element_4();
  }

};


class phasediagramts_finite_element_5: public ufc::finite_element
{
public:

  phasediagramts_finite_element_5() : ufc::finite_element()
  {
    // Do nothing
  }

  ~phasediagramts_finite_element_5() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "TensorElement(FiniteElement('Discontinuous Lagrange', interval, 0), shape=(6, 17), symmetry={})";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::interval;
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t geometric_dimension() const final override
  {
    return 1;
  }

  std::size_t space_dimension() const final override
  {
    return 102;
  }

  std::size_t value_rank() const final override
  {
    return 2;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[2] = { 6, 17 };
    if (i >= 2)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 102;
  }

  std::size_t reference_value_rank() const final override
  {
    return 2;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[2] = { 6, 17 };
    if (i >= 2)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 102;
  }

  std::size_t degree() const final override
  {
    return 0;
  }

  const char * family() const final override
  {
    return "Discontinuous Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][1] = { { 1.414213562373095 } };
    for (std::size_t k = 0; k < num_points * 102 * 102; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        for (std::size_t p = 0; p < 1; ++p)
            basisvalues0[p] *= std::sqrt(0.5 + p);
        // Accumulate products of coefficients and basisvalues
        reference_values[102 * 102 * ip] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 + 1] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 2 + 2] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 3 + 3] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 4 + 4] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 5 + 5] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 6 + 6] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 7 + 7] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 8 + 8] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 9 + 9] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 10 + 10] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 11 + 11] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 12 + 12] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 13 + 13] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 14 + 14] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 15 + 15] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 16 + 16] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 17 + 17] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 18 + 18] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 19 + 19] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 20 + 20] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 21 + 21] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 22 + 22] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 23 + 23] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 24 + 24] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 25 + 25] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 26 + 26] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 27 + 27] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 28 + 28] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 29 + 29] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 30 + 30] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 31 + 31] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 32 + 32] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 33 + 33] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 34 + 34] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 35 + 35] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 36 + 36] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 37 + 37] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 38 + 38] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 39 + 39] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 40 + 40] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 41 + 41] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 42 + 42] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 43 + 43] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 44 + 44] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 45 + 45] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 46 + 46] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 47 + 47] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 48 + 48] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 49 + 49] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 50 + 50] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 51 + 51] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 52 + 52] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 53 + 53] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 54 + 54] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 55 + 55] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 56 + 56] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 57 + 57] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 58 + 58] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 59 + 59] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 60 + 60] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 61 + 61] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 62 + 62] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 63 + 63] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 64 + 64] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 65 + 65] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 66 + 66] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 67 + 67] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 68 + 68] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 69 + 69] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 70 + 70] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 71 + 71] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 72 + 72] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 73 + 73] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 74 + 74] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 75 + 75] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 76 + 76] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 77 + 77] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 78 + 78] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 79 + 79] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 80 + 80] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 81 + 81] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 82 + 82] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 83 + 83] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 84 + 84] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 85 + 85] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 86 + 86] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 87 + 87] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 88 + 88] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 89 + 89] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 90 + 90] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 91 + 91] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 92 + 92] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 93 + 93] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 94 + 94] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 95 + 95] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 96 + 96] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 97 + 97] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 98 + 98] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 99 + 99] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 100 + 100] += coefficients0[0][0] * basisvalues0[0];
        reference_values[102 * 102 * ip + 102 * 101 + 101] += coefficients0[0][0] * basisvalues0[0];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(1, order);
    std::fill_n(reference_values, num_points * 102 * num_derivatives * 102, 0.0);
    if (order > 0)
        return;
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    std::fill_n(values, num_points * 102 * 102, 0.0);
    const std::size_t reference_offsets[102] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101 };
    const std::size_t physical_offsets[102] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 102; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[102 * 102 * ip + 102 * d + 102 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[102 * 102 * ip + 102 * d + 102 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[1] = {};
    double J[1];
    double detJ;
    double K[1];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_interval_1d(J, coordinate_dofs);
        compute_jacobian_inverse_interval_1d(K, detJ, J);
    }
    // Evaluate basis on reference element
    double ref_values[10404];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[10404];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 102; ++k)
        values[k] = physical_values[102 * i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold values of a single dof.
    double dof_values[102] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 102; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 102; ++s)
            values[r * 102 + s] = dof_values[s];
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(1, n);
    std::fill_n(values, 102 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(1, n);
    // Set values equal to zero.
    std::fill_n(values, 102 * num_derivatives * 102, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[102] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 102; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 102 * num_derivatives; ++s)
            values[102 * num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[102];
    // Declare variable for physical coordinates
    double y[1];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 2:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 3:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 4:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 5:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 6:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 7:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 8:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 9:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[9];
        }
        break;
    case 10:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[10];
        }
        break;
    case 11:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[11];
        }
        break;
    case 12:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[12];
        }
        break;
    case 13:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[13];
        }
        break;
    case 14:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[14];
        }
        break;
    case 15:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[15];
        }
        break;
    case 16:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[16];
        }
        break;
    case 17:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[17];
        }
        break;
    case 18:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[18];
        }
        break;
    case 19:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[19];
        }
        break;
    case 20:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[20];
        }
        break;
    case 21:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[21];
        }
        break;
    case 22:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[22];
        }
        break;
    case 23:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[23];
        }
        break;
    case 24:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[24];
        }
        break;
    case 25:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[25];
        }
        break;
    case 26:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[26];
        }
        break;
    case 27:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[27];
        }
        break;
    case 28:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[28];
        }
        break;
    case 29:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[29];
        }
        break;
    case 30:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[30];
        }
        break;
    case 31:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[31];
        }
        break;
    case 32:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[32];
        }
        break;
    case 33:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[33];
        }
        break;
    case 34:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[34];
        }
        break;
    case 35:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[35];
        }
        break;
    case 36:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[36];
        }
        break;
    case 37:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[37];
        }
        break;
    case 38:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[38];
        }
        break;
    case 39:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[39];
        }
        break;
    case 40:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[40];
        }
        break;
    case 41:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[41];
        }
        break;
    case 42:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[42];
        }
        break;
    case 43:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[43];
        }
        break;
    case 44:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[44];
        }
        break;
    case 45:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[45];
        }
        break;
    case 46:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[46];
        }
        break;
    case 47:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[47];
        }
        break;
    case 48:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[48];
        }
        break;
    case 49:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[49];
        }
        break;
    case 50:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[50];
        }
        break;
    case 51:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[51];
        }
        break;
    case 52:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[52];
        }
        break;
    case 53:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[53];
        }
        break;
    case 54:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[54];
        }
        break;
    case 55:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[55];
        }
        break;
    case 56:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[56];
        }
        break;
    case 57:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[57];
        }
        break;
    case 58:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[58];
        }
        break;
    case 59:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[59];
        }
        break;
    case 60:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[60];
        }
        break;
    case 61:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[61];
        }
        break;
    case 62:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[62];
        }
        break;
    case 63:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[63];
        }
        break;
    case 64:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[64];
        }
        break;
    case 65:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[65];
        }
        break;
    case 66:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[66];
        }
        break;
    case 67:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[67];
        }
        break;
    case 68:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[68];
        }
        break;
    case 69:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[69];
        }
        break;
    case 70:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[70];
        }
        break;
    case 71:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[71];
        }
        break;
    case 72:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[72];
        }
        break;
    case 73:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[73];
        }
        break;
    case 74:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[74];
        }
        break;
    case 75:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[75];
        }
        break;
    case 76:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[76];
        }
        break;
    case 77:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[77];
        }
        break;
    case 78:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[78];
        }
        break;
    case 79:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[79];
        }
        break;
    case 80:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[80];
        }
        break;
    case 81:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[81];
        }
        break;
    case 82:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[82];
        }
        break;
    case 83:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[83];
        }
        break;
    case 84:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[84];
        }
        break;
    case 85:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[85];
        }
        break;
    case 86:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[86];
        }
        break;
    case 87:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[87];
        }
        break;
    case 88:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[88];
        }
        break;
    case 89:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[89];
        }
        break;
    case 90:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[90];
        }
        break;
    case 91:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[91];
        }
        break;
    case 92:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[92];
        }
        break;
    case 93:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[93];
        }
        break;
    case 94:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[94];
        }
        break;
    case 95:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[95];
        }
        break;
    case 96:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[96];
        }
        break;
    case 97:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[97];
        }
        break;
    case 98:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[98];
        }
        break;
    case 99:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[99];
        }
        break;
    case 100:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[100];
        }
        break;
    case 101:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[101];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[102];
    // Declare variable for physical coordinates
    double y[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[1] = vals[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[2] = vals[2];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[3];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[4] = vals[4];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[5] = vals[5];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[6] = vals[6];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[7] = vals[7];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[8] = vals[8];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[9] = vals[9];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[10] = vals[10];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[11] = vals[11];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[12] = vals[12];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[13] = vals[13];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[14] = vals[14];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[15] = vals[15];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[16] = vals[16];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[17] = vals[17];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[18] = vals[18];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[19] = vals[19];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[20] = vals[20];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[21] = vals[21];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[22] = vals[22];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[23] = vals[23];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[24] = vals[24];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[25] = vals[25];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[26] = vals[26];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[27] = vals[27];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[28] = vals[28];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[29] = vals[29];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[30] = vals[30];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[31] = vals[31];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[32] = vals[32];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[33] = vals[33];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[34] = vals[34];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[35] = vals[35];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[36] = vals[36];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[37] = vals[37];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[38] = vals[38];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[39] = vals[39];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[40] = vals[40];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[41] = vals[41];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[42] = vals[42];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[43] = vals[43];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[44] = vals[44];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[45] = vals[45];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[46] = vals[46];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[47] = vals[47];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[48] = vals[48];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[49] = vals[49];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[50] = vals[50];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[51] = vals[51];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[52] = vals[52];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[53] = vals[53];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[54] = vals[54];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[55] = vals[55];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[56] = vals[56];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[57] = vals[57];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[58] = vals[58];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[59] = vals[59];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[60] = vals[60];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[61] = vals[61];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[62] = vals[62];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[63] = vals[63];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[64] = vals[64];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[65] = vals[65];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[66] = vals[66];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[67] = vals[67];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[68] = vals[68];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[69] = vals[69];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[70] = vals[70];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[71] = vals[71];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[72] = vals[72];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[73] = vals[73];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[74] = vals[74];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[75] = vals[75];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[76] = vals[76];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[77] = vals[77];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[78] = vals[78];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[79] = vals[79];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[80] = vals[80];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[81] = vals[81];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[82] = vals[82];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[83] = vals[83];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[84] = vals[84];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[85] = vals[85];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[86] = vals[86];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[87] = vals[87];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[88] = vals[88];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[89] = vals[89];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[90] = vals[90];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[91] = vals[91];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[92] = vals[92];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[93] = vals[93];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[94] = vals[94];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[95] = vals[95];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[96] = vals[96];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[97] = vals[97];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[98] = vals[98];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[99] = vals[99];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[100] = vals[100];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[101] = vals[101];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[102] = dof_values[0];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[1];
    vertex_values[103] = dof_values[1];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[2];
    vertex_values[104] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[3] = dof_values[3];
    vertex_values[105] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[4] = dof_values[4];
    vertex_values[106] = dof_values[4];
    // Evaluate function and change variables
    vertex_values[5] = dof_values[5];
    vertex_values[107] = dof_values[5];
    // Evaluate function and change variables
    vertex_values[6] = dof_values[6];
    vertex_values[108] = dof_values[6];
    // Evaluate function and change variables
    vertex_values[7] = dof_values[7];
    vertex_values[109] = dof_values[7];
    // Evaluate function and change variables
    vertex_values[8] = dof_values[8];
    vertex_values[110] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[9] = dof_values[9];
    vertex_values[111] = dof_values[9];
    // Evaluate function and change variables
    vertex_values[10] = dof_values[10];
    vertex_values[112] = dof_values[10];
    // Evaluate function and change variables
    vertex_values[11] = dof_values[11];
    vertex_values[113] = dof_values[11];
    // Evaluate function and change variables
    vertex_values[12] = dof_values[12];
    vertex_values[114] = dof_values[12];
    // Evaluate function and change variables
    vertex_values[13] = dof_values[13];
    vertex_values[115] = dof_values[13];
    // Evaluate function and change variables
    vertex_values[14] = dof_values[14];
    vertex_values[116] = dof_values[14];
    // Evaluate function and change variables
    vertex_values[15] = dof_values[15];
    vertex_values[117] = dof_values[15];
    // Evaluate function and change variables
    vertex_values[16] = dof_values[16];
    vertex_values[118] = dof_values[16];
    // Evaluate function and change variables
    vertex_values[17] = dof_values[17];
    vertex_values[119] = dof_values[17];
    // Evaluate function and change variables
    vertex_values[18] = dof_values[18];
    vertex_values[120] = dof_values[18];
    // Evaluate function and change variables
    vertex_values[19] = dof_values[19];
    vertex_values[121] = dof_values[19];
    // Evaluate function and change variables
    vertex_values[20] = dof_values[20];
    vertex_values[122] = dof_values[20];
    // Evaluate function and change variables
    vertex_values[21] = dof_values[21];
    vertex_values[123] = dof_values[21];
    // Evaluate function and change variables
    vertex_values[22] = dof_values[22];
    vertex_values[124] = dof_values[22];
    // Evaluate function and change variables
    vertex_values[23] = dof_values[23];
    vertex_values[125] = dof_values[23];
    // Evaluate function and change variables
    vertex_values[24] = dof_values[24];
    vertex_values[126] = dof_values[24];
    // Evaluate function and change variables
    vertex_values[25] = dof_values[25];
    vertex_values[127] = dof_values[25];
    // Evaluate function and change variables
    vertex_values[26] = dof_values[26];
    vertex_values[128] = dof_values[26];
    // Evaluate function and change variables
    vertex_values[27] = dof_values[27];
    vertex_values[129] = dof_values[27];
    // Evaluate function and change variables
    vertex_values[28] = dof_values[28];
    vertex_values[130] = dof_values[28];
    // Evaluate function and change variables
    vertex_values[29] = dof_values[29];
    vertex_values[131] = dof_values[29];
    // Evaluate function and change variables
    vertex_values[30] = dof_values[30];
    vertex_values[132] = dof_values[30];
    // Evaluate function and change variables
    vertex_values[31] = dof_values[31];
    vertex_values[133] = dof_values[31];
    // Evaluate function and change variables
    vertex_values[32] = dof_values[32];
    vertex_values[134] = dof_values[32];
    // Evaluate function and change variables
    vertex_values[33] = dof_values[33];
    vertex_values[135] = dof_values[33];
    // Evaluate function and change variables
    vertex_values[34] = dof_values[34];
    vertex_values[136] = dof_values[34];
    // Evaluate function and change variables
    vertex_values[35] = dof_values[35];
    vertex_values[137] = dof_values[35];
    // Evaluate function and change variables
    vertex_values[36] = dof_values[36];
    vertex_values[138] = dof_values[36];
    // Evaluate function and change variables
    vertex_values[37] = dof_values[37];
    vertex_values[139] = dof_values[37];
    // Evaluate function and change variables
    vertex_values[38] = dof_values[38];
    vertex_values[140] = dof_values[38];
    // Evaluate function and change variables
    vertex_values[39] = dof_values[39];
    vertex_values[141] = dof_values[39];
    // Evaluate function and change variables
    vertex_values[40] = dof_values[40];
    vertex_values[142] = dof_values[40];
    // Evaluate function and change variables
    vertex_values[41] = dof_values[41];
    vertex_values[143] = dof_values[41];
    // Evaluate function and change variables
    vertex_values[42] = dof_values[42];
    vertex_values[144] = dof_values[42];
    // Evaluate function and change variables
    vertex_values[43] = dof_values[43];
    vertex_values[145] = dof_values[43];
    // Evaluate function and change variables
    vertex_values[44] = dof_values[44];
    vertex_values[146] = dof_values[44];
    // Evaluate function and change variables
    vertex_values[45] = dof_values[45];
    vertex_values[147] = dof_values[45];
    // Evaluate function and change variables
    vertex_values[46] = dof_values[46];
    vertex_values[148] = dof_values[46];
    // Evaluate function and change variables
    vertex_values[47] = dof_values[47];
    vertex_values[149] = dof_values[47];
    // Evaluate function and change variables
    vertex_values[48] = dof_values[48];
    vertex_values[150] = dof_values[48];
    // Evaluate function and change variables
    vertex_values[49] = dof_values[49];
    vertex_values[151] = dof_values[49];
    // Evaluate function and change variables
    vertex_values[50] = dof_values[50];
    vertex_values[152] = dof_values[50];
    // Evaluate function and change variables
    vertex_values[51] = dof_values[51];
    vertex_values[153] = dof_values[51];
    // Evaluate function and change variables
    vertex_values[52] = dof_values[52];
    vertex_values[154] = dof_values[52];
    // Evaluate function and change variables
    vertex_values[53] = dof_values[53];
    vertex_values[155] = dof_values[53];
    // Evaluate function and change variables
    vertex_values[54] = dof_values[54];
    vertex_values[156] = dof_values[54];
    // Evaluate function and change variables
    vertex_values[55] = dof_values[55];
    vertex_values[157] = dof_values[55];
    // Evaluate function and change variables
    vertex_values[56] = dof_values[56];
    vertex_values[158] = dof_values[56];
    // Evaluate function and change variables
    vertex_values[57] = dof_values[57];
    vertex_values[159] = dof_values[57];
    // Evaluate function and change variables
    vertex_values[58] = dof_values[58];
    vertex_values[160] = dof_values[58];
    // Evaluate function and change variables
    vertex_values[59] = dof_values[59];
    vertex_values[161] = dof_values[59];
    // Evaluate function and change variables
    vertex_values[60] = dof_values[60];
    vertex_values[162] = dof_values[60];
    // Evaluate function and change variables
    vertex_values[61] = dof_values[61];
    vertex_values[163] = dof_values[61];
    // Evaluate function and change variables
    vertex_values[62] = dof_values[62];
    vertex_values[164] = dof_values[62];
    // Evaluate function and change variables
    vertex_values[63] = dof_values[63];
    vertex_values[165] = dof_values[63];
    // Evaluate function and change variables
    vertex_values[64] = dof_values[64];
    vertex_values[166] = dof_values[64];
    // Evaluate function and change variables
    vertex_values[65] = dof_values[65];
    vertex_values[167] = dof_values[65];
    // Evaluate function and change variables
    vertex_values[66] = dof_values[66];
    vertex_values[168] = dof_values[66];
    // Evaluate function and change variables
    vertex_values[67] = dof_values[67];
    vertex_values[169] = dof_values[67];
    // Evaluate function and change variables
    vertex_values[68] = dof_values[68];
    vertex_values[170] = dof_values[68];
    // Evaluate function and change variables
    vertex_values[69] = dof_values[69];
    vertex_values[171] = dof_values[69];
    // Evaluate function and change variables
    vertex_values[70] = dof_values[70];
    vertex_values[172] = dof_values[70];
    // Evaluate function and change variables
    vertex_values[71] = dof_values[71];
    vertex_values[173] = dof_values[71];
    // Evaluate function and change variables
    vertex_values[72] = dof_values[72];
    vertex_values[174] = dof_values[72];
    // Evaluate function and change variables
    vertex_values[73] = dof_values[73];
    vertex_values[175] = dof_values[73];
    // Evaluate function and change variables
    vertex_values[74] = dof_values[74];
    vertex_values[176] = dof_values[74];
    // Evaluate function and change variables
    vertex_values[75] = dof_values[75];
    vertex_values[177] = dof_values[75];
    // Evaluate function and change variables
    vertex_values[76] = dof_values[76];
    vertex_values[178] = dof_values[76];
    // Evaluate function and change variables
    vertex_values[77] = dof_values[77];
    vertex_values[179] = dof_values[77];
    // Evaluate function and change variables
    vertex_values[78] = dof_values[78];
    vertex_values[180] = dof_values[78];
    // Evaluate function and change variables
    vertex_values[79] = dof_values[79];
    vertex_values[181] = dof_values[79];
    // Evaluate function and change variables
    vertex_values[80] = dof_values[80];
    vertex_values[182] = dof_values[80];
    // Evaluate function and change variables
    vertex_values[81] = dof_values[81];
    vertex_values[183] = dof_values[81];
    // Evaluate function and change variables
    vertex_values[82] = dof_values[82];
    vertex_values[184] = dof_values[82];
    // Evaluate function and change variables
    vertex_values[83] = dof_values[83];
    vertex_values[185] = dof_values[83];
    // Evaluate function and change variables
    vertex_values[84] = dof_values[84];
    vertex_values[186] = dof_values[84];
    // Evaluate function and change variables
    vertex_values[85] = dof_values[85];
    vertex_values[187] = dof_values[85];
    // Evaluate function and change variables
    vertex_values[86] = dof_values[86];
    vertex_values[188] = dof_values[86];
    // Evaluate function and change variables
    vertex_values[87] = dof_values[87];
    vertex_values[189] = dof_values[87];
    // Evaluate function and change variables
    vertex_values[88] = dof_values[88];
    vertex_values[190] = dof_values[88];
    // Evaluate function and change variables
    vertex_values[89] = dof_values[89];
    vertex_values[191] = dof_values[89];
    // Evaluate function and change variables
    vertex_values[90] = dof_values[90];
    vertex_values[192] = dof_values[90];
    // Evaluate function and change variables
    vertex_values[91] = dof_values[91];
    vertex_values[193] = dof_values[91];
    // Evaluate function and change variables
    vertex_values[92] = dof_values[92];
    vertex_values[194] = dof_values[92];
    // Evaluate function and change variables
    vertex_values[93] = dof_values[93];
    vertex_values[195] = dof_values[93];
    // Evaluate function and change variables
    vertex_values[94] = dof_values[94];
    vertex_values[196] = dof_values[94];
    // Evaluate function and change variables
    vertex_values[95] = dof_values[95];
    vertex_values[197] = dof_values[95];
    // Evaluate function and change variables
    vertex_values[96] = dof_values[96];
    vertex_values[198] = dof_values[96];
    // Evaluate function and change variables
    vertex_values[97] = dof_values[97];
    vertex_values[199] = dof_values[97];
    // Evaluate function and change variables
    vertex_values[98] = dof_values[98];
    vertex_values[200] = dof_values[98];
    // Evaluate function and change variables
    vertex_values[99] = dof_values[99];
    vertex_values[201] = dof_values[99];
    // Evaluate function and change variables
    vertex_values[100] = dof_values[100];
    vertex_values[202] = dof_values[100];
    // Evaluate function and change variables
    vertex_values[101] = dof_values[101];
    vertex_values[203] = dof_values[101];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[1] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[2] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[3] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[4] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[5] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[6] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[7] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[8] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[9] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[10] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[11] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[12] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[13] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[14] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[15] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[16] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[17] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[18] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[19] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[20] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[21] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[22] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[23] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[24] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[25] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[26] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[27] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[28] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[29] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[30] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[31] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[32] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[33] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[34] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[35] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[36] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[37] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[38] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[39] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[40] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[41] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[42] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[43] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[44] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[45] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[46] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[47] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[48] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[49] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[50] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[51] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[52] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[53] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[54] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[55] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[56] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[57] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[58] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[59] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[60] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[61] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[62] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[63] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[64] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[65] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[66] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[67] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[68] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[69] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[70] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[71] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[72] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[73] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[74] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[75] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[76] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[77] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[78] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[79] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[80] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[81] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[82] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[83] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[84] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[85] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[86] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[87] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[88] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[89] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[90] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[91] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[92] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[93] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[94] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[95] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[96] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[97] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[98] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[99] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[100] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[101] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[102] = { 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5 };
    std::copy_n(dof_X, 102, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 102;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_finite_element_2();
    case 1:
        return new phasediagramts_finite_element_2();
    case 2:
        return new phasediagramts_finite_element_2();
    case 3:
        return new phasediagramts_finite_element_2();
    case 4:
        return new phasediagramts_finite_element_2();
    case 5:
        return new phasediagramts_finite_element_2();
    case 6:
        return new phasediagramts_finite_element_2();
    case 7:
        return new phasediagramts_finite_element_2();
    case 8:
        return new phasediagramts_finite_element_2();
    case 9:
        return new phasediagramts_finite_element_2();
    case 10:
        return new phasediagramts_finite_element_2();
    case 11:
        return new phasediagramts_finite_element_2();
    case 12:
        return new phasediagramts_finite_element_2();
    case 13:
        return new phasediagramts_finite_element_2();
    case 14:
        return new phasediagramts_finite_element_2();
    case 15:
        return new phasediagramts_finite_element_2();
    case 16:
        return new phasediagramts_finite_element_2();
    case 17:
        return new phasediagramts_finite_element_2();
    case 18:
        return new phasediagramts_finite_element_2();
    case 19:
        return new phasediagramts_finite_element_2();
    case 20:
        return new phasediagramts_finite_element_2();
    case 21:
        return new phasediagramts_finite_element_2();
    case 22:
        return new phasediagramts_finite_element_2();
    case 23:
        return new phasediagramts_finite_element_2();
    case 24:
        return new phasediagramts_finite_element_2();
    case 25:
        return new phasediagramts_finite_element_2();
    case 26:
        return new phasediagramts_finite_element_2();
    case 27:
        return new phasediagramts_finite_element_2();
    case 28:
        return new phasediagramts_finite_element_2();
    case 29:
        return new phasediagramts_finite_element_2();
    case 30:
        return new phasediagramts_finite_element_2();
    case 31:
        return new phasediagramts_finite_element_2();
    case 32:
        return new phasediagramts_finite_element_2();
    case 33:
        return new phasediagramts_finite_element_2();
    case 34:
        return new phasediagramts_finite_element_2();
    case 35:
        return new phasediagramts_finite_element_2();
    case 36:
        return new phasediagramts_finite_element_2();
    case 37:
        return new phasediagramts_finite_element_2();
    case 38:
        return new phasediagramts_finite_element_2();
    case 39:
        return new phasediagramts_finite_element_2();
    case 40:
        return new phasediagramts_finite_element_2();
    case 41:
        return new phasediagramts_finite_element_2();
    case 42:
        return new phasediagramts_finite_element_2();
    case 43:
        return new phasediagramts_finite_element_2();
    case 44:
        return new phasediagramts_finite_element_2();
    case 45:
        return new phasediagramts_finite_element_2();
    case 46:
        return new phasediagramts_finite_element_2();
    case 47:
        return new phasediagramts_finite_element_2();
    case 48:
        return new phasediagramts_finite_element_2();
    case 49:
        return new phasediagramts_finite_element_2();
    case 50:
        return new phasediagramts_finite_element_2();
    case 51:
        return new phasediagramts_finite_element_2();
    case 52:
        return new phasediagramts_finite_element_2();
    case 53:
        return new phasediagramts_finite_element_2();
    case 54:
        return new phasediagramts_finite_element_2();
    case 55:
        return new phasediagramts_finite_element_2();
    case 56:
        return new phasediagramts_finite_element_2();
    case 57:
        return new phasediagramts_finite_element_2();
    case 58:
        return new phasediagramts_finite_element_2();
    case 59:
        return new phasediagramts_finite_element_2();
    case 60:
        return new phasediagramts_finite_element_2();
    case 61:
        return new phasediagramts_finite_element_2();
    case 62:
        return new phasediagramts_finite_element_2();
    case 63:
        return new phasediagramts_finite_element_2();
    case 64:
        return new phasediagramts_finite_element_2();
    case 65:
        return new phasediagramts_finite_element_2();
    case 66:
        return new phasediagramts_finite_element_2();
    case 67:
        return new phasediagramts_finite_element_2();
    case 68:
        return new phasediagramts_finite_element_2();
    case 69:
        return new phasediagramts_finite_element_2();
    case 70:
        return new phasediagramts_finite_element_2();
    case 71:
        return new phasediagramts_finite_element_2();
    case 72:
        return new phasediagramts_finite_element_2();
    case 73:
        return new phasediagramts_finite_element_2();
    case 74:
        return new phasediagramts_finite_element_2();
    case 75:
        return new phasediagramts_finite_element_2();
    case 76:
        return new phasediagramts_finite_element_2();
    case 77:
        return new phasediagramts_finite_element_2();
    case 78:
        return new phasediagramts_finite_element_2();
    case 79:
        return new phasediagramts_finite_element_2();
    case 80:
        return new phasediagramts_finite_element_2();
    case 81:
        return new phasediagramts_finite_element_2();
    case 82:
        return new phasediagramts_finite_element_2();
    case 83:
        return new phasediagramts_finite_element_2();
    case 84:
        return new phasediagramts_finite_element_2();
    case 85:
        return new phasediagramts_finite_element_2();
    case 86:
        return new phasediagramts_finite_element_2();
    case 87:
        return new phasediagramts_finite_element_2();
    case 88:
        return new phasediagramts_finite_element_2();
    case 89:
        return new phasediagramts_finite_element_2();
    case 90:
        return new phasediagramts_finite_element_2();
    case 91:
        return new phasediagramts_finite_element_2();
    case 92:
        return new phasediagramts_finite_element_2();
    case 93:
        return new phasediagramts_finite_element_2();
    case 94:
        return new phasediagramts_finite_element_2();
    case 95:
        return new phasediagramts_finite_element_2();
    case 96:
        return new phasediagramts_finite_element_2();
    case 97:
        return new phasediagramts_finite_element_2();
    case 98:
        return new phasediagramts_finite_element_2();
    case 99:
        return new phasediagramts_finite_element_2();
    case 100:
        return new phasediagramts_finite_element_2();
    case 101:
        return new phasediagramts_finite_element_2();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new phasediagramts_finite_element_5();
  }

};


class phasediagramts_finite_element_6: public ufc::finite_element
{
public:

  phasediagramts_finite_element_6() : ufc::finite_element()
  {
    // Do nothing
  }

  ~phasediagramts_finite_element_6() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "TensorElement(FiniteElement('Discontinuous Lagrange', interval, 0), shape=(11, 17), symmetry={})";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::interval;
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t geometric_dimension() const final override
  {
    return 1;
  }

  std::size_t space_dimension() const final override
  {
    return 187;
  }

  std::size_t value_rank() const final override
  {
    return 2;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[2] = { 11, 17 };
    if (i >= 2)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 187;
  }

  std::size_t reference_value_rank() const final override
  {
    return 2;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[2] = { 11, 17 };
    if (i >= 2)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 187;
  }

  std::size_t degree() const final override
  {
    return 0;
  }

  const char * family() const final override
  {
    return "Discontinuous Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][1] = { { 1.414213562373095 } };
    for (std::size_t k = 0; k < num_points * 187 * 187; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        for (std::size_t p = 0; p < 1; ++p)
            basisvalues0[p] *= std::sqrt(0.5 + p);
        // Accumulate products of coefficients and basisvalues
        reference_values[187 * 187 * ip] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 + 1] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 2 + 2] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 3 + 3] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 4 + 4] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 5 + 5] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 6 + 6] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 7 + 7] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 8 + 8] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 9 + 9] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 10 + 10] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 11 + 11] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 12 + 12] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 13 + 13] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 14 + 14] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 15 + 15] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 16 + 16] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 17 + 17] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 18 + 18] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 19 + 19] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 20 + 20] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 21 + 21] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 22 + 22] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 23 + 23] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 24 + 24] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 25 + 25] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 26 + 26] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 27 + 27] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 28 + 28] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 29 + 29] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 30 + 30] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 31 + 31] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 32 + 32] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 33 + 33] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 34 + 34] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 35 + 35] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 36 + 36] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 37 + 37] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 38 + 38] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 39 + 39] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 40 + 40] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 41 + 41] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 42 + 42] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 43 + 43] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 44 + 44] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 45 + 45] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 46 + 46] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 47 + 47] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 48 + 48] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 49 + 49] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 50 + 50] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 51 + 51] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 52 + 52] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 53 + 53] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 54 + 54] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 55 + 55] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 56 + 56] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 57 + 57] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 58 + 58] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 59 + 59] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 60 + 60] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 61 + 61] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 62 + 62] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 63 + 63] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 64 + 64] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 65 + 65] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 66 + 66] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 67 + 67] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 68 + 68] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 69 + 69] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 70 + 70] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 71 + 71] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 72 + 72] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 73 + 73] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 74 + 74] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 75 + 75] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 76 + 76] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 77 + 77] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 78 + 78] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 79 + 79] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 80 + 80] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 81 + 81] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 82 + 82] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 83 + 83] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 84 + 84] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 85 + 85] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 86 + 86] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 87 + 87] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 88 + 88] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 89 + 89] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 90 + 90] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 91 + 91] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 92 + 92] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 93 + 93] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 94 + 94] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 95 + 95] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 96 + 96] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 97 + 97] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 98 + 98] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 99 + 99] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 100 + 100] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 101 + 101] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 102 + 102] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 103 + 103] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 104 + 104] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 105 + 105] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 106 + 106] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 107 + 107] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 108 + 108] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 109 + 109] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 110 + 110] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 111 + 111] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 112 + 112] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 113 + 113] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 114 + 114] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 115 + 115] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 116 + 116] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 117 + 117] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 118 + 118] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 119 + 119] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 120 + 120] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 121 + 121] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 122 + 122] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 123 + 123] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 124 + 124] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 125 + 125] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 126 + 126] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 127 + 127] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 128 + 128] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 129 + 129] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 130 + 130] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 131 + 131] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 132 + 132] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 133 + 133] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 134 + 134] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 135 + 135] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 136 + 136] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 137 + 137] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 138 + 138] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 139 + 139] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 140 + 140] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 141 + 141] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 142 + 142] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 143 + 143] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 144 + 144] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 145 + 145] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 146 + 146] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 147 + 147] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 148 + 148] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 149 + 149] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 150 + 150] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 151 + 151] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 152 + 152] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 153 + 153] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 154 + 154] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 155 + 155] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 156 + 156] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 157 + 157] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 158 + 158] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 159 + 159] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 160 + 160] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 161 + 161] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 162 + 162] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 163 + 163] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 164 + 164] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 165 + 165] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 166 + 166] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 167 + 167] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 168 + 168] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 169 + 169] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 170 + 170] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 171 + 171] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 172 + 172] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 173 + 173] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 174 + 174] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 175 + 175] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 176 + 176] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 177 + 177] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 178 + 178] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 179 + 179] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 180 + 180] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 181 + 181] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 182 + 182] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 183 + 183] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 184 + 184] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 185 + 185] += coefficients0[0][0] * basisvalues0[0];
        reference_values[187 * 187 * ip + 187 * 186 + 186] += coefficients0[0][0] * basisvalues0[0];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(1, order);
    std::fill_n(reference_values, num_points * 187 * num_derivatives * 187, 0.0);
    if (order > 0)
        return;
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    std::fill_n(values, num_points * 187 * 187, 0.0);
    const std::size_t reference_offsets[187] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186 };
    const std::size_t physical_offsets[187] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 187; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[187 * 187 * ip + 187 * d + 187 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[187 * 187 * ip + 187 * d + 187 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[1] = {};
    double J[1];
    double detJ;
    double K[1];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_interval_1d(J, coordinate_dofs);
        compute_jacobian_inverse_interval_1d(K, detJ, J);
    }
    // Evaluate basis on reference element
    double ref_values[34969];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[34969];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 187; ++k)
        values[k] = physical_values[187 * i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold values of a single dof.
    double dof_values[187] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 187; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 187; ++s)
            values[r * 187 + s] = dof_values[s];
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(1, n);
    std::fill_n(values, 187 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(1, n);
    // Set values equal to zero.
    std::fill_n(values, 187 * num_derivatives * 187, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[187] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 187; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 187 * num_derivatives; ++s)
            values[187 * num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[187];
    // Declare variable for physical coordinates
    double y[1];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 2:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 3:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 4:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 5:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 6:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 7:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 8:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 9:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[9];
        }
        break;
    case 10:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[10];
        }
        break;
    case 11:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[11];
        }
        break;
    case 12:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[12];
        }
        break;
    case 13:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[13];
        }
        break;
    case 14:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[14];
        }
        break;
    case 15:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[15];
        }
        break;
    case 16:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[16];
        }
        break;
    case 17:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[17];
        }
        break;
    case 18:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[18];
        }
        break;
    case 19:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[19];
        }
        break;
    case 20:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[20];
        }
        break;
    case 21:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[21];
        }
        break;
    case 22:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[22];
        }
        break;
    case 23:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[23];
        }
        break;
    case 24:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[24];
        }
        break;
    case 25:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[25];
        }
        break;
    case 26:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[26];
        }
        break;
    case 27:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[27];
        }
        break;
    case 28:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[28];
        }
        break;
    case 29:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[29];
        }
        break;
    case 30:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[30];
        }
        break;
    case 31:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[31];
        }
        break;
    case 32:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[32];
        }
        break;
    case 33:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[33];
        }
        break;
    case 34:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[34];
        }
        break;
    case 35:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[35];
        }
        break;
    case 36:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[36];
        }
        break;
    case 37:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[37];
        }
        break;
    case 38:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[38];
        }
        break;
    case 39:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[39];
        }
        break;
    case 40:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[40];
        }
        break;
    case 41:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[41];
        }
        break;
    case 42:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[42];
        }
        break;
    case 43:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[43];
        }
        break;
    case 44:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[44];
        }
        break;
    case 45:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[45];
        }
        break;
    case 46:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[46];
        }
        break;
    case 47:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[47];
        }
        break;
    case 48:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[48];
        }
        break;
    case 49:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[49];
        }
        break;
    case 50:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[50];
        }
        break;
    case 51:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[51];
        }
        break;
    case 52:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[52];
        }
        break;
    case 53:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[53];
        }
        break;
    case 54:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[54];
        }
        break;
    case 55:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[55];
        }
        break;
    case 56:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[56];
        }
        break;
    case 57:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[57];
        }
        break;
    case 58:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[58];
        }
        break;
    case 59:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[59];
        }
        break;
    case 60:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[60];
        }
        break;
    case 61:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[61];
        }
        break;
    case 62:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[62];
        }
        break;
    case 63:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[63];
        }
        break;
    case 64:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[64];
        }
        break;
    case 65:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[65];
        }
        break;
    case 66:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[66];
        }
        break;
    case 67:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[67];
        }
        break;
    case 68:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[68];
        }
        break;
    case 69:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[69];
        }
        break;
    case 70:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[70];
        }
        break;
    case 71:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[71];
        }
        break;
    case 72:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[72];
        }
        break;
    case 73:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[73];
        }
        break;
    case 74:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[74];
        }
        break;
    case 75:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[75];
        }
        break;
    case 76:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[76];
        }
        break;
    case 77:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[77];
        }
        break;
    case 78:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[78];
        }
        break;
    case 79:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[79];
        }
        break;
    case 80:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[80];
        }
        break;
    case 81:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[81];
        }
        break;
    case 82:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[82];
        }
        break;
    case 83:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[83];
        }
        break;
    case 84:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[84];
        }
        break;
    case 85:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[85];
        }
        break;
    case 86:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[86];
        }
        break;
    case 87:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[87];
        }
        break;
    case 88:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[88];
        }
        break;
    case 89:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[89];
        }
        break;
    case 90:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[90];
        }
        break;
    case 91:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[91];
        }
        break;
    case 92:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[92];
        }
        break;
    case 93:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[93];
        }
        break;
    case 94:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[94];
        }
        break;
    case 95:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[95];
        }
        break;
    case 96:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[96];
        }
        break;
    case 97:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[97];
        }
        break;
    case 98:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[98];
        }
        break;
    case 99:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[99];
        }
        break;
    case 100:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[100];
        }
        break;
    case 101:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[101];
        }
        break;
    case 102:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[102];
        }
        break;
    case 103:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[103];
        }
        break;
    case 104:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[104];
        }
        break;
    case 105:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[105];
        }
        break;
    case 106:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[106];
        }
        break;
    case 107:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[107];
        }
        break;
    case 108:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[108];
        }
        break;
    case 109:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[109];
        }
        break;
    case 110:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[110];
        }
        break;
    case 111:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[111];
        }
        break;
    case 112:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[112];
        }
        break;
    case 113:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[113];
        }
        break;
    case 114:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[114];
        }
        break;
    case 115:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[115];
        }
        break;
    case 116:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[116];
        }
        break;
    case 117:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[117];
        }
        break;
    case 118:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[118];
        }
        break;
    case 119:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[119];
        }
        break;
    case 120:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[120];
        }
        break;
    case 121:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[121];
        }
        break;
    case 122:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[122];
        }
        break;
    case 123:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[123];
        }
        break;
    case 124:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[124];
        }
        break;
    case 125:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[125];
        }
        break;
    case 126:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[126];
        }
        break;
    case 127:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[127];
        }
        break;
    case 128:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[128];
        }
        break;
    case 129:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[129];
        }
        break;
    case 130:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[130];
        }
        break;
    case 131:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[131];
        }
        break;
    case 132:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[132];
        }
        break;
    case 133:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[133];
        }
        break;
    case 134:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[134];
        }
        break;
    case 135:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[135];
        }
        break;
    case 136:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[136];
        }
        break;
    case 137:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[137];
        }
        break;
    case 138:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[138];
        }
        break;
    case 139:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[139];
        }
        break;
    case 140:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[140];
        }
        break;
    case 141:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[141];
        }
        break;
    case 142:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[142];
        }
        break;
    case 143:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[143];
        }
        break;
    case 144:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[144];
        }
        break;
    case 145:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[145];
        }
        break;
    case 146:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[146];
        }
        break;
    case 147:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[147];
        }
        break;
    case 148:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[148];
        }
        break;
    case 149:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[149];
        }
        break;
    case 150:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[150];
        }
        break;
    case 151:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[151];
        }
        break;
    case 152:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[152];
        }
        break;
    case 153:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[153];
        }
        break;
    case 154:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[154];
        }
        break;
    case 155:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[155];
        }
        break;
    case 156:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[156];
        }
        break;
    case 157:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[157];
        }
        break;
    case 158:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[158];
        }
        break;
    case 159:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[159];
        }
        break;
    case 160:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[160];
        }
        break;
    case 161:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[161];
        }
        break;
    case 162:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[162];
        }
        break;
    case 163:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[163];
        }
        break;
    case 164:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[164];
        }
        break;
    case 165:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[165];
        }
        break;
    case 166:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[166];
        }
        break;
    case 167:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[167];
        }
        break;
    case 168:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[168];
        }
        break;
    case 169:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[169];
        }
        break;
    case 170:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[170];
        }
        break;
    case 171:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[171];
        }
        break;
    case 172:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[172];
        }
        break;
    case 173:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[173];
        }
        break;
    case 174:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[174];
        }
        break;
    case 175:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[175];
        }
        break;
    case 176:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[176];
        }
        break;
    case 177:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[177];
        }
        break;
    case 178:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[178];
        }
        break;
    case 179:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[179];
        }
        break;
    case 180:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[180];
        }
        break;
    case 181:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[181];
        }
        break;
    case 182:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[182];
        }
        break;
    case 183:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[183];
        }
        break;
    case 184:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[184];
        }
        break;
    case 185:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[185];
        }
        break;
    case 186:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[186];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[187];
    // Declare variable for physical coordinates
    double y[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[1] = vals[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[2] = vals[2];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[3];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[4] = vals[4];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[5] = vals[5];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[6] = vals[6];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[7] = vals[7];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[8] = vals[8];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[9] = vals[9];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[10] = vals[10];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[11] = vals[11];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[12] = vals[12];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[13] = vals[13];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[14] = vals[14];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[15] = vals[15];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[16] = vals[16];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[17] = vals[17];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[18] = vals[18];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[19] = vals[19];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[20] = vals[20];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[21] = vals[21];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[22] = vals[22];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[23] = vals[23];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[24] = vals[24];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[25] = vals[25];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[26] = vals[26];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[27] = vals[27];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[28] = vals[28];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[29] = vals[29];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[30] = vals[30];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[31] = vals[31];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[32] = vals[32];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[33] = vals[33];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[34] = vals[34];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[35] = vals[35];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[36] = vals[36];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[37] = vals[37];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[38] = vals[38];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[39] = vals[39];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[40] = vals[40];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[41] = vals[41];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[42] = vals[42];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[43] = vals[43];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[44] = vals[44];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[45] = vals[45];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[46] = vals[46];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[47] = vals[47];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[48] = vals[48];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[49] = vals[49];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[50] = vals[50];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[51] = vals[51];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[52] = vals[52];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[53] = vals[53];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[54] = vals[54];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[55] = vals[55];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[56] = vals[56];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[57] = vals[57];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[58] = vals[58];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[59] = vals[59];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[60] = vals[60];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[61] = vals[61];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[62] = vals[62];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[63] = vals[63];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[64] = vals[64];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[65] = vals[65];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[66] = vals[66];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[67] = vals[67];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[68] = vals[68];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[69] = vals[69];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[70] = vals[70];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[71] = vals[71];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[72] = vals[72];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[73] = vals[73];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[74] = vals[74];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[75] = vals[75];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[76] = vals[76];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[77] = vals[77];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[78] = vals[78];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[79] = vals[79];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[80] = vals[80];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[81] = vals[81];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[82] = vals[82];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[83] = vals[83];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[84] = vals[84];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[85] = vals[85];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[86] = vals[86];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[87] = vals[87];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[88] = vals[88];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[89] = vals[89];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[90] = vals[90];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[91] = vals[91];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[92] = vals[92];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[93] = vals[93];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[94] = vals[94];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[95] = vals[95];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[96] = vals[96];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[97] = vals[97];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[98] = vals[98];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[99] = vals[99];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[100] = vals[100];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[101] = vals[101];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[102] = vals[102];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[103] = vals[103];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[104] = vals[104];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[105] = vals[105];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[106] = vals[106];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[107] = vals[107];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[108] = vals[108];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[109] = vals[109];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[110] = vals[110];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[111] = vals[111];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[112] = vals[112];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[113] = vals[113];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[114] = vals[114];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[115] = vals[115];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[116] = vals[116];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[117] = vals[117];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[118] = vals[118];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[119] = vals[119];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[120] = vals[120];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[121] = vals[121];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[122] = vals[122];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[123] = vals[123];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[124] = vals[124];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[125] = vals[125];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[126] = vals[126];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[127] = vals[127];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[128] = vals[128];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[129] = vals[129];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[130] = vals[130];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[131] = vals[131];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[132] = vals[132];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[133] = vals[133];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[134] = vals[134];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[135] = vals[135];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[136] = vals[136];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[137] = vals[137];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[138] = vals[138];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[139] = vals[139];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[140] = vals[140];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[141] = vals[141];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[142] = vals[142];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[143] = vals[143];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[144] = vals[144];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[145] = vals[145];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[146] = vals[146];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[147] = vals[147];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[148] = vals[148];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[149] = vals[149];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[150] = vals[150];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[151] = vals[151];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[152] = vals[152];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[153] = vals[153];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[154] = vals[154];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[155] = vals[155];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[156] = vals[156];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[157] = vals[157];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[158] = vals[158];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[159] = vals[159];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[160] = vals[160];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[161] = vals[161];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[162] = vals[162];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[163] = vals[163];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[164] = vals[164];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[165] = vals[165];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[166] = vals[166];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[167] = vals[167];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[168] = vals[168];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[169] = vals[169];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[170] = vals[170];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[171] = vals[171];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[172] = vals[172];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[173] = vals[173];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[174] = vals[174];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[175] = vals[175];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[176] = vals[176];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[177] = vals[177];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[178] = vals[178];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[179] = vals[179];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[180] = vals[180];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[181] = vals[181];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[182] = vals[182];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[183] = vals[183];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[184] = vals[184];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[185] = vals[185];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[186] = vals[186];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[187] = dof_values[0];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[1];
    vertex_values[188] = dof_values[1];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[2];
    vertex_values[189] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[3] = dof_values[3];
    vertex_values[190] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[4] = dof_values[4];
    vertex_values[191] = dof_values[4];
    // Evaluate function and change variables
    vertex_values[5] = dof_values[5];
    vertex_values[192] = dof_values[5];
    // Evaluate function and change variables
    vertex_values[6] = dof_values[6];
    vertex_values[193] = dof_values[6];
    // Evaluate function and change variables
    vertex_values[7] = dof_values[7];
    vertex_values[194] = dof_values[7];
    // Evaluate function and change variables
    vertex_values[8] = dof_values[8];
    vertex_values[195] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[9] = dof_values[9];
    vertex_values[196] = dof_values[9];
    // Evaluate function and change variables
    vertex_values[10] = dof_values[10];
    vertex_values[197] = dof_values[10];
    // Evaluate function and change variables
    vertex_values[11] = dof_values[11];
    vertex_values[198] = dof_values[11];
    // Evaluate function and change variables
    vertex_values[12] = dof_values[12];
    vertex_values[199] = dof_values[12];
    // Evaluate function and change variables
    vertex_values[13] = dof_values[13];
    vertex_values[200] = dof_values[13];
    // Evaluate function and change variables
    vertex_values[14] = dof_values[14];
    vertex_values[201] = dof_values[14];
    // Evaluate function and change variables
    vertex_values[15] = dof_values[15];
    vertex_values[202] = dof_values[15];
    // Evaluate function and change variables
    vertex_values[16] = dof_values[16];
    vertex_values[203] = dof_values[16];
    // Evaluate function and change variables
    vertex_values[17] = dof_values[17];
    vertex_values[204] = dof_values[17];
    // Evaluate function and change variables
    vertex_values[18] = dof_values[18];
    vertex_values[205] = dof_values[18];
    // Evaluate function and change variables
    vertex_values[19] = dof_values[19];
    vertex_values[206] = dof_values[19];
    // Evaluate function and change variables
    vertex_values[20] = dof_values[20];
    vertex_values[207] = dof_values[20];
    // Evaluate function and change variables
    vertex_values[21] = dof_values[21];
    vertex_values[208] = dof_values[21];
    // Evaluate function and change variables
    vertex_values[22] = dof_values[22];
    vertex_values[209] = dof_values[22];
    // Evaluate function and change variables
    vertex_values[23] = dof_values[23];
    vertex_values[210] = dof_values[23];
    // Evaluate function and change variables
    vertex_values[24] = dof_values[24];
    vertex_values[211] = dof_values[24];
    // Evaluate function and change variables
    vertex_values[25] = dof_values[25];
    vertex_values[212] = dof_values[25];
    // Evaluate function and change variables
    vertex_values[26] = dof_values[26];
    vertex_values[213] = dof_values[26];
    // Evaluate function and change variables
    vertex_values[27] = dof_values[27];
    vertex_values[214] = dof_values[27];
    // Evaluate function and change variables
    vertex_values[28] = dof_values[28];
    vertex_values[215] = dof_values[28];
    // Evaluate function and change variables
    vertex_values[29] = dof_values[29];
    vertex_values[216] = dof_values[29];
    // Evaluate function and change variables
    vertex_values[30] = dof_values[30];
    vertex_values[217] = dof_values[30];
    // Evaluate function and change variables
    vertex_values[31] = dof_values[31];
    vertex_values[218] = dof_values[31];
    // Evaluate function and change variables
    vertex_values[32] = dof_values[32];
    vertex_values[219] = dof_values[32];
    // Evaluate function and change variables
    vertex_values[33] = dof_values[33];
    vertex_values[220] = dof_values[33];
    // Evaluate function and change variables
    vertex_values[34] = dof_values[34];
    vertex_values[221] = dof_values[34];
    // Evaluate function and change variables
    vertex_values[35] = dof_values[35];
    vertex_values[222] = dof_values[35];
    // Evaluate function and change variables
    vertex_values[36] = dof_values[36];
    vertex_values[223] = dof_values[36];
    // Evaluate function and change variables
    vertex_values[37] = dof_values[37];
    vertex_values[224] = dof_values[37];
    // Evaluate function and change variables
    vertex_values[38] = dof_values[38];
    vertex_values[225] = dof_values[38];
    // Evaluate function and change variables
    vertex_values[39] = dof_values[39];
    vertex_values[226] = dof_values[39];
    // Evaluate function and change variables
    vertex_values[40] = dof_values[40];
    vertex_values[227] = dof_values[40];
    // Evaluate function and change variables
    vertex_values[41] = dof_values[41];
    vertex_values[228] = dof_values[41];
    // Evaluate function and change variables
    vertex_values[42] = dof_values[42];
    vertex_values[229] = dof_values[42];
    // Evaluate function and change variables
    vertex_values[43] = dof_values[43];
    vertex_values[230] = dof_values[43];
    // Evaluate function and change variables
    vertex_values[44] = dof_values[44];
    vertex_values[231] = dof_values[44];
    // Evaluate function and change variables
    vertex_values[45] = dof_values[45];
    vertex_values[232] = dof_values[45];
    // Evaluate function and change variables
    vertex_values[46] = dof_values[46];
    vertex_values[233] = dof_values[46];
    // Evaluate function and change variables
    vertex_values[47] = dof_values[47];
    vertex_values[234] = dof_values[47];
    // Evaluate function and change variables
    vertex_values[48] = dof_values[48];
    vertex_values[235] = dof_values[48];
    // Evaluate function and change variables
    vertex_values[49] = dof_values[49];
    vertex_values[236] = dof_values[49];
    // Evaluate function and change variables
    vertex_values[50] = dof_values[50];
    vertex_values[237] = dof_values[50];
    // Evaluate function and change variables
    vertex_values[51] = dof_values[51];
    vertex_values[238] = dof_values[51];
    // Evaluate function and change variables
    vertex_values[52] = dof_values[52];
    vertex_values[239] = dof_values[52];
    // Evaluate function and change variables
    vertex_values[53] = dof_values[53];
    vertex_values[240] = dof_values[53];
    // Evaluate function and change variables
    vertex_values[54] = dof_values[54];
    vertex_values[241] = dof_values[54];
    // Evaluate function and change variables
    vertex_values[55] = dof_values[55];
    vertex_values[242] = dof_values[55];
    // Evaluate function and change variables
    vertex_values[56] = dof_values[56];
    vertex_values[243] = dof_values[56];
    // Evaluate function and change variables
    vertex_values[57] = dof_values[57];
    vertex_values[244] = dof_values[57];
    // Evaluate function and change variables
    vertex_values[58] = dof_values[58];
    vertex_values[245] = dof_values[58];
    // Evaluate function and change variables
    vertex_values[59] = dof_values[59];
    vertex_values[246] = dof_values[59];
    // Evaluate function and change variables
    vertex_values[60] = dof_values[60];
    vertex_values[247] = dof_values[60];
    // Evaluate function and change variables
    vertex_values[61] = dof_values[61];
    vertex_values[248] = dof_values[61];
    // Evaluate function and change variables
    vertex_values[62] = dof_values[62];
    vertex_values[249] = dof_values[62];
    // Evaluate function and change variables
    vertex_values[63] = dof_values[63];
    vertex_values[250] = dof_values[63];
    // Evaluate function and change variables
    vertex_values[64] = dof_values[64];
    vertex_values[251] = dof_values[64];
    // Evaluate function and change variables
    vertex_values[65] = dof_values[65];
    vertex_values[252] = dof_values[65];
    // Evaluate function and change variables
    vertex_values[66] = dof_values[66];
    vertex_values[253] = dof_values[66];
    // Evaluate function and change variables
    vertex_values[67] = dof_values[67];
    vertex_values[254] = dof_values[67];
    // Evaluate function and change variables
    vertex_values[68] = dof_values[68];
    vertex_values[255] = dof_values[68];
    // Evaluate function and change variables
    vertex_values[69] = dof_values[69];
    vertex_values[256] = dof_values[69];
    // Evaluate function and change variables
    vertex_values[70] = dof_values[70];
    vertex_values[257] = dof_values[70];
    // Evaluate function and change variables
    vertex_values[71] = dof_values[71];
    vertex_values[258] = dof_values[71];
    // Evaluate function and change variables
    vertex_values[72] = dof_values[72];
    vertex_values[259] = dof_values[72];
    // Evaluate function and change variables
    vertex_values[73] = dof_values[73];
    vertex_values[260] = dof_values[73];
    // Evaluate function and change variables
    vertex_values[74] = dof_values[74];
    vertex_values[261] = dof_values[74];
    // Evaluate function and change variables
    vertex_values[75] = dof_values[75];
    vertex_values[262] = dof_values[75];
    // Evaluate function and change variables
    vertex_values[76] = dof_values[76];
    vertex_values[263] = dof_values[76];
    // Evaluate function and change variables
    vertex_values[77] = dof_values[77];
    vertex_values[264] = dof_values[77];
    // Evaluate function and change variables
    vertex_values[78] = dof_values[78];
    vertex_values[265] = dof_values[78];
    // Evaluate function and change variables
    vertex_values[79] = dof_values[79];
    vertex_values[266] = dof_values[79];
    // Evaluate function and change variables
    vertex_values[80] = dof_values[80];
    vertex_values[267] = dof_values[80];
    // Evaluate function and change variables
    vertex_values[81] = dof_values[81];
    vertex_values[268] = dof_values[81];
    // Evaluate function and change variables
    vertex_values[82] = dof_values[82];
    vertex_values[269] = dof_values[82];
    // Evaluate function and change variables
    vertex_values[83] = dof_values[83];
    vertex_values[270] = dof_values[83];
    // Evaluate function and change variables
    vertex_values[84] = dof_values[84];
    vertex_values[271] = dof_values[84];
    // Evaluate function and change variables
    vertex_values[85] = dof_values[85];
    vertex_values[272] = dof_values[85];
    // Evaluate function and change variables
    vertex_values[86] = dof_values[86];
    vertex_values[273] = dof_values[86];
    // Evaluate function and change variables
    vertex_values[87] = dof_values[87];
    vertex_values[274] = dof_values[87];
    // Evaluate function and change variables
    vertex_values[88] = dof_values[88];
    vertex_values[275] = dof_values[88];
    // Evaluate function and change variables
    vertex_values[89] = dof_values[89];
    vertex_values[276] = dof_values[89];
    // Evaluate function and change variables
    vertex_values[90] = dof_values[90];
    vertex_values[277] = dof_values[90];
    // Evaluate function and change variables
    vertex_values[91] = dof_values[91];
    vertex_values[278] = dof_values[91];
    // Evaluate function and change variables
    vertex_values[92] = dof_values[92];
    vertex_values[279] = dof_values[92];
    // Evaluate function and change variables
    vertex_values[93] = dof_values[93];
    vertex_values[280] = dof_values[93];
    // Evaluate function and change variables
    vertex_values[94] = dof_values[94];
    vertex_values[281] = dof_values[94];
    // Evaluate function and change variables
    vertex_values[95] = dof_values[95];
    vertex_values[282] = dof_values[95];
    // Evaluate function and change variables
    vertex_values[96] = dof_values[96];
    vertex_values[283] = dof_values[96];
    // Evaluate function and change variables
    vertex_values[97] = dof_values[97];
    vertex_values[284] = dof_values[97];
    // Evaluate function and change variables
    vertex_values[98] = dof_values[98];
    vertex_values[285] = dof_values[98];
    // Evaluate function and change variables
    vertex_values[99] = dof_values[99];
    vertex_values[286] = dof_values[99];
    // Evaluate function and change variables
    vertex_values[100] = dof_values[100];
    vertex_values[287] = dof_values[100];
    // Evaluate function and change variables
    vertex_values[101] = dof_values[101];
    vertex_values[288] = dof_values[101];
    // Evaluate function and change variables
    vertex_values[102] = dof_values[102];
    vertex_values[289] = dof_values[102];
    // Evaluate function and change variables
    vertex_values[103] = dof_values[103];
    vertex_values[290] = dof_values[103];
    // Evaluate function and change variables
    vertex_values[104] = dof_values[104];
    vertex_values[291] = dof_values[104];
    // Evaluate function and change variables
    vertex_values[105] = dof_values[105];
    vertex_values[292] = dof_values[105];
    // Evaluate function and change variables
    vertex_values[106] = dof_values[106];
    vertex_values[293] = dof_values[106];
    // Evaluate function and change variables
    vertex_values[107] = dof_values[107];
    vertex_values[294] = dof_values[107];
    // Evaluate function and change variables
    vertex_values[108] = dof_values[108];
    vertex_values[295] = dof_values[108];
    // Evaluate function and change variables
    vertex_values[109] = dof_values[109];
    vertex_values[296] = dof_values[109];
    // Evaluate function and change variables
    vertex_values[110] = dof_values[110];
    vertex_values[297] = dof_values[110];
    // Evaluate function and change variables
    vertex_values[111] = dof_values[111];
    vertex_values[298] = dof_values[111];
    // Evaluate function and change variables
    vertex_values[112] = dof_values[112];
    vertex_values[299] = dof_values[112];
    // Evaluate function and change variables
    vertex_values[113] = dof_values[113];
    vertex_values[300] = dof_values[113];
    // Evaluate function and change variables
    vertex_values[114] = dof_values[114];
    vertex_values[301] = dof_values[114];
    // Evaluate function and change variables
    vertex_values[115] = dof_values[115];
    vertex_values[302] = dof_values[115];
    // Evaluate function and change variables
    vertex_values[116] = dof_values[116];
    vertex_values[303] = dof_values[116];
    // Evaluate function and change variables
    vertex_values[117] = dof_values[117];
    vertex_values[304] = dof_values[117];
    // Evaluate function and change variables
    vertex_values[118] = dof_values[118];
    vertex_values[305] = dof_values[118];
    // Evaluate function and change variables
    vertex_values[119] = dof_values[119];
    vertex_values[306] = dof_values[119];
    // Evaluate function and change variables
    vertex_values[120] = dof_values[120];
    vertex_values[307] = dof_values[120];
    // Evaluate function and change variables
    vertex_values[121] = dof_values[121];
    vertex_values[308] = dof_values[121];
    // Evaluate function and change variables
    vertex_values[122] = dof_values[122];
    vertex_values[309] = dof_values[122];
    // Evaluate function and change variables
    vertex_values[123] = dof_values[123];
    vertex_values[310] = dof_values[123];
    // Evaluate function and change variables
    vertex_values[124] = dof_values[124];
    vertex_values[311] = dof_values[124];
    // Evaluate function and change variables
    vertex_values[125] = dof_values[125];
    vertex_values[312] = dof_values[125];
    // Evaluate function and change variables
    vertex_values[126] = dof_values[126];
    vertex_values[313] = dof_values[126];
    // Evaluate function and change variables
    vertex_values[127] = dof_values[127];
    vertex_values[314] = dof_values[127];
    // Evaluate function and change variables
    vertex_values[128] = dof_values[128];
    vertex_values[315] = dof_values[128];
    // Evaluate function and change variables
    vertex_values[129] = dof_values[129];
    vertex_values[316] = dof_values[129];
    // Evaluate function and change variables
    vertex_values[130] = dof_values[130];
    vertex_values[317] = dof_values[130];
    // Evaluate function and change variables
    vertex_values[131] = dof_values[131];
    vertex_values[318] = dof_values[131];
    // Evaluate function and change variables
    vertex_values[132] = dof_values[132];
    vertex_values[319] = dof_values[132];
    // Evaluate function and change variables
    vertex_values[133] = dof_values[133];
    vertex_values[320] = dof_values[133];
    // Evaluate function and change variables
    vertex_values[134] = dof_values[134];
    vertex_values[321] = dof_values[134];
    // Evaluate function and change variables
    vertex_values[135] = dof_values[135];
    vertex_values[322] = dof_values[135];
    // Evaluate function and change variables
    vertex_values[136] = dof_values[136];
    vertex_values[323] = dof_values[136];
    // Evaluate function and change variables
    vertex_values[137] = dof_values[137];
    vertex_values[324] = dof_values[137];
    // Evaluate function and change variables
    vertex_values[138] = dof_values[138];
    vertex_values[325] = dof_values[138];
    // Evaluate function and change variables
    vertex_values[139] = dof_values[139];
    vertex_values[326] = dof_values[139];
    // Evaluate function and change variables
    vertex_values[140] = dof_values[140];
    vertex_values[327] = dof_values[140];
    // Evaluate function and change variables
    vertex_values[141] = dof_values[141];
    vertex_values[328] = dof_values[141];
    // Evaluate function and change variables
    vertex_values[142] = dof_values[142];
    vertex_values[329] = dof_values[142];
    // Evaluate function and change variables
    vertex_values[143] = dof_values[143];
    vertex_values[330] = dof_values[143];
    // Evaluate function and change variables
    vertex_values[144] = dof_values[144];
    vertex_values[331] = dof_values[144];
    // Evaluate function and change variables
    vertex_values[145] = dof_values[145];
    vertex_values[332] = dof_values[145];
    // Evaluate function and change variables
    vertex_values[146] = dof_values[146];
    vertex_values[333] = dof_values[146];
    // Evaluate function and change variables
    vertex_values[147] = dof_values[147];
    vertex_values[334] = dof_values[147];
    // Evaluate function and change variables
    vertex_values[148] = dof_values[148];
    vertex_values[335] = dof_values[148];
    // Evaluate function and change variables
    vertex_values[149] = dof_values[149];
    vertex_values[336] = dof_values[149];
    // Evaluate function and change variables
    vertex_values[150] = dof_values[150];
    vertex_values[337] = dof_values[150];
    // Evaluate function and change variables
    vertex_values[151] = dof_values[151];
    vertex_values[338] = dof_values[151];
    // Evaluate function and change variables
    vertex_values[152] = dof_values[152];
    vertex_values[339] = dof_values[152];
    // Evaluate function and change variables
    vertex_values[153] = dof_values[153];
    vertex_values[340] = dof_values[153];
    // Evaluate function and change variables
    vertex_values[154] = dof_values[154];
    vertex_values[341] = dof_values[154];
    // Evaluate function and change variables
    vertex_values[155] = dof_values[155];
    vertex_values[342] = dof_values[155];
    // Evaluate function and change variables
    vertex_values[156] = dof_values[156];
    vertex_values[343] = dof_values[156];
    // Evaluate function and change variables
    vertex_values[157] = dof_values[157];
    vertex_values[344] = dof_values[157];
    // Evaluate function and change variables
    vertex_values[158] = dof_values[158];
    vertex_values[345] = dof_values[158];
    // Evaluate function and change variables
    vertex_values[159] = dof_values[159];
    vertex_values[346] = dof_values[159];
    // Evaluate function and change variables
    vertex_values[160] = dof_values[160];
    vertex_values[347] = dof_values[160];
    // Evaluate function and change variables
    vertex_values[161] = dof_values[161];
    vertex_values[348] = dof_values[161];
    // Evaluate function and change variables
    vertex_values[162] = dof_values[162];
    vertex_values[349] = dof_values[162];
    // Evaluate function and change variables
    vertex_values[163] = dof_values[163];
    vertex_values[350] = dof_values[163];
    // Evaluate function and change variables
    vertex_values[164] = dof_values[164];
    vertex_values[351] = dof_values[164];
    // Evaluate function and change variables
    vertex_values[165] = dof_values[165];
    vertex_values[352] = dof_values[165];
    // Evaluate function and change variables
    vertex_values[166] = dof_values[166];
    vertex_values[353] = dof_values[166];
    // Evaluate function and change variables
    vertex_values[167] = dof_values[167];
    vertex_values[354] = dof_values[167];
    // Evaluate function and change variables
    vertex_values[168] = dof_values[168];
    vertex_values[355] = dof_values[168];
    // Evaluate function and change variables
    vertex_values[169] = dof_values[169];
    vertex_values[356] = dof_values[169];
    // Evaluate function and change variables
    vertex_values[170] = dof_values[170];
    vertex_values[357] = dof_values[170];
    // Evaluate function and change variables
    vertex_values[171] = dof_values[171];
    vertex_values[358] = dof_values[171];
    // Evaluate function and change variables
    vertex_values[172] = dof_values[172];
    vertex_values[359] = dof_values[172];
    // Evaluate function and change variables
    vertex_values[173] = dof_values[173];
    vertex_values[360] = dof_values[173];
    // Evaluate function and change variables
    vertex_values[174] = dof_values[174];
    vertex_values[361] = dof_values[174];
    // Evaluate function and change variables
    vertex_values[175] = dof_values[175];
    vertex_values[362] = dof_values[175];
    // Evaluate function and change variables
    vertex_values[176] = dof_values[176];
    vertex_values[363] = dof_values[176];
    // Evaluate function and change variables
    vertex_values[177] = dof_values[177];
    vertex_values[364] = dof_values[177];
    // Evaluate function and change variables
    vertex_values[178] = dof_values[178];
    vertex_values[365] = dof_values[178];
    // Evaluate function and change variables
    vertex_values[179] = dof_values[179];
    vertex_values[366] = dof_values[179];
    // Evaluate function and change variables
    vertex_values[180] = dof_values[180];
    vertex_values[367] = dof_values[180];
    // Evaluate function and change variables
    vertex_values[181] = dof_values[181];
    vertex_values[368] = dof_values[181];
    // Evaluate function and change variables
    vertex_values[182] = dof_values[182];
    vertex_values[369] = dof_values[182];
    // Evaluate function and change variables
    vertex_values[183] = dof_values[183];
    vertex_values[370] = dof_values[183];
    // Evaluate function and change variables
    vertex_values[184] = dof_values[184];
    vertex_values[371] = dof_values[184];
    // Evaluate function and change variables
    vertex_values[185] = dof_values[185];
    vertex_values[372] = dof_values[185];
    // Evaluate function and change variables
    vertex_values[186] = dof_values[186];
    vertex_values[373] = dof_values[186];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[1] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[2] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[3] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[4] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[5] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[6] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[7] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[8] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[9] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[10] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[11] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[12] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[13] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[14] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[15] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[16] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[17] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[18] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[19] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[20] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[21] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[22] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[23] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[24] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[25] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[26] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[27] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[28] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[29] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[30] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[31] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[32] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[33] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[34] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[35] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[36] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[37] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[38] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[39] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[40] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[41] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[42] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[43] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[44] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[45] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[46] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[47] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[48] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[49] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[50] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[51] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[52] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[53] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[54] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[55] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[56] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[57] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[58] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[59] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[60] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[61] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[62] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[63] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[64] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[65] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[66] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[67] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[68] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[69] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[70] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[71] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[72] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[73] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[74] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[75] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[76] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[77] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[78] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[79] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[80] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[81] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[82] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[83] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[84] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[85] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[86] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[87] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[88] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[89] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[90] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[91] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[92] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[93] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[94] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[95] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[96] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[97] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[98] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[99] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[100] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[101] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[102] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[103] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[104] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[105] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[106] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[107] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[108] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[109] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[110] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[111] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[112] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[113] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[114] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[115] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[116] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[117] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[118] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[119] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[120] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[121] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[122] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[123] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[124] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[125] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[126] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[127] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[128] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[129] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[130] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[131] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[132] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[133] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[134] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[135] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[136] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[137] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[138] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[139] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[140] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[141] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[142] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[143] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[144] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[145] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[146] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[147] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[148] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[149] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[150] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[151] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[152] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[153] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[154] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[155] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[156] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[157] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[158] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[159] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[160] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[161] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[162] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[163] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[164] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[165] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[166] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[167] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[168] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[169] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[170] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[171] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[172] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[173] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[174] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[175] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[176] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[177] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[178] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[179] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[180] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[181] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[182] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[183] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[184] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[185] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[186] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[187] = { 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5 };
    std::copy_n(dof_X, 187, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 187;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_finite_element_2();
    case 1:
        return new phasediagramts_finite_element_2();
    case 2:
        return new phasediagramts_finite_element_2();
    case 3:
        return new phasediagramts_finite_element_2();
    case 4:
        return new phasediagramts_finite_element_2();
    case 5:
        return new phasediagramts_finite_element_2();
    case 6:
        return new phasediagramts_finite_element_2();
    case 7:
        return new phasediagramts_finite_element_2();
    case 8:
        return new phasediagramts_finite_element_2();
    case 9:
        return new phasediagramts_finite_element_2();
    case 10:
        return new phasediagramts_finite_element_2();
    case 11:
        return new phasediagramts_finite_element_2();
    case 12:
        return new phasediagramts_finite_element_2();
    case 13:
        return new phasediagramts_finite_element_2();
    case 14:
        return new phasediagramts_finite_element_2();
    case 15:
        return new phasediagramts_finite_element_2();
    case 16:
        return new phasediagramts_finite_element_2();
    case 17:
        return new phasediagramts_finite_element_2();
    case 18:
        return new phasediagramts_finite_element_2();
    case 19:
        return new phasediagramts_finite_element_2();
    case 20:
        return new phasediagramts_finite_element_2();
    case 21:
        return new phasediagramts_finite_element_2();
    case 22:
        return new phasediagramts_finite_element_2();
    case 23:
        return new phasediagramts_finite_element_2();
    case 24:
        return new phasediagramts_finite_element_2();
    case 25:
        return new phasediagramts_finite_element_2();
    case 26:
        return new phasediagramts_finite_element_2();
    case 27:
        return new phasediagramts_finite_element_2();
    case 28:
        return new phasediagramts_finite_element_2();
    case 29:
        return new phasediagramts_finite_element_2();
    case 30:
        return new phasediagramts_finite_element_2();
    case 31:
        return new phasediagramts_finite_element_2();
    case 32:
        return new phasediagramts_finite_element_2();
    case 33:
        return new phasediagramts_finite_element_2();
    case 34:
        return new phasediagramts_finite_element_2();
    case 35:
        return new phasediagramts_finite_element_2();
    case 36:
        return new phasediagramts_finite_element_2();
    case 37:
        return new phasediagramts_finite_element_2();
    case 38:
        return new phasediagramts_finite_element_2();
    case 39:
        return new phasediagramts_finite_element_2();
    case 40:
        return new phasediagramts_finite_element_2();
    case 41:
        return new phasediagramts_finite_element_2();
    case 42:
        return new phasediagramts_finite_element_2();
    case 43:
        return new phasediagramts_finite_element_2();
    case 44:
        return new phasediagramts_finite_element_2();
    case 45:
        return new phasediagramts_finite_element_2();
    case 46:
        return new phasediagramts_finite_element_2();
    case 47:
        return new phasediagramts_finite_element_2();
    case 48:
        return new phasediagramts_finite_element_2();
    case 49:
        return new phasediagramts_finite_element_2();
    case 50:
        return new phasediagramts_finite_element_2();
    case 51:
        return new phasediagramts_finite_element_2();
    case 52:
        return new phasediagramts_finite_element_2();
    case 53:
        return new phasediagramts_finite_element_2();
    case 54:
        return new phasediagramts_finite_element_2();
    case 55:
        return new phasediagramts_finite_element_2();
    case 56:
        return new phasediagramts_finite_element_2();
    case 57:
        return new phasediagramts_finite_element_2();
    case 58:
        return new phasediagramts_finite_element_2();
    case 59:
        return new phasediagramts_finite_element_2();
    case 60:
        return new phasediagramts_finite_element_2();
    case 61:
        return new phasediagramts_finite_element_2();
    case 62:
        return new phasediagramts_finite_element_2();
    case 63:
        return new phasediagramts_finite_element_2();
    case 64:
        return new phasediagramts_finite_element_2();
    case 65:
        return new phasediagramts_finite_element_2();
    case 66:
        return new phasediagramts_finite_element_2();
    case 67:
        return new phasediagramts_finite_element_2();
    case 68:
        return new phasediagramts_finite_element_2();
    case 69:
        return new phasediagramts_finite_element_2();
    case 70:
        return new phasediagramts_finite_element_2();
    case 71:
        return new phasediagramts_finite_element_2();
    case 72:
        return new phasediagramts_finite_element_2();
    case 73:
        return new phasediagramts_finite_element_2();
    case 74:
        return new phasediagramts_finite_element_2();
    case 75:
        return new phasediagramts_finite_element_2();
    case 76:
        return new phasediagramts_finite_element_2();
    case 77:
        return new phasediagramts_finite_element_2();
    case 78:
        return new phasediagramts_finite_element_2();
    case 79:
        return new phasediagramts_finite_element_2();
    case 80:
        return new phasediagramts_finite_element_2();
    case 81:
        return new phasediagramts_finite_element_2();
    case 82:
        return new phasediagramts_finite_element_2();
    case 83:
        return new phasediagramts_finite_element_2();
    case 84:
        return new phasediagramts_finite_element_2();
    case 85:
        return new phasediagramts_finite_element_2();
    case 86:
        return new phasediagramts_finite_element_2();
    case 87:
        return new phasediagramts_finite_element_2();
    case 88:
        return new phasediagramts_finite_element_2();
    case 89:
        return new phasediagramts_finite_element_2();
    case 90:
        return new phasediagramts_finite_element_2();
    case 91:
        return new phasediagramts_finite_element_2();
    case 92:
        return new phasediagramts_finite_element_2();
    case 93:
        return new phasediagramts_finite_element_2();
    case 94:
        return new phasediagramts_finite_element_2();
    case 95:
        return new phasediagramts_finite_element_2();
    case 96:
        return new phasediagramts_finite_element_2();
    case 97:
        return new phasediagramts_finite_element_2();
    case 98:
        return new phasediagramts_finite_element_2();
    case 99:
        return new phasediagramts_finite_element_2();
    case 100:
        return new phasediagramts_finite_element_2();
    case 101:
        return new phasediagramts_finite_element_2();
    case 102:
        return new phasediagramts_finite_element_2();
    case 103:
        return new phasediagramts_finite_element_2();
    case 104:
        return new phasediagramts_finite_element_2();
    case 105:
        return new phasediagramts_finite_element_2();
    case 106:
        return new phasediagramts_finite_element_2();
    case 107:
        return new phasediagramts_finite_element_2();
    case 108:
        return new phasediagramts_finite_element_2();
    case 109:
        return new phasediagramts_finite_element_2();
    case 110:
        return new phasediagramts_finite_element_2();
    case 111:
        return new phasediagramts_finite_element_2();
    case 112:
        return new phasediagramts_finite_element_2();
    case 113:
        return new phasediagramts_finite_element_2();
    case 114:
        return new phasediagramts_finite_element_2();
    case 115:
        return new phasediagramts_finite_element_2();
    case 116:
        return new phasediagramts_finite_element_2();
    case 117:
        return new phasediagramts_finite_element_2();
    case 118:
        return new phasediagramts_finite_element_2();
    case 119:
        return new phasediagramts_finite_element_2();
    case 120:
        return new phasediagramts_finite_element_2();
    case 121:
        return new phasediagramts_finite_element_2();
    case 122:
        return new phasediagramts_finite_element_2();
    case 123:
        return new phasediagramts_finite_element_2();
    case 124:
        return new phasediagramts_finite_element_2();
    case 125:
        return new phasediagramts_finite_element_2();
    case 126:
        return new phasediagramts_finite_element_2();
    case 127:
        return new phasediagramts_finite_element_2();
    case 128:
        return new phasediagramts_finite_element_2();
    case 129:
        return new phasediagramts_finite_element_2();
    case 130:
        return new phasediagramts_finite_element_2();
    case 131:
        return new phasediagramts_finite_element_2();
    case 132:
        return new phasediagramts_finite_element_2();
    case 133:
        return new phasediagramts_finite_element_2();
    case 134:
        return new phasediagramts_finite_element_2();
    case 135:
        return new phasediagramts_finite_element_2();
    case 136:
        return new phasediagramts_finite_element_2();
    case 137:
        return new phasediagramts_finite_element_2();
    case 138:
        return new phasediagramts_finite_element_2();
    case 139:
        return new phasediagramts_finite_element_2();
    case 140:
        return new phasediagramts_finite_element_2();
    case 141:
        return new phasediagramts_finite_element_2();
    case 142:
        return new phasediagramts_finite_element_2();
    case 143:
        return new phasediagramts_finite_element_2();
    case 144:
        return new phasediagramts_finite_element_2();
    case 145:
        return new phasediagramts_finite_element_2();
    case 146:
        return new phasediagramts_finite_element_2();
    case 147:
        return new phasediagramts_finite_element_2();
    case 148:
        return new phasediagramts_finite_element_2();
    case 149:
        return new phasediagramts_finite_element_2();
    case 150:
        return new phasediagramts_finite_element_2();
    case 151:
        return new phasediagramts_finite_element_2();
    case 152:
        return new phasediagramts_finite_element_2();
    case 153:
        return new phasediagramts_finite_element_2();
    case 154:
        return new phasediagramts_finite_element_2();
    case 155:
        return new phasediagramts_finite_element_2();
    case 156:
        return new phasediagramts_finite_element_2();
    case 157:
        return new phasediagramts_finite_element_2();
    case 158:
        return new phasediagramts_finite_element_2();
    case 159:
        return new phasediagramts_finite_element_2();
    case 160:
        return new phasediagramts_finite_element_2();
    case 161:
        return new phasediagramts_finite_element_2();
    case 162:
        return new phasediagramts_finite_element_2();
    case 163:
        return new phasediagramts_finite_element_2();
    case 164:
        return new phasediagramts_finite_element_2();
    case 165:
        return new phasediagramts_finite_element_2();
    case 166:
        return new phasediagramts_finite_element_2();
    case 167:
        return new phasediagramts_finite_element_2();
    case 168:
        return new phasediagramts_finite_element_2();
    case 169:
        return new phasediagramts_finite_element_2();
    case 170:
        return new phasediagramts_finite_element_2();
    case 171:
        return new phasediagramts_finite_element_2();
    case 172:
        return new phasediagramts_finite_element_2();
    case 173:
        return new phasediagramts_finite_element_2();
    case 174:
        return new phasediagramts_finite_element_2();
    case 175:
        return new phasediagramts_finite_element_2();
    case 176:
        return new phasediagramts_finite_element_2();
    case 177:
        return new phasediagramts_finite_element_2();
    case 178:
        return new phasediagramts_finite_element_2();
    case 179:
        return new phasediagramts_finite_element_2();
    case 180:
        return new phasediagramts_finite_element_2();
    case 181:
        return new phasediagramts_finite_element_2();
    case 182:
        return new phasediagramts_finite_element_2();
    case 183:
        return new phasediagramts_finite_element_2();
    case 184:
        return new phasediagramts_finite_element_2();
    case 185:
        return new phasediagramts_finite_element_2();
    case 186:
        return new phasediagramts_finite_element_2();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new phasediagramts_finite_element_6();
  }

};


class phasediagramts_finite_element_7: public ufc::finite_element
{
public:

  phasediagramts_finite_element_7() : ufc::finite_element()
  {
    // Do nothing
  }

  ~phasediagramts_finite_element_7() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=2)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::interval;
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t geometric_dimension() const final override
  {
    return 1;
  }

  std::size_t space_dimension() const final override
  {
    return 2;
  }

  std::size_t value_rank() const final override
  {
    return 1;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 2;
  }

  std::size_t reference_value_rank() const final override
  {
    return 1;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 2;
  }

  std::size_t degree() const final override
  {
    return 0;
  }

  const char * family() const final override
  {
    return "Discontinuous Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][1] = { { 1.414213562373095 } };
    for (std::size_t k = 0; k < num_points * 2 * 2; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        for (std::size_t p = 0; p < 1; ++p)
            basisvalues0[p] *= std::sqrt(0.5 + p);
        // Accumulate products of coefficients and basisvalues
        reference_values[2 * 2 * ip] += coefficients0[0][0] * basisvalues0[0];
        reference_values[2 * 2 * ip + 2 + 1] += coefficients0[0][0] * basisvalues0[0];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(1, order);
    std::fill_n(reference_values, num_points * 2 * num_derivatives * 2, 0.0);
    if (order > 0)
        return;
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    std::fill_n(values, num_points * 2 * 2, 0.0);
    const std::size_t reference_offsets[2] = { 0, 1 };
    const std::size_t physical_offsets[2] = { 0, 1 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 2; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[2 * 2 * ip + 2 * d + 2 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[2 * 2 * ip + 2 * d + 2 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[1] = {};
    double J[1];
    double detJ;
    double K[1];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_interval_1d(J, coordinate_dofs);
        compute_jacobian_inverse_interval_1d(K, detJ, J);
    }
    // Evaluate basis on reference element
    double ref_values[4];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[4];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 2; ++k)
        values[k] = physical_values[2 * i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 2; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2; ++s)
            values[r * 2 + s] = dof_values[s];
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(1, n);
    std::fill_n(values, 2 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(1, n);
    // Set values equal to zero.
    std::fill_n(values, 2 * num_derivatives * 2, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 2; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2 * num_derivatives; ++s)
            values[2 * num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[1];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[1] = vals[1];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[0];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[1];
    vertex_values[3] = dof_values[1];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[1] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[2] = { 0.5, 0.5 };
    std::copy_n(dof_X, 2, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 2;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_finite_element_2();
    case 1:
        return new phasediagramts_finite_element_2();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new phasediagramts_finite_element_7();
  }

};


class phasediagramts_finite_element_8: public ufc::finite_element
{
public:

  phasediagramts_finite_element_8() : ufc::finite_element()
  {
    // Do nothing
  }

  ~phasediagramts_finite_element_8() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=1)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::interval;
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t geometric_dimension() const final override
  {
    return 1;
  }

  std::size_t space_dimension() const final override
  {
    return 1;
  }

  std::size_t value_rank() const final override
  {
    return 1;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 1 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 1;
  }

  std::size_t reference_value_rank() const final override
  {
    return 1;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 1 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 1;
  }

  std::size_t degree() const final override
  {
    return 0;
  }

  const char * family() const final override
  {
    return "Discontinuous Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][1] = { { 1.414213562373095 } };
    for (std::size_t k = 0; k < num_points; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        for (std::size_t p = 0; p < 1; ++p)
            basisvalues0[p] *= std::sqrt(0.5 + p);
        // Accumulate products of coefficients and basisvalues
        reference_values[ip] += coefficients0[0][0] * basisvalues0[0];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(1, order);
    std::fill_n(reference_values, num_points * num_derivatives, 0.0);
    if (order > 0)
        return;
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    std::fill_n(values, num_points, 0.0);
    const std::size_t reference_offsets[1] = {};
    const std::size_t physical_offsets[1] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 1; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[ip + d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[ip + d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[1] = {};
    double J[1];
    double detJ;
    double K[1];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_interval_1d(J, coordinate_dofs);
        compute_jacobian_inverse_interval_1d(K, detJ, J);
    }
    // Evaluate basis on reference element
    double ref_values[1];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[1];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, x, coordinate_dofs, cell_orientation);
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(1, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, x, coordinate_dofs, cell_orientation);
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[1];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[1] = { 0.5 };
    std::copy_n(dof_X, 1, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 1;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_finite_element_2();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new phasediagramts_finite_element_8();
  }

};


class phasediagramts_finite_element_9: public ufc::finite_element
{
public:

  phasediagramts_finite_element_9() : ufc::finite_element()
  {
    // Do nothing
  }

  ~phasediagramts_finite_element_9() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "MixedElement(FiniteElement('Discontinuous Lagrange', interval, 0), FiniteElement('Discontinuous Lagrange', interval, 0), FiniteElement('Discontinuous Lagrange', interval, 0), FiniteElement('Discontinuous Lagrange', interval, 0), FiniteElement('Discontinuous Lagrange', interval, 0), FiniteElement('Discontinuous Lagrange', interval, 0), VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=2), VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=2), VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=2), VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=2), VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=2), VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=1))";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::interval;
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t geometric_dimension() const final override
  {
    return 1;
  }

  std::size_t space_dimension() const final override
  {
    return 17;
  }

  std::size_t value_rank() const final override
  {
    return 1;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 17 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 17;
  }

  std::size_t reference_value_rank() const final override
  {
    return 1;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 17 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 17;
  }

  std::size_t degree() const final override
  {
    return 0;
  }

  const char * family() const final override
  {
    return "Mixed";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][1] = { { 1.414213562373095 } };
    for (std::size_t k = 0; k < num_points * 17 * 17; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        for (std::size_t p = 0; p < 1; ++p)
            basisvalues0[p] *= std::sqrt(0.5 + p);
        // Accumulate products of coefficients and basisvalues
        reference_values[17 * 17 * ip] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 + 1] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 2 + 2] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 3 + 3] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 4 + 4] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 5 + 5] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 6 + 6] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 7 + 7] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 8 + 8] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 9 + 9] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 10 + 10] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 11 + 11] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 12 + 12] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 13 + 13] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 14 + 14] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 15 + 15] += coefficients0[0][0] * basisvalues0[0];
        reference_values[17 * 17 * ip + 17 * 16 + 16] += coefficients0[0][0] * basisvalues0[0];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(1, order);
    std::fill_n(reference_values, num_points * 17 * num_derivatives * 17, 0.0);
    if (order > 0)
        return;
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    std::fill_n(values, num_points * 17 * 17, 0.0);
    const std::size_t reference_offsets[17] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
    const std::size_t physical_offsets[17] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 17; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[17 * 17 * ip + 17 * d + 17 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[17 * 17 * ip + 17 * d + 17 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[1] = {};
    double J[1];
    double detJ;
    double K[1];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_interval_1d(J, coordinate_dofs);
        compute_jacobian_inverse_interval_1d(K, detJ, J);
    }
    // Evaluate basis on reference element
    double ref_values[289];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[289];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 17; ++k)
        values[k] = physical_values[17 * i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold values of a single dof.
    double dof_values[17] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 17; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 17; ++s)
            values[r * 17 + s] = dof_values[s];
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(1, n);
    std::fill_n(values, 17 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(1, n);
    // Set values equal to zero.
    std::fill_n(values, 17 * num_derivatives * 17, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[17] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 17; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 17 * num_derivatives; ++s)
            values[17 * num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[17];
    // Declare variable for physical coordinates
    double y[1];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 2:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 3:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 4:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 5:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 6:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 7:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 8:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 9:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[9];
        }
        break;
    case 10:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[10];
        }
        break;
    case 11:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[11];
        }
        break;
    case 12:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[12];
        }
        break;
    case 13:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[13];
        }
        break;
    case 14:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[14];
        }
        break;
    case 15:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[15];
        }
        break;
    case 16:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[16];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[17];
    // Declare variable for physical coordinates
    double y[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[1] = vals[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[2] = vals[2];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[3];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[4] = vals[4];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[5] = vals[5];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[6] = vals[6];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[7] = vals[7];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[8] = vals[8];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[9] = vals[9];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[10] = vals[10];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[11] = vals[11];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[12] = vals[12];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[13] = vals[13];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[14] = vals[14];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[15] = vals[15];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[16] = vals[16];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[17] = dof_values[0];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[1];
    vertex_values[18] = dof_values[1];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[2];
    vertex_values[19] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[3] = dof_values[3];
    vertex_values[20] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[4] = dof_values[4];
    vertex_values[21] = dof_values[4];
    // Evaluate function and change variables
    vertex_values[5] = dof_values[5];
    vertex_values[22] = dof_values[5];
    // Evaluate function and change variables
    vertex_values[6] = dof_values[6];
    vertex_values[23] = dof_values[6];
    // Evaluate function and change variables
    vertex_values[7] = dof_values[7];
    vertex_values[24] = dof_values[7];
    // Evaluate function and change variables
    vertex_values[8] = dof_values[8];
    vertex_values[25] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[9] = dof_values[9];
    vertex_values[26] = dof_values[9];
    // Evaluate function and change variables
    vertex_values[10] = dof_values[10];
    vertex_values[27] = dof_values[10];
    // Evaluate function and change variables
    vertex_values[11] = dof_values[11];
    vertex_values[28] = dof_values[11];
    // Evaluate function and change variables
    vertex_values[12] = dof_values[12];
    vertex_values[29] = dof_values[12];
    // Evaluate function and change variables
    vertex_values[13] = dof_values[13];
    vertex_values[30] = dof_values[13];
    // Evaluate function and change variables
    vertex_values[14] = dof_values[14];
    vertex_values[31] = dof_values[14];
    // Evaluate function and change variables
    vertex_values[15] = dof_values[15];
    vertex_values[32] = dof_values[15];
    // Evaluate function and change variables
    vertex_values[16] = dof_values[16];
    vertex_values[33] = dof_values[16];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[1] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[2] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[3] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[4] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[5] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[6] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[7] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[8] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[9] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[10] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[11] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[12] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[13] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[14] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[15] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    dof_coordinates[16] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[17] = { 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5 };
    std::copy_n(dof_X, 17, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 12;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_finite_element_2();
    case 1:
        return new phasediagramts_finite_element_2();
    case 2:
        return new phasediagramts_finite_element_2();
    case 3:
        return new phasediagramts_finite_element_2();
    case 4:
        return new phasediagramts_finite_element_2();
    case 5:
        return new phasediagramts_finite_element_2();
    case 6:
        return new phasediagramts_finite_element_7();
    case 7:
        return new phasediagramts_finite_element_7();
    case 8:
        return new phasediagramts_finite_element_7();
    case 9:
        return new phasediagramts_finite_element_7();
    case 10:
        return new phasediagramts_finite_element_7();
    case 11:
        return new phasediagramts_finite_element_8();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new phasediagramts_finite_element_9();
  }

};


class phasediagramts_finite_element_10: public ufc::finite_element
{
public:

  phasediagramts_finite_element_10() : ufc::finite_element()
  {
    // Do nothing
  }

  ~phasediagramts_finite_element_10() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FiniteElement('Real', interval, 0)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::interval;
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t geometric_dimension() const final override
  {
    return 1;
  }

  std::size_t space_dimension() const final override
  {
    return 1;
  }

  std::size_t value_rank() const final override
  {
    return 0;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t value_size() const final override
  {
    return 1;
  }

  std::size_t reference_value_rank() const final override
  {
    return 0;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t reference_value_size() const final override
  {
    return 1;
  }

  std::size_t degree() const final override
  {
    return 0;
  }

  const char * family() const final override
  {
    return "Real";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][1] = { { 1.414213562373095 } };
    for (std::size_t k = 0; k < num_points; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        for (std::size_t p = 0; p < 1; ++p)
            basisvalues0[p] *= std::sqrt(0.5 + p);
        // Accumulate products of coefficients and basisvalues
        reference_values[ip] += coefficients0[0][0] * basisvalues0[0];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(1, order);
    std::fill_n(reference_values, num_points * num_derivatives, 0.0);
    if (order > 0)
        return;
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    std::fill_n(values, num_points, 0.0);
    const std::size_t reference_offsets[1] = {};
    const std::size_t physical_offsets[1] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 1; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[ip + d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[ip + d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[1] = {};
    double J[1];
    double detJ;
    double K[1];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_interval_1d(J, coordinate_dofs);
        compute_jacobian_inverse_interval_1d(K, detJ, J);
    }
    // Evaluate basis on reference element
    double ref_values[1];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[1];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, x, coordinate_dofs, cell_orientation);
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(1, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, x, coordinate_dofs, cell_orientation);
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[1];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[1];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[1] = { 0.5 };
    std::copy_n(dof_X, 1, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 0;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::finite_element * create() const final override
  {
    return new phasediagramts_finite_element_10();
  }

};


class phasediagramts_dofmap_0: public ufc::dofmap
{
public:

  phasediagramts_dofmap_0() : ufc::dofmap()
  {
    // Do nothing
  }

  ~phasediagramts_dofmap_0() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for FiniteElement('Lagrange', interval, 1)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[2] = { true, false };
    if (d >= 2)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return num_global_entities[0];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 2;
  }

  std::size_t num_element_dofs() const final override
  {
    return 2;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 1;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 1, 0 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 1, 2 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    dofs[0] = entity_indices[0][0];
    dofs[1] = entity_indices[0][1];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
        dofs[0] = 0;
        break;
    case 1:
        dofs[0] = 1;
        break;
    }
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 0;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::dofmap * create() const final override
  {
    return new phasediagramts_dofmap_0();
  }

};


class phasediagramts_dofmap_1: public ufc::dofmap
{
public:

  phasediagramts_dofmap_1() : ufc::dofmap()
  {
    // Do nothing
  }

  ~phasediagramts_dofmap_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for VectorElement(FiniteElement('Lagrange', interval, 1), dim=1)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[2] = { true, false };
    if (d >= 2)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return num_global_entities[0];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 2;
  }

  std::size_t num_element_dofs() const final override
  {
    return 2;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 1;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 1, 0 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 1, 2 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    dofs[0] = entity_indices[0][0];
    dofs[1] = entity_indices[0][1];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
        dofs[0] = 0;
        break;
    case 1:
        dofs[0] = 1;
        break;
    }
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 1;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_dofmap_0();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new phasediagramts_dofmap_1();
  }

};


class phasediagramts_dofmap_2: public ufc::dofmap
{
public:

  phasediagramts_dofmap_2() : ufc::dofmap()
  {
    // Do nothing
  }

  ~phasediagramts_dofmap_2() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for FiniteElement('Discontinuous Lagrange', interval, 0)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[2] = { false, true };
    if (d >= 2)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return num_global_entities[1];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 1;
  }

  std::size_t num_element_dofs() const final override
  {
    return 1;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 0;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 1 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 1 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    dofs[0] = entity_indices[1][0];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    // Do nothing
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 0;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::dofmap * create() const final override
  {
    return new phasediagramts_dofmap_2();
  }

};


class phasediagramts_dofmap_3: public ufc::dofmap
{
public:

  phasediagramts_dofmap_3() : ufc::dofmap()
  {
    // Do nothing
  }

  ~phasediagramts_dofmap_3() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=6)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[2] = { false, true };
    if (d >= 2)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 6 * num_global_entities[1];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 6;
  }

  std::size_t num_element_dofs() const final override
  {
    return 6;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 0;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 6 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 6 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[1] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[2] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[3] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[4] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[5] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    // Do nothing
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 6;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_dofmap_2();
    case 1:
        return new phasediagramts_dofmap_2();
    case 2:
        return new phasediagramts_dofmap_2();
    case 3:
        return new phasediagramts_dofmap_2();
    case 4:
        return new phasediagramts_dofmap_2();
    case 5:
        return new phasediagramts_dofmap_2();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new phasediagramts_dofmap_3();
  }

};


class phasediagramts_dofmap_4: public ufc::dofmap
{
public:

  phasediagramts_dofmap_4() : ufc::dofmap()
  {
    // Do nothing
  }

  ~phasediagramts_dofmap_4() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=11)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[2] = { false, true };
    if (d >= 2)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 11 * num_global_entities[1];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 11;
  }

  std::size_t num_element_dofs() const final override
  {
    return 11;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 0;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 11 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 11 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[1] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[2] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[3] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[4] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[5] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[6] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[7] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[8] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[9] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[10] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    // Do nothing
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 11;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_dofmap_2();
    case 1:
        return new phasediagramts_dofmap_2();
    case 2:
        return new phasediagramts_dofmap_2();
    case 3:
        return new phasediagramts_dofmap_2();
    case 4:
        return new phasediagramts_dofmap_2();
    case 5:
        return new phasediagramts_dofmap_2();
    case 6:
        return new phasediagramts_dofmap_2();
    case 7:
        return new phasediagramts_dofmap_2();
    case 8:
        return new phasediagramts_dofmap_2();
    case 9:
        return new phasediagramts_dofmap_2();
    case 10:
        return new phasediagramts_dofmap_2();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new phasediagramts_dofmap_4();
  }

};


class phasediagramts_dofmap_5: public ufc::dofmap
{
public:

  phasediagramts_dofmap_5() : ufc::dofmap()
  {
    // Do nothing
  }

  ~phasediagramts_dofmap_5() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for TensorElement(FiniteElement('Discontinuous Lagrange', interval, 0), shape=(6, 17), symmetry={})";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[2] = { false, true };
    if (d >= 2)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 102 * num_global_entities[1];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 102;
  }

  std::size_t num_element_dofs() const final override
  {
    return 102;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 0;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 102 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 102 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[1] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[2] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[3] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[4] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[5] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[6] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[7] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[8] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[9] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[10] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[11] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[12] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[13] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[14] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[15] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[16] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[17] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[18] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[19] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[20] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[21] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[22] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[23] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[24] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[25] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[26] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[27] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[28] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[29] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[30] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[31] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[32] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[33] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[34] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[35] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[36] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[37] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[38] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[39] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[40] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[41] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[42] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[43] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[44] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[45] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[46] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[47] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[48] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[49] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[50] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[51] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[52] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[53] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[54] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[55] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[56] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[57] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[58] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[59] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[60] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[61] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[62] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[63] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[64] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[65] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[66] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[67] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[68] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[69] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[70] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[71] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[72] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[73] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[74] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[75] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[76] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[77] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[78] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[79] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[80] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[81] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[82] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[83] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[84] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[85] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[86] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[87] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[88] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[89] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[90] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[91] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[92] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[93] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[94] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[95] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[96] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[97] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[98] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[99] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[100] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[101] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    // Do nothing
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            dofs[18] = 18;
            dofs[19] = 19;
            dofs[20] = 20;
            dofs[21] = 21;
            dofs[22] = 22;
            dofs[23] = 23;
            dofs[24] = 24;
            dofs[25] = 25;
            dofs[26] = 26;
            dofs[27] = 27;
            dofs[28] = 28;
            dofs[29] = 29;
            dofs[30] = 30;
            dofs[31] = 31;
            dofs[32] = 32;
            dofs[33] = 33;
            dofs[34] = 34;
            dofs[35] = 35;
            dofs[36] = 36;
            dofs[37] = 37;
            dofs[38] = 38;
            dofs[39] = 39;
            dofs[40] = 40;
            dofs[41] = 41;
            dofs[42] = 42;
            dofs[43] = 43;
            dofs[44] = 44;
            dofs[45] = 45;
            dofs[46] = 46;
            dofs[47] = 47;
            dofs[48] = 48;
            dofs[49] = 49;
            dofs[50] = 50;
            dofs[51] = 51;
            dofs[52] = 52;
            dofs[53] = 53;
            dofs[54] = 54;
            dofs[55] = 55;
            dofs[56] = 56;
            dofs[57] = 57;
            dofs[58] = 58;
            dofs[59] = 59;
            dofs[60] = 60;
            dofs[61] = 61;
            dofs[62] = 62;
            dofs[63] = 63;
            dofs[64] = 64;
            dofs[65] = 65;
            dofs[66] = 66;
            dofs[67] = 67;
            dofs[68] = 68;
            dofs[69] = 69;
            dofs[70] = 70;
            dofs[71] = 71;
            dofs[72] = 72;
            dofs[73] = 73;
            dofs[74] = 74;
            dofs[75] = 75;
            dofs[76] = 76;
            dofs[77] = 77;
            dofs[78] = 78;
            dofs[79] = 79;
            dofs[80] = 80;
            dofs[81] = 81;
            dofs[82] = 82;
            dofs[83] = 83;
            dofs[84] = 84;
            dofs[85] = 85;
            dofs[86] = 86;
            dofs[87] = 87;
            dofs[88] = 88;
            dofs[89] = 89;
            dofs[90] = 90;
            dofs[91] = 91;
            dofs[92] = 92;
            dofs[93] = 93;
            dofs[94] = 94;
            dofs[95] = 95;
            dofs[96] = 96;
            dofs[97] = 97;
            dofs[98] = 98;
            dofs[99] = 99;
            dofs[100] = 100;
            dofs[101] = 101;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            dofs[18] = 18;
            dofs[19] = 19;
            dofs[20] = 20;
            dofs[21] = 21;
            dofs[22] = 22;
            dofs[23] = 23;
            dofs[24] = 24;
            dofs[25] = 25;
            dofs[26] = 26;
            dofs[27] = 27;
            dofs[28] = 28;
            dofs[29] = 29;
            dofs[30] = 30;
            dofs[31] = 31;
            dofs[32] = 32;
            dofs[33] = 33;
            dofs[34] = 34;
            dofs[35] = 35;
            dofs[36] = 36;
            dofs[37] = 37;
            dofs[38] = 38;
            dofs[39] = 39;
            dofs[40] = 40;
            dofs[41] = 41;
            dofs[42] = 42;
            dofs[43] = 43;
            dofs[44] = 44;
            dofs[45] = 45;
            dofs[46] = 46;
            dofs[47] = 47;
            dofs[48] = 48;
            dofs[49] = 49;
            dofs[50] = 50;
            dofs[51] = 51;
            dofs[52] = 52;
            dofs[53] = 53;
            dofs[54] = 54;
            dofs[55] = 55;
            dofs[56] = 56;
            dofs[57] = 57;
            dofs[58] = 58;
            dofs[59] = 59;
            dofs[60] = 60;
            dofs[61] = 61;
            dofs[62] = 62;
            dofs[63] = 63;
            dofs[64] = 64;
            dofs[65] = 65;
            dofs[66] = 66;
            dofs[67] = 67;
            dofs[68] = 68;
            dofs[69] = 69;
            dofs[70] = 70;
            dofs[71] = 71;
            dofs[72] = 72;
            dofs[73] = 73;
            dofs[74] = 74;
            dofs[75] = 75;
            dofs[76] = 76;
            dofs[77] = 77;
            dofs[78] = 78;
            dofs[79] = 79;
            dofs[80] = 80;
            dofs[81] = 81;
            dofs[82] = 82;
            dofs[83] = 83;
            dofs[84] = 84;
            dofs[85] = 85;
            dofs[86] = 86;
            dofs[87] = 87;
            dofs[88] = 88;
            dofs[89] = 89;
            dofs[90] = 90;
            dofs[91] = 91;
            dofs[92] = 92;
            dofs[93] = 93;
            dofs[94] = 94;
            dofs[95] = 95;
            dofs[96] = 96;
            dofs[97] = 97;
            dofs[98] = 98;
            dofs[99] = 99;
            dofs[100] = 100;
            dofs[101] = 101;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 102;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_dofmap_2();
    case 1:
        return new phasediagramts_dofmap_2();
    case 2:
        return new phasediagramts_dofmap_2();
    case 3:
        return new phasediagramts_dofmap_2();
    case 4:
        return new phasediagramts_dofmap_2();
    case 5:
        return new phasediagramts_dofmap_2();
    case 6:
        return new phasediagramts_dofmap_2();
    case 7:
        return new phasediagramts_dofmap_2();
    case 8:
        return new phasediagramts_dofmap_2();
    case 9:
        return new phasediagramts_dofmap_2();
    case 10:
        return new phasediagramts_dofmap_2();
    case 11:
        return new phasediagramts_dofmap_2();
    case 12:
        return new phasediagramts_dofmap_2();
    case 13:
        return new phasediagramts_dofmap_2();
    case 14:
        return new phasediagramts_dofmap_2();
    case 15:
        return new phasediagramts_dofmap_2();
    case 16:
        return new phasediagramts_dofmap_2();
    case 17:
        return new phasediagramts_dofmap_2();
    case 18:
        return new phasediagramts_dofmap_2();
    case 19:
        return new phasediagramts_dofmap_2();
    case 20:
        return new phasediagramts_dofmap_2();
    case 21:
        return new phasediagramts_dofmap_2();
    case 22:
        return new phasediagramts_dofmap_2();
    case 23:
        return new phasediagramts_dofmap_2();
    case 24:
        return new phasediagramts_dofmap_2();
    case 25:
        return new phasediagramts_dofmap_2();
    case 26:
        return new phasediagramts_dofmap_2();
    case 27:
        return new phasediagramts_dofmap_2();
    case 28:
        return new phasediagramts_dofmap_2();
    case 29:
        return new phasediagramts_dofmap_2();
    case 30:
        return new phasediagramts_dofmap_2();
    case 31:
        return new phasediagramts_dofmap_2();
    case 32:
        return new phasediagramts_dofmap_2();
    case 33:
        return new phasediagramts_dofmap_2();
    case 34:
        return new phasediagramts_dofmap_2();
    case 35:
        return new phasediagramts_dofmap_2();
    case 36:
        return new phasediagramts_dofmap_2();
    case 37:
        return new phasediagramts_dofmap_2();
    case 38:
        return new phasediagramts_dofmap_2();
    case 39:
        return new phasediagramts_dofmap_2();
    case 40:
        return new phasediagramts_dofmap_2();
    case 41:
        return new phasediagramts_dofmap_2();
    case 42:
        return new phasediagramts_dofmap_2();
    case 43:
        return new phasediagramts_dofmap_2();
    case 44:
        return new phasediagramts_dofmap_2();
    case 45:
        return new phasediagramts_dofmap_2();
    case 46:
        return new phasediagramts_dofmap_2();
    case 47:
        return new phasediagramts_dofmap_2();
    case 48:
        return new phasediagramts_dofmap_2();
    case 49:
        return new phasediagramts_dofmap_2();
    case 50:
        return new phasediagramts_dofmap_2();
    case 51:
        return new phasediagramts_dofmap_2();
    case 52:
        return new phasediagramts_dofmap_2();
    case 53:
        return new phasediagramts_dofmap_2();
    case 54:
        return new phasediagramts_dofmap_2();
    case 55:
        return new phasediagramts_dofmap_2();
    case 56:
        return new phasediagramts_dofmap_2();
    case 57:
        return new phasediagramts_dofmap_2();
    case 58:
        return new phasediagramts_dofmap_2();
    case 59:
        return new phasediagramts_dofmap_2();
    case 60:
        return new phasediagramts_dofmap_2();
    case 61:
        return new phasediagramts_dofmap_2();
    case 62:
        return new phasediagramts_dofmap_2();
    case 63:
        return new phasediagramts_dofmap_2();
    case 64:
        return new phasediagramts_dofmap_2();
    case 65:
        return new phasediagramts_dofmap_2();
    case 66:
        return new phasediagramts_dofmap_2();
    case 67:
        return new phasediagramts_dofmap_2();
    case 68:
        return new phasediagramts_dofmap_2();
    case 69:
        return new phasediagramts_dofmap_2();
    case 70:
        return new phasediagramts_dofmap_2();
    case 71:
        return new phasediagramts_dofmap_2();
    case 72:
        return new phasediagramts_dofmap_2();
    case 73:
        return new phasediagramts_dofmap_2();
    case 74:
        return new phasediagramts_dofmap_2();
    case 75:
        return new phasediagramts_dofmap_2();
    case 76:
        return new phasediagramts_dofmap_2();
    case 77:
        return new phasediagramts_dofmap_2();
    case 78:
        return new phasediagramts_dofmap_2();
    case 79:
        return new phasediagramts_dofmap_2();
    case 80:
        return new phasediagramts_dofmap_2();
    case 81:
        return new phasediagramts_dofmap_2();
    case 82:
        return new phasediagramts_dofmap_2();
    case 83:
        return new phasediagramts_dofmap_2();
    case 84:
        return new phasediagramts_dofmap_2();
    case 85:
        return new phasediagramts_dofmap_2();
    case 86:
        return new phasediagramts_dofmap_2();
    case 87:
        return new phasediagramts_dofmap_2();
    case 88:
        return new phasediagramts_dofmap_2();
    case 89:
        return new phasediagramts_dofmap_2();
    case 90:
        return new phasediagramts_dofmap_2();
    case 91:
        return new phasediagramts_dofmap_2();
    case 92:
        return new phasediagramts_dofmap_2();
    case 93:
        return new phasediagramts_dofmap_2();
    case 94:
        return new phasediagramts_dofmap_2();
    case 95:
        return new phasediagramts_dofmap_2();
    case 96:
        return new phasediagramts_dofmap_2();
    case 97:
        return new phasediagramts_dofmap_2();
    case 98:
        return new phasediagramts_dofmap_2();
    case 99:
        return new phasediagramts_dofmap_2();
    case 100:
        return new phasediagramts_dofmap_2();
    case 101:
        return new phasediagramts_dofmap_2();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new phasediagramts_dofmap_5();
  }

};


class phasediagramts_dofmap_6: public ufc::dofmap
{
public:

  phasediagramts_dofmap_6() : ufc::dofmap()
  {
    // Do nothing
  }

  ~phasediagramts_dofmap_6() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for TensorElement(FiniteElement('Discontinuous Lagrange', interval, 0), shape=(11, 17), symmetry={})";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[2] = { false, true };
    if (d >= 2)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 187 * num_global_entities[1];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 187;
  }

  std::size_t num_element_dofs() const final override
  {
    return 187;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 0;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 187 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 187 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[1] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[2] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[3] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[4] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[5] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[6] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[7] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[8] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[9] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[10] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[11] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[12] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[13] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[14] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[15] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[16] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[17] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[18] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[19] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[20] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[21] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[22] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[23] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[24] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[25] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[26] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[27] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[28] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[29] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[30] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[31] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[32] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[33] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[34] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[35] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[36] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[37] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[38] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[39] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[40] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[41] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[42] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[43] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[44] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[45] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[46] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[47] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[48] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[49] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[50] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[51] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[52] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[53] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[54] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[55] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[56] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[57] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[58] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[59] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[60] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[61] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[62] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[63] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[64] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[65] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[66] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[67] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[68] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[69] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[70] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[71] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[72] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[73] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[74] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[75] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[76] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[77] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[78] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[79] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[80] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[81] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[82] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[83] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[84] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[85] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[86] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[87] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[88] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[89] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[90] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[91] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[92] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[93] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[94] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[95] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[96] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[97] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[98] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[99] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[100] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[101] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[102] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[103] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[104] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[105] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[106] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[107] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[108] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[109] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[110] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[111] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[112] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[113] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[114] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[115] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[116] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[117] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[118] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[119] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[120] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[121] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[122] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[123] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[124] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[125] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[126] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[127] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[128] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[129] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[130] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[131] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[132] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[133] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[134] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[135] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[136] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[137] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[138] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[139] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[140] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[141] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[142] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[143] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[144] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[145] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[146] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[147] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[148] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[149] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[150] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[151] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[152] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[153] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[154] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[155] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[156] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[157] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[158] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[159] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[160] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[161] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[162] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[163] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[164] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[165] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[166] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[167] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[168] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[169] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[170] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[171] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[172] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[173] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[174] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[175] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[176] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[177] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[178] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[179] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[180] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[181] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[182] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[183] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[184] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[185] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[186] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    // Do nothing
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            dofs[18] = 18;
            dofs[19] = 19;
            dofs[20] = 20;
            dofs[21] = 21;
            dofs[22] = 22;
            dofs[23] = 23;
            dofs[24] = 24;
            dofs[25] = 25;
            dofs[26] = 26;
            dofs[27] = 27;
            dofs[28] = 28;
            dofs[29] = 29;
            dofs[30] = 30;
            dofs[31] = 31;
            dofs[32] = 32;
            dofs[33] = 33;
            dofs[34] = 34;
            dofs[35] = 35;
            dofs[36] = 36;
            dofs[37] = 37;
            dofs[38] = 38;
            dofs[39] = 39;
            dofs[40] = 40;
            dofs[41] = 41;
            dofs[42] = 42;
            dofs[43] = 43;
            dofs[44] = 44;
            dofs[45] = 45;
            dofs[46] = 46;
            dofs[47] = 47;
            dofs[48] = 48;
            dofs[49] = 49;
            dofs[50] = 50;
            dofs[51] = 51;
            dofs[52] = 52;
            dofs[53] = 53;
            dofs[54] = 54;
            dofs[55] = 55;
            dofs[56] = 56;
            dofs[57] = 57;
            dofs[58] = 58;
            dofs[59] = 59;
            dofs[60] = 60;
            dofs[61] = 61;
            dofs[62] = 62;
            dofs[63] = 63;
            dofs[64] = 64;
            dofs[65] = 65;
            dofs[66] = 66;
            dofs[67] = 67;
            dofs[68] = 68;
            dofs[69] = 69;
            dofs[70] = 70;
            dofs[71] = 71;
            dofs[72] = 72;
            dofs[73] = 73;
            dofs[74] = 74;
            dofs[75] = 75;
            dofs[76] = 76;
            dofs[77] = 77;
            dofs[78] = 78;
            dofs[79] = 79;
            dofs[80] = 80;
            dofs[81] = 81;
            dofs[82] = 82;
            dofs[83] = 83;
            dofs[84] = 84;
            dofs[85] = 85;
            dofs[86] = 86;
            dofs[87] = 87;
            dofs[88] = 88;
            dofs[89] = 89;
            dofs[90] = 90;
            dofs[91] = 91;
            dofs[92] = 92;
            dofs[93] = 93;
            dofs[94] = 94;
            dofs[95] = 95;
            dofs[96] = 96;
            dofs[97] = 97;
            dofs[98] = 98;
            dofs[99] = 99;
            dofs[100] = 100;
            dofs[101] = 101;
            dofs[102] = 102;
            dofs[103] = 103;
            dofs[104] = 104;
            dofs[105] = 105;
            dofs[106] = 106;
            dofs[107] = 107;
            dofs[108] = 108;
            dofs[109] = 109;
            dofs[110] = 110;
            dofs[111] = 111;
            dofs[112] = 112;
            dofs[113] = 113;
            dofs[114] = 114;
            dofs[115] = 115;
            dofs[116] = 116;
            dofs[117] = 117;
            dofs[118] = 118;
            dofs[119] = 119;
            dofs[120] = 120;
            dofs[121] = 121;
            dofs[122] = 122;
            dofs[123] = 123;
            dofs[124] = 124;
            dofs[125] = 125;
            dofs[126] = 126;
            dofs[127] = 127;
            dofs[128] = 128;
            dofs[129] = 129;
            dofs[130] = 130;
            dofs[131] = 131;
            dofs[132] = 132;
            dofs[133] = 133;
            dofs[134] = 134;
            dofs[135] = 135;
            dofs[136] = 136;
            dofs[137] = 137;
            dofs[138] = 138;
            dofs[139] = 139;
            dofs[140] = 140;
            dofs[141] = 141;
            dofs[142] = 142;
            dofs[143] = 143;
            dofs[144] = 144;
            dofs[145] = 145;
            dofs[146] = 146;
            dofs[147] = 147;
            dofs[148] = 148;
            dofs[149] = 149;
            dofs[150] = 150;
            dofs[151] = 151;
            dofs[152] = 152;
            dofs[153] = 153;
            dofs[154] = 154;
            dofs[155] = 155;
            dofs[156] = 156;
            dofs[157] = 157;
            dofs[158] = 158;
            dofs[159] = 159;
            dofs[160] = 160;
            dofs[161] = 161;
            dofs[162] = 162;
            dofs[163] = 163;
            dofs[164] = 164;
            dofs[165] = 165;
            dofs[166] = 166;
            dofs[167] = 167;
            dofs[168] = 168;
            dofs[169] = 169;
            dofs[170] = 170;
            dofs[171] = 171;
            dofs[172] = 172;
            dofs[173] = 173;
            dofs[174] = 174;
            dofs[175] = 175;
            dofs[176] = 176;
            dofs[177] = 177;
            dofs[178] = 178;
            dofs[179] = 179;
            dofs[180] = 180;
            dofs[181] = 181;
            dofs[182] = 182;
            dofs[183] = 183;
            dofs[184] = 184;
            dofs[185] = 185;
            dofs[186] = 186;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            dofs[18] = 18;
            dofs[19] = 19;
            dofs[20] = 20;
            dofs[21] = 21;
            dofs[22] = 22;
            dofs[23] = 23;
            dofs[24] = 24;
            dofs[25] = 25;
            dofs[26] = 26;
            dofs[27] = 27;
            dofs[28] = 28;
            dofs[29] = 29;
            dofs[30] = 30;
            dofs[31] = 31;
            dofs[32] = 32;
            dofs[33] = 33;
            dofs[34] = 34;
            dofs[35] = 35;
            dofs[36] = 36;
            dofs[37] = 37;
            dofs[38] = 38;
            dofs[39] = 39;
            dofs[40] = 40;
            dofs[41] = 41;
            dofs[42] = 42;
            dofs[43] = 43;
            dofs[44] = 44;
            dofs[45] = 45;
            dofs[46] = 46;
            dofs[47] = 47;
            dofs[48] = 48;
            dofs[49] = 49;
            dofs[50] = 50;
            dofs[51] = 51;
            dofs[52] = 52;
            dofs[53] = 53;
            dofs[54] = 54;
            dofs[55] = 55;
            dofs[56] = 56;
            dofs[57] = 57;
            dofs[58] = 58;
            dofs[59] = 59;
            dofs[60] = 60;
            dofs[61] = 61;
            dofs[62] = 62;
            dofs[63] = 63;
            dofs[64] = 64;
            dofs[65] = 65;
            dofs[66] = 66;
            dofs[67] = 67;
            dofs[68] = 68;
            dofs[69] = 69;
            dofs[70] = 70;
            dofs[71] = 71;
            dofs[72] = 72;
            dofs[73] = 73;
            dofs[74] = 74;
            dofs[75] = 75;
            dofs[76] = 76;
            dofs[77] = 77;
            dofs[78] = 78;
            dofs[79] = 79;
            dofs[80] = 80;
            dofs[81] = 81;
            dofs[82] = 82;
            dofs[83] = 83;
            dofs[84] = 84;
            dofs[85] = 85;
            dofs[86] = 86;
            dofs[87] = 87;
            dofs[88] = 88;
            dofs[89] = 89;
            dofs[90] = 90;
            dofs[91] = 91;
            dofs[92] = 92;
            dofs[93] = 93;
            dofs[94] = 94;
            dofs[95] = 95;
            dofs[96] = 96;
            dofs[97] = 97;
            dofs[98] = 98;
            dofs[99] = 99;
            dofs[100] = 100;
            dofs[101] = 101;
            dofs[102] = 102;
            dofs[103] = 103;
            dofs[104] = 104;
            dofs[105] = 105;
            dofs[106] = 106;
            dofs[107] = 107;
            dofs[108] = 108;
            dofs[109] = 109;
            dofs[110] = 110;
            dofs[111] = 111;
            dofs[112] = 112;
            dofs[113] = 113;
            dofs[114] = 114;
            dofs[115] = 115;
            dofs[116] = 116;
            dofs[117] = 117;
            dofs[118] = 118;
            dofs[119] = 119;
            dofs[120] = 120;
            dofs[121] = 121;
            dofs[122] = 122;
            dofs[123] = 123;
            dofs[124] = 124;
            dofs[125] = 125;
            dofs[126] = 126;
            dofs[127] = 127;
            dofs[128] = 128;
            dofs[129] = 129;
            dofs[130] = 130;
            dofs[131] = 131;
            dofs[132] = 132;
            dofs[133] = 133;
            dofs[134] = 134;
            dofs[135] = 135;
            dofs[136] = 136;
            dofs[137] = 137;
            dofs[138] = 138;
            dofs[139] = 139;
            dofs[140] = 140;
            dofs[141] = 141;
            dofs[142] = 142;
            dofs[143] = 143;
            dofs[144] = 144;
            dofs[145] = 145;
            dofs[146] = 146;
            dofs[147] = 147;
            dofs[148] = 148;
            dofs[149] = 149;
            dofs[150] = 150;
            dofs[151] = 151;
            dofs[152] = 152;
            dofs[153] = 153;
            dofs[154] = 154;
            dofs[155] = 155;
            dofs[156] = 156;
            dofs[157] = 157;
            dofs[158] = 158;
            dofs[159] = 159;
            dofs[160] = 160;
            dofs[161] = 161;
            dofs[162] = 162;
            dofs[163] = 163;
            dofs[164] = 164;
            dofs[165] = 165;
            dofs[166] = 166;
            dofs[167] = 167;
            dofs[168] = 168;
            dofs[169] = 169;
            dofs[170] = 170;
            dofs[171] = 171;
            dofs[172] = 172;
            dofs[173] = 173;
            dofs[174] = 174;
            dofs[175] = 175;
            dofs[176] = 176;
            dofs[177] = 177;
            dofs[178] = 178;
            dofs[179] = 179;
            dofs[180] = 180;
            dofs[181] = 181;
            dofs[182] = 182;
            dofs[183] = 183;
            dofs[184] = 184;
            dofs[185] = 185;
            dofs[186] = 186;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 187;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_dofmap_2();
    case 1:
        return new phasediagramts_dofmap_2();
    case 2:
        return new phasediagramts_dofmap_2();
    case 3:
        return new phasediagramts_dofmap_2();
    case 4:
        return new phasediagramts_dofmap_2();
    case 5:
        return new phasediagramts_dofmap_2();
    case 6:
        return new phasediagramts_dofmap_2();
    case 7:
        return new phasediagramts_dofmap_2();
    case 8:
        return new phasediagramts_dofmap_2();
    case 9:
        return new phasediagramts_dofmap_2();
    case 10:
        return new phasediagramts_dofmap_2();
    case 11:
        return new phasediagramts_dofmap_2();
    case 12:
        return new phasediagramts_dofmap_2();
    case 13:
        return new phasediagramts_dofmap_2();
    case 14:
        return new phasediagramts_dofmap_2();
    case 15:
        return new phasediagramts_dofmap_2();
    case 16:
        return new phasediagramts_dofmap_2();
    case 17:
        return new phasediagramts_dofmap_2();
    case 18:
        return new phasediagramts_dofmap_2();
    case 19:
        return new phasediagramts_dofmap_2();
    case 20:
        return new phasediagramts_dofmap_2();
    case 21:
        return new phasediagramts_dofmap_2();
    case 22:
        return new phasediagramts_dofmap_2();
    case 23:
        return new phasediagramts_dofmap_2();
    case 24:
        return new phasediagramts_dofmap_2();
    case 25:
        return new phasediagramts_dofmap_2();
    case 26:
        return new phasediagramts_dofmap_2();
    case 27:
        return new phasediagramts_dofmap_2();
    case 28:
        return new phasediagramts_dofmap_2();
    case 29:
        return new phasediagramts_dofmap_2();
    case 30:
        return new phasediagramts_dofmap_2();
    case 31:
        return new phasediagramts_dofmap_2();
    case 32:
        return new phasediagramts_dofmap_2();
    case 33:
        return new phasediagramts_dofmap_2();
    case 34:
        return new phasediagramts_dofmap_2();
    case 35:
        return new phasediagramts_dofmap_2();
    case 36:
        return new phasediagramts_dofmap_2();
    case 37:
        return new phasediagramts_dofmap_2();
    case 38:
        return new phasediagramts_dofmap_2();
    case 39:
        return new phasediagramts_dofmap_2();
    case 40:
        return new phasediagramts_dofmap_2();
    case 41:
        return new phasediagramts_dofmap_2();
    case 42:
        return new phasediagramts_dofmap_2();
    case 43:
        return new phasediagramts_dofmap_2();
    case 44:
        return new phasediagramts_dofmap_2();
    case 45:
        return new phasediagramts_dofmap_2();
    case 46:
        return new phasediagramts_dofmap_2();
    case 47:
        return new phasediagramts_dofmap_2();
    case 48:
        return new phasediagramts_dofmap_2();
    case 49:
        return new phasediagramts_dofmap_2();
    case 50:
        return new phasediagramts_dofmap_2();
    case 51:
        return new phasediagramts_dofmap_2();
    case 52:
        return new phasediagramts_dofmap_2();
    case 53:
        return new phasediagramts_dofmap_2();
    case 54:
        return new phasediagramts_dofmap_2();
    case 55:
        return new phasediagramts_dofmap_2();
    case 56:
        return new phasediagramts_dofmap_2();
    case 57:
        return new phasediagramts_dofmap_2();
    case 58:
        return new phasediagramts_dofmap_2();
    case 59:
        return new phasediagramts_dofmap_2();
    case 60:
        return new phasediagramts_dofmap_2();
    case 61:
        return new phasediagramts_dofmap_2();
    case 62:
        return new phasediagramts_dofmap_2();
    case 63:
        return new phasediagramts_dofmap_2();
    case 64:
        return new phasediagramts_dofmap_2();
    case 65:
        return new phasediagramts_dofmap_2();
    case 66:
        return new phasediagramts_dofmap_2();
    case 67:
        return new phasediagramts_dofmap_2();
    case 68:
        return new phasediagramts_dofmap_2();
    case 69:
        return new phasediagramts_dofmap_2();
    case 70:
        return new phasediagramts_dofmap_2();
    case 71:
        return new phasediagramts_dofmap_2();
    case 72:
        return new phasediagramts_dofmap_2();
    case 73:
        return new phasediagramts_dofmap_2();
    case 74:
        return new phasediagramts_dofmap_2();
    case 75:
        return new phasediagramts_dofmap_2();
    case 76:
        return new phasediagramts_dofmap_2();
    case 77:
        return new phasediagramts_dofmap_2();
    case 78:
        return new phasediagramts_dofmap_2();
    case 79:
        return new phasediagramts_dofmap_2();
    case 80:
        return new phasediagramts_dofmap_2();
    case 81:
        return new phasediagramts_dofmap_2();
    case 82:
        return new phasediagramts_dofmap_2();
    case 83:
        return new phasediagramts_dofmap_2();
    case 84:
        return new phasediagramts_dofmap_2();
    case 85:
        return new phasediagramts_dofmap_2();
    case 86:
        return new phasediagramts_dofmap_2();
    case 87:
        return new phasediagramts_dofmap_2();
    case 88:
        return new phasediagramts_dofmap_2();
    case 89:
        return new phasediagramts_dofmap_2();
    case 90:
        return new phasediagramts_dofmap_2();
    case 91:
        return new phasediagramts_dofmap_2();
    case 92:
        return new phasediagramts_dofmap_2();
    case 93:
        return new phasediagramts_dofmap_2();
    case 94:
        return new phasediagramts_dofmap_2();
    case 95:
        return new phasediagramts_dofmap_2();
    case 96:
        return new phasediagramts_dofmap_2();
    case 97:
        return new phasediagramts_dofmap_2();
    case 98:
        return new phasediagramts_dofmap_2();
    case 99:
        return new phasediagramts_dofmap_2();
    case 100:
        return new phasediagramts_dofmap_2();
    case 101:
        return new phasediagramts_dofmap_2();
    case 102:
        return new phasediagramts_dofmap_2();
    case 103:
        return new phasediagramts_dofmap_2();
    case 104:
        return new phasediagramts_dofmap_2();
    case 105:
        return new phasediagramts_dofmap_2();
    case 106:
        return new phasediagramts_dofmap_2();
    case 107:
        return new phasediagramts_dofmap_2();
    case 108:
        return new phasediagramts_dofmap_2();
    case 109:
        return new phasediagramts_dofmap_2();
    case 110:
        return new phasediagramts_dofmap_2();
    case 111:
        return new phasediagramts_dofmap_2();
    case 112:
        return new phasediagramts_dofmap_2();
    case 113:
        return new phasediagramts_dofmap_2();
    case 114:
        return new phasediagramts_dofmap_2();
    case 115:
        return new phasediagramts_dofmap_2();
    case 116:
        return new phasediagramts_dofmap_2();
    case 117:
        return new phasediagramts_dofmap_2();
    case 118:
        return new phasediagramts_dofmap_2();
    case 119:
        return new phasediagramts_dofmap_2();
    case 120:
        return new phasediagramts_dofmap_2();
    case 121:
        return new phasediagramts_dofmap_2();
    case 122:
        return new phasediagramts_dofmap_2();
    case 123:
        return new phasediagramts_dofmap_2();
    case 124:
        return new phasediagramts_dofmap_2();
    case 125:
        return new phasediagramts_dofmap_2();
    case 126:
        return new phasediagramts_dofmap_2();
    case 127:
        return new phasediagramts_dofmap_2();
    case 128:
        return new phasediagramts_dofmap_2();
    case 129:
        return new phasediagramts_dofmap_2();
    case 130:
        return new phasediagramts_dofmap_2();
    case 131:
        return new phasediagramts_dofmap_2();
    case 132:
        return new phasediagramts_dofmap_2();
    case 133:
        return new phasediagramts_dofmap_2();
    case 134:
        return new phasediagramts_dofmap_2();
    case 135:
        return new phasediagramts_dofmap_2();
    case 136:
        return new phasediagramts_dofmap_2();
    case 137:
        return new phasediagramts_dofmap_2();
    case 138:
        return new phasediagramts_dofmap_2();
    case 139:
        return new phasediagramts_dofmap_2();
    case 140:
        return new phasediagramts_dofmap_2();
    case 141:
        return new phasediagramts_dofmap_2();
    case 142:
        return new phasediagramts_dofmap_2();
    case 143:
        return new phasediagramts_dofmap_2();
    case 144:
        return new phasediagramts_dofmap_2();
    case 145:
        return new phasediagramts_dofmap_2();
    case 146:
        return new phasediagramts_dofmap_2();
    case 147:
        return new phasediagramts_dofmap_2();
    case 148:
        return new phasediagramts_dofmap_2();
    case 149:
        return new phasediagramts_dofmap_2();
    case 150:
        return new phasediagramts_dofmap_2();
    case 151:
        return new phasediagramts_dofmap_2();
    case 152:
        return new phasediagramts_dofmap_2();
    case 153:
        return new phasediagramts_dofmap_2();
    case 154:
        return new phasediagramts_dofmap_2();
    case 155:
        return new phasediagramts_dofmap_2();
    case 156:
        return new phasediagramts_dofmap_2();
    case 157:
        return new phasediagramts_dofmap_2();
    case 158:
        return new phasediagramts_dofmap_2();
    case 159:
        return new phasediagramts_dofmap_2();
    case 160:
        return new phasediagramts_dofmap_2();
    case 161:
        return new phasediagramts_dofmap_2();
    case 162:
        return new phasediagramts_dofmap_2();
    case 163:
        return new phasediagramts_dofmap_2();
    case 164:
        return new phasediagramts_dofmap_2();
    case 165:
        return new phasediagramts_dofmap_2();
    case 166:
        return new phasediagramts_dofmap_2();
    case 167:
        return new phasediagramts_dofmap_2();
    case 168:
        return new phasediagramts_dofmap_2();
    case 169:
        return new phasediagramts_dofmap_2();
    case 170:
        return new phasediagramts_dofmap_2();
    case 171:
        return new phasediagramts_dofmap_2();
    case 172:
        return new phasediagramts_dofmap_2();
    case 173:
        return new phasediagramts_dofmap_2();
    case 174:
        return new phasediagramts_dofmap_2();
    case 175:
        return new phasediagramts_dofmap_2();
    case 176:
        return new phasediagramts_dofmap_2();
    case 177:
        return new phasediagramts_dofmap_2();
    case 178:
        return new phasediagramts_dofmap_2();
    case 179:
        return new phasediagramts_dofmap_2();
    case 180:
        return new phasediagramts_dofmap_2();
    case 181:
        return new phasediagramts_dofmap_2();
    case 182:
        return new phasediagramts_dofmap_2();
    case 183:
        return new phasediagramts_dofmap_2();
    case 184:
        return new phasediagramts_dofmap_2();
    case 185:
        return new phasediagramts_dofmap_2();
    case 186:
        return new phasediagramts_dofmap_2();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new phasediagramts_dofmap_6();
  }

};


class phasediagramts_dofmap_7: public ufc::dofmap
{
public:

  phasediagramts_dofmap_7() : ufc::dofmap()
  {
    // Do nothing
  }

  ~phasediagramts_dofmap_7() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=2)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[2] = { false, true };
    if (d >= 2)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 2 * num_global_entities[1];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 2;
  }

  std::size_t num_element_dofs() const final override
  {
    return 2;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 0;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 2 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 2 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[1] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    // Do nothing
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 2;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_dofmap_2();
    case 1:
        return new phasediagramts_dofmap_2();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new phasediagramts_dofmap_7();
  }

};


class phasediagramts_dofmap_8: public ufc::dofmap
{
public:

  phasediagramts_dofmap_8() : ufc::dofmap()
  {
    // Do nothing
  }

  ~phasediagramts_dofmap_8() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=1)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[2] = { false, true };
    if (d >= 2)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return num_global_entities[1];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 1;
  }

  std::size_t num_element_dofs() const final override
  {
    return 1;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 0;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 1 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 1 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    dofs[0] = entity_indices[1][0];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    // Do nothing
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 1;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_dofmap_2();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new phasediagramts_dofmap_8();
  }

};


class phasediagramts_dofmap_9: public ufc::dofmap
{
public:

  phasediagramts_dofmap_9() : ufc::dofmap()
  {
    // Do nothing
  }

  ~phasediagramts_dofmap_9() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for MixedElement(FiniteElement('Discontinuous Lagrange', interval, 0), FiniteElement('Discontinuous Lagrange', interval, 0), FiniteElement('Discontinuous Lagrange', interval, 0), FiniteElement('Discontinuous Lagrange', interval, 0), FiniteElement('Discontinuous Lagrange', interval, 0), FiniteElement('Discontinuous Lagrange', interval, 0), VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=2), VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=2), VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=2), VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=2), VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=2), VectorElement(FiniteElement('Discontinuous Lagrange', interval, 0), dim=1))";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[2] = { false, true };
    if (d >= 2)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 17 * num_global_entities[1];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 17;
  }

  std::size_t num_element_dofs() const final override
  {
    return 17;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 0;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 17 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 17 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[1] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[2] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[3] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[4] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[5] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[6] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[7] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[8] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[9] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[10] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[11] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[12] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[13] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[14] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[15] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
    dofs[16] = offset + entity_indices[1][0];
    offset += num_global_entities[1];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    // Do nothing
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 12;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_dofmap_2();
    case 1:
        return new phasediagramts_dofmap_2();
    case 2:
        return new phasediagramts_dofmap_2();
    case 3:
        return new phasediagramts_dofmap_2();
    case 4:
        return new phasediagramts_dofmap_2();
    case 5:
        return new phasediagramts_dofmap_2();
    case 6:
        return new phasediagramts_dofmap_7();
    case 7:
        return new phasediagramts_dofmap_7();
    case 8:
        return new phasediagramts_dofmap_7();
    case 9:
        return new phasediagramts_dofmap_7();
    case 10:
        return new phasediagramts_dofmap_7();
    case 11:
        return new phasediagramts_dofmap_8();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new phasediagramts_dofmap_9();
  }

};


class phasediagramts_dofmap_10: public ufc::dofmap
{
public:

  phasediagramts_dofmap_10() : ufc::dofmap()
  {
    // Do nothing
  }

  ~phasediagramts_dofmap_10() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for FiniteElement('Real', interval, 0)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[2] = {};
    if (d >= 2)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 1;
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 1;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_dofs() const final override
  {
    return 1;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 0;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 1 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[2] = { 0, 1 };
    if (d >= 2)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    dofs[0] = 0;
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    // Do nothing
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 0;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::dofmap * create() const final override
  {
    return new phasediagramts_dofmap_10();
  }

};


class phasediagramts_coordinate_mapping_1: public ufc::coordinate_mapping
{
public:

  phasediagramts_coordinate_mapping_1() : ufc::coordinate_mapping()
  {
    // Do nothing
  }

  ~phasediagramts_coordinate_mapping_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC coordinate_mapping from VectorElement(FiniteElement('Lagrange', interval, 1), dim=1)";
  }

  ufc::coordinate_mapping * create() const final override
  {
    return new phasediagramts_coordinate_mapping_1();
  }

  std::size_t geometric_dimension() const final override
  {
    return 1;
  }

  std::size_t topological_dimension() const final override
  {
    return 1;
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::interval;
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new phasediagramts_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new phasediagramts_dofmap_1();
  }

  void compute_physical_coordinates(
      double * x, std::size_t num_points,
      const double * X,
      const double * coordinate_dofs) const final override
  {
    phasediagramts_finite_element_0 xelement;
    double phi[2];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis values of coordinate element
        xelement.evaluate_reference_basis(phi, 1, &X[ip]);
        // Compute x
        for (std::size_t i = 0; i < 1; ++i)
            for (std::size_t d = 0; d < 2; ++d)
                x[ip + i] += coordinate_dofs[d + i] * phi[d];
    }
  }

  void compute_reference_coordinates(
      double * X, std::size_t num_points,
      const double * x,
      const double * coordinate_dofs, int cell_orientation) const final override
  {
    const double phi_X0[2] = { 1.0, 0.0 };
    const double dphi_X0[1][2] = { { -1.0, 1.0 } };
    double J[1];
    double detJ[1];
    double K[1];
    double x0[1] = {};
    for (std::size_t i = 0; i < 1; ++i)
        for (std::size_t k = 0; k < 2; ++k)
            x0[i] += coordinate_dofs[k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 1; ++i)
    {
        for (std::size_t j = 0; j < 1; ++j)
        {
            J[i + j] = 0.0;
            for (std::size_t k = 0; k < 2; ++k)
                J[i + j] += coordinate_dofs[k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 1; ++j)
            for (std::size_t i = 0; i < 1; ++i)
                X[ip + j] += K[j + i] * (x[ip + i] - x0[i]);
  }

  void compute_reference_geometry(
      double * X, double * J, double * detJ, double * K, std::size_t num_points,
      const double * x,
      const double * coordinate_dofs, int cell_orientation) const final override
  {
    const double phi_X0[2] = { 1.0, 0.0 };
    const double dphi_X0[1][2] = { { -1.0, 1.0 } };
    double x0[1] = {};
    for (std::size_t i = 0; i < 1; ++i)
        for (std::size_t k = 0; k < 2; ++k)
            x0[i] += coordinate_dofs[k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 1; ++i)
    {
        for (std::size_t j = 0; j < 1; ++j)
        {
            J[i + j] = 0.0;
            for (std::size_t k = 0; k < 2; ++k)
                J[i + j] += coordinate_dofs[k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 1; ++j)
            for (std::size_t i = 0; i < 1; ++i)
                X[ip + j] += K[j + i] * (x[ip + i] - x0[i]);
  }

  void compute_jacobians(
      double * J, std::size_t num_points,
      const double * X,
      const double * coordinate_dofs) const final override
  {
    phasediagramts_finite_element_0 xelement;
    double dphi[2];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis derivatives of coordinate element
        xelement.evaluate_reference_basis_derivatives(dphi, 1, 1, &X[ip]);
        // Compute J
        for (std::size_t i = 0; i < 1; ++i)
            for (std::size_t j = 0; j < 1; ++j)
                for (std::size_t d = 0; d < 2; ++d)
                    J[ip + i + j] += coordinate_dofs[d + i] * dphi[d + j];
    }
  }

  void compute_jacobian_determinants(
      double * detJ, std::size_t num_points,
      const double * J,
      int cell_orientation) const final override
  {
    for (std::size_t ip = 0; ip < num_points; ++ip)
        detJ[ip] = J[ip];
  }

  void compute_jacobian_inverses(
      double * K, std::size_t num_points,
      const double * J, const double * detJ) const final override
  {
    for (std::size_t ip = 0; ip < num_points; ++ip)
        K[ip] = 1.0 / J[ip];
  }

  void compute_geometry(
      double * x, double * J, double * detJ, double * K, std::size_t num_points,
      const double * X,
      const double * coordinate_dofs, int cell_orientation) const final override
  {
    compute_physical_coordinates(x, num_points, X, coordinate_dofs);
    compute_jacobians(J, num_points, X, coordinate_dofs);
    compute_jacobian_determinants(detJ, num_points, J, cell_orientation);
    compute_jacobian_inverses(K, num_points, J, detJ);
  }

  void compute_midpoint_geometry(
      double * x, double * J,
      const double * coordinate_dofs) const final override
  {
    const double phi_Xm[2] = { 0.5, 0.5 };
    const double dphi_Xm[1][2] = { { -1.0, 1.0 } };
    // Compute x
    for (std::size_t i = 0; i < 1; ++i)
        for (std::size_t d = 0; d < 2; ++d)
            x[i] += coordinate_dofs[d + i] * phi_Xm[d];
    // Compute J
    for (std::size_t i = 0; i < 1; ++i)
        for (std::size_t j = 0; j < 1; ++j)
            for (std::size_t d = 0; d < 2; ++d)
                J[i + j] += coordinate_dofs[d + i] * dphi_Xm[j][d];
  }

};


class phasediagramts_cell_integral_0_otherwise: public ufc::cell_integral
{
public:

  phasediagramts_cell_integral_0_otherwise() : ufc::cell_integral()
  {

  }

  ~phasediagramts_cell_integral_0_otherwise() override
  {

  }

  const std::vector<bool> & enabled_coefficients() const final override
  {
static const std::vector<bool> enabled({true});
return enabled;
  }

  void tabulate_tensor(double * A,
                       const double * const * w,
                       const double * coordinate_dofs,
                       int cell_orientation) const final override
  {
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 0
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 0
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           0
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE0_C0_D1_Q1[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE0_C0_D1_Q1[0][0][0] + coordinate_dofs[1] * FE0_C0_D1_Q1[0][0][1];
    alignas(32) double sp[18];
    sp[0] = std::abs(J_c0);
    sp[1] = w[0][0] * sp[0];
    sp[2] = w[0][1] * sp[0];
    sp[3] = w[0][2] * sp[0];
    sp[4] = w[0][3] * sp[0];
    sp[5] = w[0][4] * sp[0];
    sp[6] = w[0][5] * sp[0];
    sp[7] = w[0][6] * sp[0];
    sp[8] = w[0][7] * sp[0];
    sp[9] = w[0][8] * sp[0];
    sp[10] = w[0][9] * sp[0];
    sp[11] = w[0][10] * sp[0];
    sp[12] = w[0][11] * sp[0];
    sp[13] = w[0][12] * sp[0];
    sp[14] = w[0][13] * sp[0];
    sp[15] = w[0][14] * sp[0];
    sp[16] = w[0][15] * sp[0];
    sp[17] = w[0][16] * sp[0];
    A[0] = sp[1];
    A[1] = sp[2];
    A[2] = sp[3];
    A[3] = sp[4];
    A[4] = sp[5];
    A[5] = sp[6];
    A[6] = sp[7];
    A[7] = sp[8];
    A[8] = sp[9];
    A[9] = sp[10];
    A[10] = sp[11];
    A[11] = sp[12];
    A[12] = sp[13];
    A[13] = sp[14];
    A[14] = sp[15];
    A[15] = sp[16];
    A[16] = sp[17];
  }

};


class phasediagramts_cell_integral_1_otherwise: public ufc::cell_integral
{
public:

  phasediagramts_cell_integral_1_otherwise() : ufc::cell_integral()
  {

  }

  ~phasediagramts_cell_integral_1_otherwise() override
  {

  }

  const std::vector<bool> & enabled_coefficients() const final override
  {
static const std::vector<bool> enabled({true, true, true, true, true, true, true});
return enabled;
  }

  void tabulate_tensor(double * A,
                       const double * const * w,
                       const double * coordinate_dofs,
                       int cell_orientation) const final override
  {
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 0
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 0
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           0
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE0_C0_D1_Q1[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE0_C0_D1_Q1[0][0][0] + coordinate_dofs[1] * FE0_C0_D1_Q1[0][0][1];
    alignas(32) double sp[103];
    sp[0] = w[0][0] / w[4][0];
    sp[1] = w[0][1] / w[4][1];
    sp[2] = sp[0] + sp[1];
    sp[3] = w[0][2] / w[4][2];
    sp[4] = sp[2] + sp[3];
    sp[5] = w[0][3] / w[4][3];
    sp[6] = sp[4] + sp[5];
    sp[7] = w[0][4] / w[4][4];
    sp[8] = sp[6] + sp[7];
    sp[9] = w[0][5] / w[4][5];
    sp[10] = sp[8] + sp[9];
    sp[11] = w[1][0] * w[3][0];
    sp[12] = w[5][0] * sp[11];
    sp[13] = sp[10] * sp[12];
    sp[14] = w[5][1] * sp[11];
    sp[15] = sp[10] * sp[14];
    sp[16] = w[5][2] * sp[11];
    sp[17] = sp[10] * sp[16];
    sp[18] = w[5][3] * sp[11];
    sp[19] = sp[10] * sp[18];
    sp[20] = w[5][4] * sp[11];
    sp[21] = sp[10] * sp[20];
    sp[22] = w[5][5] * sp[11];
    sp[23] = sp[10] * sp[22];
    sp[24] = w[5][0] * w[0][6];
    sp[25] = w[6][0] + -1 * sp[24];
    sp[26] = sp[25] * sp[11];
    sp[27] = sp[10] * sp[26];
    sp[28] = w[0][0] + w[2][0];
    sp[29] = sp[27] / sp[28];
    sp[30] = w[5][0] * w[0][7];
    sp[31] = w[6][1] + -1 * sp[30];
    sp[32] = sp[31] * sp[11];
    sp[33] = sp[10] * sp[32];
    sp[34] = sp[33] / sp[28];
    sp[35] = w[5][1] * w[0][8];
    sp[36] = w[6][2] + -1 * sp[35];
    sp[37] = sp[36] * sp[11];
    sp[38] = sp[10] * sp[37];
    sp[39] = w[0][1] + w[2][0];
    sp[40] = sp[38] / sp[39];
    sp[41] = w[5][1] * w[0][9];
    sp[42] = w[6][3] + -1 * sp[41];
    sp[43] = sp[42] * sp[11];
    sp[44] = sp[10] * sp[43];
    sp[45] = sp[44] / sp[39];
    sp[46] = w[5][2] * w[0][10];
    sp[47] = w[6][4] + -1 * sp[46];
    sp[48] = sp[47] * sp[11];
    sp[49] = sp[10] * sp[48];
    sp[50] = w[0][2] + w[2][0];
    sp[51] = sp[49] / sp[50];
    sp[52] = w[5][2] * w[0][11];
    sp[53] = w[6][5] + -1 * sp[52];
    sp[54] = sp[53] * sp[11];
    sp[55] = sp[10] * sp[54];
    sp[56] = sp[55] / sp[50];
    sp[57] = w[5][3] * w[0][12];
    sp[58] = w[6][6] + -1 * sp[57];
    sp[59] = sp[58] * sp[11];
    sp[60] = sp[10] * sp[59];
    sp[61] = w[0][3] + w[2][0];
    sp[62] = sp[60] / sp[61];
    sp[63] = w[5][3] * w[0][13];
    sp[64] = w[6][7] + -1 * sp[63];
    sp[65] = sp[64] * sp[11];
    sp[66] = sp[10] * sp[65];
    sp[67] = sp[66] / sp[61];
    sp[68] = w[5][4] * w[0][14];
    sp[69] = w[6][8] + -1 * sp[68];
    sp[70] = sp[69] * sp[11];
    sp[71] = sp[10] * sp[70];
    sp[72] = w[0][4] + w[2][0];
    sp[73] = sp[71] / sp[72];
    sp[74] = w[5][4] * w[0][15];
    sp[75] = w[6][9] + -1 * sp[74];
    sp[76] = sp[75] * sp[11];
    sp[77] = sp[10] * sp[76];
    sp[78] = sp[77] / sp[72];
    sp[79] = w[5][5] * w[0][16];
    sp[80] = w[6][10] + -1 * sp[79];
    sp[81] = sp[80] * sp[11];
    sp[82] = sp[10] * sp[81];
    sp[83] = w[0][5] + w[2][0];
    sp[84] = sp[82] / sp[83];
    sp[85] = std::abs(J_c0);
    sp[86] = sp[13] * sp[85];
    sp[87] = sp[15] * sp[85];
    sp[88] = sp[17] * sp[85];
    sp[89] = sp[19] * sp[85];
    sp[90] = sp[21] * sp[85];
    sp[91] = sp[23] * sp[85];
    sp[92] = sp[29] * sp[85];
    sp[93] = sp[34] * sp[85];
    sp[94] = sp[40] * sp[85];
    sp[95] = sp[45] * sp[85];
    sp[96] = sp[51] * sp[85];
    sp[97] = sp[56] * sp[85];
    sp[98] = sp[62] * sp[85];
    sp[99] = sp[67] * sp[85];
    sp[100] = sp[73] * sp[85];
    sp[101] = sp[78] * sp[85];
    sp[102] = sp[84] * sp[85];
    A[0] = sp[86];
    A[1] = sp[87];
    A[2] = sp[88];
    A[3] = sp[89];
    A[4] = sp[90];
    A[5] = sp[91];
    A[6] = sp[92];
    A[7] = sp[93];
    A[8] = sp[94];
    A[9] = sp[95];
    A[10] = sp[96];
    A[11] = sp[97];
    A[12] = sp[98];
    A[13] = sp[99];
    A[14] = sp[100];
    A[15] = sp[101];
    A[16] = sp[102];
  }

};


class phasediagramts_cell_integral_2_otherwise: public ufc::cell_integral
{
public:

  phasediagramts_cell_integral_2_otherwise() : ufc::cell_integral()
  {

  }

  ~phasediagramts_cell_integral_2_otherwise() override
  {

  }

  const std::vector<bool> & enabled_coefficients() const final override
  {
static const std::vector<bool> enabled({true});
return enabled;
  }

  void tabulate_tensor(double * A,
                       const double * const * w,
                       const double * coordinate_dofs,
                       int cell_orientation) const final override
  {
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 0
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 0
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           0
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE0_C0_D1_Q1[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE0_C0_D1_Q1[0][0][0] + coordinate_dofs[1] * FE0_C0_D1_Q1[0][0][1];
    alignas(32) double sp[2];
    sp[0] = std::abs(J_c0);
    sp[1] = sp[0] * w[0][0];
    A[0] = sp[1];
    std::fill(A + 1, A + 18, 0.0);
    A[18] = sp[1];
    std::fill(A + 19, A + 36, 0.0);
    A[36] = sp[1];
    std::fill(A + 37, A + 54, 0.0);
    A[54] = sp[1];
    std::fill(A + 55, A + 72, 0.0);
    A[72] = sp[1];
    std::fill(A + 73, A + 90, 0.0);
    A[90] = sp[1];
    std::fill(A + 91, A + 108, 0.0);
    A[108] = sp[1];
    std::fill(A + 109, A + 126, 0.0);
    A[126] = sp[1];
    std::fill(A + 127, A + 144, 0.0);
    A[144] = sp[1];
    std::fill(A + 145, A + 162, 0.0);
    A[162] = sp[1];
    std::fill(A + 163, A + 180, 0.0);
    A[180] = sp[1];
    std::fill(A + 181, A + 198, 0.0);
    A[198] = sp[1];
    std::fill(A + 199, A + 216, 0.0);
    A[216] = sp[1];
    std::fill(A + 217, A + 234, 0.0);
    A[234] = sp[1];
    std::fill(A + 235, A + 252, 0.0);
    A[252] = sp[1];
    std::fill(A + 253, A + 270, 0.0);
    A[270] = sp[1];
    std::fill(A + 271, A + 288, 0.0);
    A[288] = sp[1];
  }

};


class phasediagramts_cell_integral_3_otherwise: public ufc::cell_integral
{
public:

  phasediagramts_cell_integral_3_otherwise() : ufc::cell_integral()
  {

  }

  ~phasediagramts_cell_integral_3_otherwise() override
  {

  }

  const std::vector<bool> & enabled_coefficients() const final override
  {
static const std::vector<bool> enabled({true, true, true, true, true, true, true, true, true, true});
return enabled;
  }

  void tabulate_tensor(double * A,
                       const double * const * w,
                       const double * coordinate_dofs,
                       int cell_orientation) const final override
  {
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 0
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 0
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           0
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE0_C0_D1_Q1[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE0_C0_D1_Q1[0][0][0] + coordinate_dofs[1] * FE0_C0_D1_Q1[0][0][1];
    alignas(32) double sp[2397];
    sp[0] = w[0][0] / w[4][0];
    sp[1] = w[5][0] * sp[0];
    sp[2] = w[5][1] * sp[0];
    sp[3] = w[5][2] * sp[0];
    sp[4] = w[5][3] * sp[0];
    sp[5] = w[5][4] * sp[0];
    sp[6] = w[5][5] * sp[0];
    sp[7] = w[5][6] * sp[0];
    sp[8] = w[5][7] * sp[0];
    sp[9] = w[5][8] * sp[0];
    sp[10] = w[5][9] * sp[0];
    sp[11] = w[5][10] * sp[0];
    sp[12] = w[5][11] * sp[0];
    sp[13] = w[5][12] * sp[0];
    sp[14] = w[5][13] * sp[0];
    sp[15] = w[5][14] * sp[0];
    sp[16] = w[5][15] * sp[0];
    sp[17] = w[5][16] * sp[0];
    sp[18] = (1.0 + -1 * sp[1]) / w[4][0];
    sp[19] = -1 * sp[2] / w[4][0];
    sp[20] = -1 * sp[3] / w[4][0];
    sp[21] = -1 * sp[4] / w[4][0];
    sp[22] = -1 * sp[5] / w[4][0];
    sp[23] = -1 * sp[6] / w[4][0];
    sp[24] = -1 * sp[7] / w[4][0];
    sp[25] = -1 * sp[8] / w[4][0];
    sp[26] = -1 * sp[9] / w[4][0];
    sp[27] = -1 * sp[10] / w[4][0];
    sp[28] = -1 * sp[11] / w[4][0];
    sp[29] = -1 * sp[12] / w[4][0];
    sp[30] = -1 * sp[13] / w[4][0];
    sp[31] = -1 * sp[14] / w[4][0];
    sp[32] = -1 * sp[15] / w[4][0];
    sp[33] = -1 * sp[16] / w[4][0];
    sp[34] = -1 * sp[17] / w[4][0];
    sp[35] = w[0][1] / w[4][1];
    sp[36] = w[5][17] * sp[35];
    sp[37] = w[5][18] * sp[35];
    sp[38] = w[5][19] * sp[35];
    sp[39] = w[5][20] * sp[35];
    sp[40] = w[5][21] * sp[35];
    sp[41] = w[5][22] * sp[35];
    sp[42] = w[5][23] * sp[35];
    sp[43] = w[5][24] * sp[35];
    sp[44] = w[5][25] * sp[35];
    sp[45] = w[5][26] * sp[35];
    sp[46] = w[5][27] * sp[35];
    sp[47] = w[5][28] * sp[35];
    sp[48] = w[5][29] * sp[35];
    sp[49] = w[5][30] * sp[35];
    sp[50] = w[5][31] * sp[35];
    sp[51] = w[5][32] * sp[35];
    sp[52] = w[5][33] * sp[35];
    sp[53] = -1 * sp[36] / w[4][1];
    sp[54] = (1.0 + -1 * sp[37]) / w[4][1];
    sp[55] = -1 * sp[38] / w[4][1];
    sp[56] = -1 * sp[39] / w[4][1];
    sp[57] = -1 * sp[40] / w[4][1];
    sp[58] = -1 * sp[41] / w[4][1];
    sp[59] = -1 * sp[42] / w[4][1];
    sp[60] = -1 * sp[43] / w[4][1];
    sp[61] = -1 * sp[44] / w[4][1];
    sp[62] = -1 * sp[45] / w[4][1];
    sp[63] = -1 * sp[46] / w[4][1];
    sp[64] = -1 * sp[47] / w[4][1];
    sp[65] = -1 * sp[48] / w[4][1];
    sp[66] = -1 * sp[49] / w[4][1];
    sp[67] = -1 * sp[50] / w[4][1];
    sp[68] = -1 * sp[51] / w[4][1];
    sp[69] = -1 * sp[52] / w[4][1];
    sp[70] = sp[18] + sp[53];
    sp[71] = sp[19] + sp[54];
    sp[72] = sp[20] + sp[55];
    sp[73] = sp[21] + sp[56];
    sp[74] = sp[22] + sp[57];
    sp[75] = sp[23] + sp[58];
    sp[76] = sp[24] + sp[59];
    sp[77] = sp[25] + sp[60];
    sp[78] = sp[26] + sp[61];
    sp[79] = sp[27] + sp[62];
    sp[80] = sp[28] + sp[63];
    sp[81] = sp[29] + sp[64];
    sp[82] = sp[30] + sp[65];
    sp[83] = sp[31] + sp[66];
    sp[84] = sp[32] + sp[67];
    sp[85] = sp[33] + sp[68];
    sp[86] = sp[34] + sp[69];
    sp[87] = w[0][2] / w[4][2];
    sp[88] = w[5][34] * sp[87];
    sp[89] = w[5][35] * sp[87];
    sp[90] = w[5][36] * sp[87];
    sp[91] = w[5][37] * sp[87];
    sp[92] = w[5][38] * sp[87];
    sp[93] = w[5][39] * sp[87];
    sp[94] = w[5][40] * sp[87];
    sp[95] = w[5][41] * sp[87];
    sp[96] = w[5][42] * sp[87];
    sp[97] = w[5][43] * sp[87];
    sp[98] = w[5][44] * sp[87];
    sp[99] = w[5][45] * sp[87];
    sp[100] = w[5][46] * sp[87];
    sp[101] = w[5][47] * sp[87];
    sp[102] = w[5][48] * sp[87];
    sp[103] = w[5][49] * sp[87];
    sp[104] = w[5][50] * sp[87];
    sp[105] = -1 * sp[88] / w[4][2];
    sp[106] = -1 * sp[89] / w[4][2];
    sp[107] = (1.0 + -1 * sp[90]) / w[4][2];
    sp[108] = -1 * sp[91] / w[4][2];
    sp[109] = -1 * sp[92] / w[4][2];
    sp[110] = -1 * sp[93] / w[4][2];
    sp[111] = -1 * sp[94] / w[4][2];
    sp[112] = -1 * sp[95] / w[4][2];
    sp[113] = -1 * sp[96] / w[4][2];
    sp[114] = -1 * sp[97] / w[4][2];
    sp[115] = -1 * sp[98] / w[4][2];
    sp[116] = -1 * sp[99] / w[4][2];
    sp[117] = -1 * sp[100] / w[4][2];
    sp[118] = -1 * sp[101] / w[4][2];
    sp[119] = -1 * sp[102] / w[4][2];
    sp[120] = -1 * sp[103] / w[4][2];
    sp[121] = -1 * sp[104] / w[4][2];
    sp[122] = sp[70] + sp[105];
    sp[123] = sp[71] + sp[106];
    sp[124] = sp[72] + sp[107];
    sp[125] = sp[73] + sp[108];
    sp[126] = sp[74] + sp[109];
    sp[127] = sp[75] + sp[110];
    sp[128] = sp[76] + sp[111];
    sp[129] = sp[77] + sp[112];
    sp[130] = sp[78] + sp[113];
    sp[131] = sp[79] + sp[114];
    sp[132] = sp[80] + sp[115];
    sp[133] = sp[81] + sp[116];
    sp[134] = sp[82] + sp[117];
    sp[135] = sp[83] + sp[118];
    sp[136] = sp[84] + sp[119];
    sp[137] = sp[85] + sp[120];
    sp[138] = sp[86] + sp[121];
    sp[139] = w[0][3] / w[4][3];
    sp[140] = w[5][51] * sp[139];
    sp[141] = w[5][52] * sp[139];
    sp[142] = w[5][53] * sp[139];
    sp[143] = w[5][54] * sp[139];
    sp[144] = w[5][55] * sp[139];
    sp[145] = w[5][56] * sp[139];
    sp[146] = w[5][57] * sp[139];
    sp[147] = w[5][58] * sp[139];
    sp[148] = w[5][59] * sp[139];
    sp[149] = w[5][60] * sp[139];
    sp[150] = w[5][61] * sp[139];
    sp[151] = w[5][62] * sp[139];
    sp[152] = w[5][63] * sp[139];
    sp[153] = w[5][64] * sp[139];
    sp[154] = w[5][65] * sp[139];
    sp[155] = w[5][66] * sp[139];
    sp[156] = w[5][67] * sp[139];
    sp[157] = -1 * sp[140] / w[4][3];
    sp[158] = -1 * sp[141] / w[4][3];
    sp[159] = -1 * sp[142] / w[4][3];
    sp[160] = (1.0 + -1 * sp[143]) / w[4][3];
    sp[161] = -1 * sp[144] / w[4][3];
    sp[162] = -1 * sp[145] / w[4][3];
    sp[163] = -1 * sp[146] / w[4][3];
    sp[164] = -1 * sp[147] / w[4][3];
    sp[165] = -1 * sp[148] / w[4][3];
    sp[166] = -1 * sp[149] / w[4][3];
    sp[167] = -1 * sp[150] / w[4][3];
    sp[168] = -1 * sp[151] / w[4][3];
    sp[169] = -1 * sp[152] / w[4][3];
    sp[170] = -1 * sp[153] / w[4][3];
    sp[171] = -1 * sp[154] / w[4][3];
    sp[172] = -1 * sp[155] / w[4][3];
    sp[173] = -1 * sp[156] / w[4][3];
    sp[174] = sp[122] + sp[157];
    sp[175] = sp[123] + sp[158];
    sp[176] = sp[124] + sp[159];
    sp[177] = sp[125] + sp[160];
    sp[178] = sp[126] + sp[161];
    sp[179] = sp[127] + sp[162];
    sp[180] = sp[128] + sp[163];
    sp[181] = sp[129] + sp[164];
    sp[182] = sp[130] + sp[165];
    sp[183] = sp[131] + sp[166];
    sp[184] = sp[132] + sp[167];
    sp[185] = sp[133] + sp[168];
    sp[186] = sp[134] + sp[169];
    sp[187] = sp[135] + sp[170];
    sp[188] = sp[136] + sp[171];
    sp[189] = sp[137] + sp[172];
    sp[190] = sp[138] + sp[173];
    sp[191] = w[0][4] / w[4][4];
    sp[192] = w[5][68] * sp[191];
    sp[193] = w[5][69] * sp[191];
    sp[194] = w[5][70] * sp[191];
    sp[195] = w[5][71] * sp[191];
    sp[196] = w[5][72] * sp[191];
    sp[197] = w[5][73] * sp[191];
    sp[198] = w[5][74] * sp[191];
    sp[199] = w[5][75] * sp[191];
    sp[200] = w[5][76] * sp[191];
    sp[201] = w[5][77] * sp[191];
    sp[202] = w[5][78] * sp[191];
    sp[203] = w[5][79] * sp[191];
    sp[204] = w[5][80] * sp[191];
    sp[205] = w[5][81] * sp[191];
    sp[206] = w[5][82] * sp[191];
    sp[207] = w[5][83] * sp[191];
    sp[208] = w[5][84] * sp[191];
    sp[209] = -1 * sp[192] / w[4][4];
    sp[210] = -1 * sp[193] / w[4][4];
    sp[211] = -1 * sp[194] / w[4][4];
    sp[212] = -1 * sp[195] / w[4][4];
    sp[213] = (1.0 + -1 * sp[196]) / w[4][4];
    sp[214] = -1 * sp[197] / w[4][4];
    sp[215] = -1 * sp[198] / w[4][4];
    sp[216] = -1 * sp[199] / w[4][4];
    sp[217] = -1 * sp[200] / w[4][4];
    sp[218] = -1 * sp[201] / w[4][4];
    sp[219] = -1 * sp[202] / w[4][4];
    sp[220] = -1 * sp[203] / w[4][4];
    sp[221] = -1 * sp[204] / w[4][4];
    sp[222] = -1 * sp[205] / w[4][4];
    sp[223] = -1 * sp[206] / w[4][4];
    sp[224] = -1 * sp[207] / w[4][4];
    sp[225] = -1 * sp[208] / w[4][4];
    sp[226] = sp[174] + sp[209];
    sp[227] = sp[175] + sp[210];
    sp[228] = sp[176] + sp[211];
    sp[229] = sp[177] + sp[212];
    sp[230] = sp[178] + sp[213];
    sp[231] = sp[179] + sp[214];
    sp[232] = sp[180] + sp[215];
    sp[233] = sp[181] + sp[216];
    sp[234] = sp[182] + sp[217];
    sp[235] = sp[183] + sp[218];
    sp[236] = sp[184] + sp[219];
    sp[237] = sp[185] + sp[220];
    sp[238] = sp[186] + sp[221];
    sp[239] = sp[187] + sp[222];
    sp[240] = sp[188] + sp[223];
    sp[241] = sp[189] + sp[224];
    sp[242] = sp[190] + sp[225];
    sp[243] = w[0][5] / w[4][5];
    sp[244] = w[5][85] * sp[243];
    sp[245] = w[5][86] * sp[243];
    sp[246] = w[5][87] * sp[243];
    sp[247] = w[5][88] * sp[243];
    sp[248] = w[5][89] * sp[243];
    sp[249] = w[5][90] * sp[243];
    sp[250] = w[5][91] * sp[243];
    sp[251] = w[5][92] * sp[243];
    sp[252] = w[5][93] * sp[243];
    sp[253] = w[5][94] * sp[243];
    sp[254] = w[5][95] * sp[243];
    sp[255] = w[5][96] * sp[243];
    sp[256] = w[5][97] * sp[243];
    sp[257] = w[5][98] * sp[243];
    sp[258] = w[5][99] * sp[243];
    sp[259] = w[5][100] * sp[243];
    sp[260] = w[5][101] * sp[243];
    sp[261] = -1 * sp[244] / w[4][5];
    sp[262] = -1 * sp[245] / w[4][5];
    sp[263] = -1 * sp[246] / w[4][5];
    sp[264] = -1 * sp[247] / w[4][5];
    sp[265] = -1 * sp[248] / w[4][5];
    sp[266] = (1.0 + -1 * sp[249]) / w[4][5];
    sp[267] = -1 * sp[250] / w[4][5];
    sp[268] = -1 * sp[251] / w[4][5];
    sp[269] = -1 * sp[252] / w[4][5];
    sp[270] = -1 * sp[253] / w[4][5];
    sp[271] = -1 * sp[254] / w[4][5];
    sp[272] = -1 * sp[255] / w[4][5];
    sp[273] = -1 * sp[256] / w[4][5];
    sp[274] = -1 * sp[257] / w[4][5];
    sp[275] = -1 * sp[258] / w[4][5];
    sp[276] = -1 * sp[259] / w[4][5];
    sp[277] = -1 * sp[260] / w[4][5];
    sp[278] = sp[226] + sp[261];
    sp[279] = sp[227] + sp[262];
    sp[280] = sp[228] + sp[263];
    sp[281] = sp[229] + sp[264];
    sp[282] = sp[230] + sp[265];
    sp[283] = sp[231] + sp[266];
    sp[284] = sp[232] + sp[267];
    sp[285] = sp[233] + sp[268];
    sp[286] = sp[234] + sp[269];
    sp[287] = sp[235] + sp[270];
    sp[288] = sp[236] + sp[271];
    sp[289] = sp[237] + sp[272];
    sp[290] = sp[238] + sp[273];
    sp[291] = sp[239] + sp[274];
    sp[292] = sp[240] + sp[275];
    sp[293] = sp[241] + sp[276];
    sp[294] = sp[242] + sp[277];
    sp[295] = w[1][0] * w[3][0];
    sp[296] = w[6][0] * sp[295];
    sp[297] = sp[278] * sp[296];
    sp[298] = sp[279] * sp[296];
    sp[299] = sp[280] * sp[296];
    sp[300] = sp[281] * sp[296];
    sp[301] = sp[282] * sp[296];
    sp[302] = sp[283] * sp[296];
    sp[303] = sp[284] * sp[296];
    sp[304] = sp[285] * sp[296];
    sp[305] = sp[286] * sp[296];
    sp[306] = sp[287] * sp[296];
    sp[307] = sp[288] * sp[296];
    sp[308] = sp[289] * sp[296];
    sp[309] = sp[290] * sp[296];
    sp[310] = sp[291] * sp[296];
    sp[311] = sp[292] * sp[296];
    sp[312] = sp[293] * sp[296];
    sp[313] = sp[294] * sp[296];
    sp[314] = sp[0] + sp[35];
    sp[315] = sp[314] + sp[87];
    sp[316] = sp[315] + sp[139];
    sp[317] = sp[316] + sp[191];
    sp[318] = sp[317] + sp[243];
    sp[319] = w[7][0] * sp[295];
    sp[320] = w[7][1] * sp[295];
    sp[321] = w[7][2] * sp[295];
    sp[322] = w[7][3] * sp[295];
    sp[323] = w[7][4] * sp[295];
    sp[324] = w[7][5] * sp[295];
    sp[325] = w[7][6] * sp[295];
    sp[326] = w[7][7] * sp[295];
    sp[327] = w[7][8] * sp[295];
    sp[328] = w[7][9] * sp[295];
    sp[329] = w[7][10] * sp[295];
    sp[330] = w[7][11] * sp[295];
    sp[331] = w[7][12] * sp[295];
    sp[332] = w[7][13] * sp[295];
    sp[333] = w[7][14] * sp[295];
    sp[334] = w[7][15] * sp[295];
    sp[335] = w[7][16] * sp[295];
    sp[336] = sp[318] * sp[319];
    sp[337] = sp[318] * sp[320];
    sp[338] = sp[318] * sp[321];
    sp[339] = sp[318] * sp[322];
    sp[340] = sp[318] * sp[323];
    sp[341] = sp[318] * sp[324];
    sp[342] = sp[318] * sp[325];
    sp[343] = sp[318] * sp[326];
    sp[344] = sp[318] * sp[327];
    sp[345] = sp[318] * sp[328];
    sp[346] = sp[318] * sp[329];
    sp[347] = sp[318] * sp[330];
    sp[348] = sp[318] * sp[331];
    sp[349] = sp[318] * sp[332];
    sp[350] = sp[318] * sp[333];
    sp[351] = sp[318] * sp[334];
    sp[352] = sp[318] * sp[335];
    sp[353] = sp[297] + sp[336];
    sp[354] = sp[298] + sp[337];
    sp[355] = sp[299] + sp[338];
    sp[356] = sp[300] + sp[339];
    sp[357] = sp[301] + sp[340];
    sp[358] = sp[302] + sp[341];
    sp[359] = sp[303] + sp[342];
    sp[360] = sp[304] + sp[343];
    sp[361] = sp[305] + sp[344];
    sp[362] = sp[306] + sp[345];
    sp[363] = sp[307] + sp[346];
    sp[364] = sp[308] + sp[347];
    sp[365] = sp[309] + sp[348];
    sp[366] = sp[310] + sp[349];
    sp[367] = sp[311] + sp[350];
    sp[368] = sp[312] + sp[351];
    sp[369] = sp[313] + sp[352];
    sp[370] = w[6][1] * sp[295];
    sp[371] = sp[278] * sp[370];
    sp[372] = sp[279] * sp[370];
    sp[373] = sp[280] * sp[370];
    sp[374] = sp[281] * sp[370];
    sp[375] = sp[282] * sp[370];
    sp[376] = sp[283] * sp[370];
    sp[377] = sp[284] * sp[370];
    sp[378] = sp[285] * sp[370];
    sp[379] = sp[286] * sp[370];
    sp[380] = sp[287] * sp[370];
    sp[381] = sp[288] * sp[370];
    sp[382] = sp[289] * sp[370];
    sp[383] = sp[290] * sp[370];
    sp[384] = sp[291] * sp[370];
    sp[385] = sp[292] * sp[370];
    sp[386] = sp[293] * sp[370];
    sp[387] = sp[294] * sp[370];
    sp[388] = w[7][17] * sp[295];
    sp[389] = w[7][18] * sp[295];
    sp[390] = w[7][19] * sp[295];
    sp[391] = w[7][20] * sp[295];
    sp[392] = w[7][21] * sp[295];
    sp[393] = w[7][22] * sp[295];
    sp[394] = w[7][23] * sp[295];
    sp[395] = w[7][24] * sp[295];
    sp[396] = w[7][25] * sp[295];
    sp[397] = w[7][26] * sp[295];
    sp[398] = w[7][27] * sp[295];
    sp[399] = w[7][28] * sp[295];
    sp[400] = w[7][29] * sp[295];
    sp[401] = w[7][30] * sp[295];
    sp[402] = w[7][31] * sp[295];
    sp[403] = w[7][32] * sp[295];
    sp[404] = w[7][33] * sp[295];
    sp[405] = sp[318] * sp[388];
    sp[406] = sp[318] * sp[389];
    sp[407] = sp[318] * sp[390];
    sp[408] = sp[318] * sp[391];
    sp[409] = sp[318] * sp[392];
    sp[410] = sp[318] * sp[393];
    sp[411] = sp[318] * sp[394];
    sp[412] = sp[318] * sp[395];
    sp[413] = sp[318] * sp[396];
    sp[414] = sp[318] * sp[397];
    sp[415] = sp[318] * sp[398];
    sp[416] = sp[318] * sp[399];
    sp[417] = sp[318] * sp[400];
    sp[418] = sp[318] * sp[401];
    sp[419] = sp[318] * sp[402];
    sp[420] = sp[318] * sp[403];
    sp[421] = sp[318] * sp[404];
    sp[422] = sp[371] + sp[405];
    sp[423] = sp[372] + sp[406];
    sp[424] = sp[373] + sp[407];
    sp[425] = sp[374] + sp[408];
    sp[426] = sp[375] + sp[409];
    sp[427] = sp[376] + sp[410];
    sp[428] = sp[377] + sp[411];
    sp[429] = sp[378] + sp[412];
    sp[430] = sp[379] + sp[413];
    sp[431] = sp[380] + sp[414];
    sp[432] = sp[381] + sp[415];
    sp[433] = sp[382] + sp[416];
    sp[434] = sp[383] + sp[417];
    sp[435] = sp[384] + sp[418];
    sp[436] = sp[385] + sp[419];
    sp[437] = sp[386] + sp[420];
    sp[438] = sp[387] + sp[421];
    sp[439] = w[6][2] * sp[295];
    sp[440] = sp[278] * sp[439];
    sp[441] = sp[279] * sp[439];
    sp[442] = sp[280] * sp[439];
    sp[443] = sp[281] * sp[439];
    sp[444] = sp[282] * sp[439];
    sp[445] = sp[283] * sp[439];
    sp[446] = sp[284] * sp[439];
    sp[447] = sp[285] * sp[439];
    sp[448] = sp[286] * sp[439];
    sp[449] = sp[287] * sp[439];
    sp[450] = sp[288] * sp[439];
    sp[451] = sp[289] * sp[439];
    sp[452] = sp[290] * sp[439];
    sp[453] = sp[291] * sp[439];
    sp[454] = sp[292] * sp[439];
    sp[455] = sp[293] * sp[439];
    sp[456] = sp[294] * sp[439];
    sp[457] = w[7][34] * sp[295];
    sp[458] = w[7][35] * sp[295];
    sp[459] = w[7][36] * sp[295];
    sp[460] = w[7][37] * sp[295];
    sp[461] = w[7][38] * sp[295];
    sp[462] = w[7][39] * sp[295];
    sp[463] = w[7][40] * sp[295];
    sp[464] = w[7][41] * sp[295];
    sp[465] = w[7][42] * sp[295];
    sp[466] = w[7][43] * sp[295];
    sp[467] = w[7][44] * sp[295];
    sp[468] = w[7][45] * sp[295];
    sp[469] = w[7][46] * sp[295];
    sp[470] = w[7][47] * sp[295];
    sp[471] = w[7][48] * sp[295];
    sp[472] = w[7][49] * sp[295];
    sp[473] = w[7][50] * sp[295];
    sp[474] = sp[318] * sp[457];
    sp[475] = sp[318] * sp[458];
    sp[476] = sp[318] * sp[459];
    sp[477] = sp[318] * sp[460];
    sp[478] = sp[318] * sp[461];
    sp[479] = sp[318] * sp[462];
    sp[480] = sp[318] * sp[463];
    sp[481] = sp[318] * sp[464];
    sp[482] = sp[318] * sp[465];
    sp[483] = sp[318] * sp[466];
    sp[484] = sp[318] * sp[467];
    sp[485] = sp[318] * sp[468];
    sp[486] = sp[318] * sp[469];
    sp[487] = sp[318] * sp[470];
    sp[488] = sp[318] * sp[471];
    sp[489] = sp[318] * sp[472];
    sp[490] = sp[318] * sp[473];
    sp[491] = sp[440] + sp[474];
    sp[492] = sp[441] + sp[475];
    sp[493] = sp[442] + sp[476];
    sp[494] = sp[443] + sp[477];
    sp[495] = sp[444] + sp[478];
    sp[496] = sp[445] + sp[479];
    sp[497] = sp[446] + sp[480];
    sp[498] = sp[447] + sp[481];
    sp[499] = sp[448] + sp[482];
    sp[500] = sp[449] + sp[483];
    sp[501] = sp[450] + sp[484];
    sp[502] = sp[451] + sp[485];
    sp[503] = sp[452] + sp[486];
    sp[504] = sp[453] + sp[487];
    sp[505] = sp[454] + sp[488];
    sp[506] = sp[455] + sp[489];
    sp[507] = sp[456] + sp[490];
    sp[508] = w[6][3] * sp[295];
    sp[509] = sp[278] * sp[508];
    sp[510] = sp[279] * sp[508];
    sp[511] = sp[280] * sp[508];
    sp[512] = sp[281] * sp[508];
    sp[513] = sp[282] * sp[508];
    sp[514] = sp[283] * sp[508];
    sp[515] = sp[284] * sp[508];
    sp[516] = sp[285] * sp[508];
    sp[517] = sp[286] * sp[508];
    sp[518] = sp[287] * sp[508];
    sp[519] = sp[288] * sp[508];
    sp[520] = sp[289] * sp[508];
    sp[521] = sp[290] * sp[508];
    sp[522] = sp[291] * sp[508];
    sp[523] = sp[292] * sp[508];
    sp[524] = sp[293] * sp[508];
    sp[525] = sp[294] * sp[508];
    sp[526] = w[7][51] * sp[295];
    sp[527] = w[7][52] * sp[295];
    sp[528] = w[7][53] * sp[295];
    sp[529] = w[7][54] * sp[295];
    sp[530] = w[7][55] * sp[295];
    sp[531] = w[7][56] * sp[295];
    sp[532] = w[7][57] * sp[295];
    sp[533] = w[7][58] * sp[295];
    sp[534] = w[7][59] * sp[295];
    sp[535] = w[7][60] * sp[295];
    sp[536] = w[7][61] * sp[295];
    sp[537] = w[7][62] * sp[295];
    sp[538] = w[7][63] * sp[295];
    sp[539] = w[7][64] * sp[295];
    sp[540] = w[7][65] * sp[295];
    sp[541] = w[7][66] * sp[295];
    sp[542] = w[7][67] * sp[295];
    sp[543] = sp[318] * sp[526];
    sp[544] = sp[318] * sp[527];
    sp[545] = sp[318] * sp[528];
    sp[546] = sp[318] * sp[529];
    sp[547] = sp[318] * sp[530];
    sp[548] = sp[318] * sp[531];
    sp[549] = sp[318] * sp[532];
    sp[550] = sp[318] * sp[533];
    sp[551] = sp[318] * sp[534];
    sp[552] = sp[318] * sp[535];
    sp[553] = sp[318] * sp[536];
    sp[554] = sp[318] * sp[537];
    sp[555] = sp[318] * sp[538];
    sp[556] = sp[318] * sp[539];
    sp[557] = sp[318] * sp[540];
    sp[558] = sp[318] * sp[541];
    sp[559] = sp[318] * sp[542];
    sp[560] = sp[509] + sp[543];
    sp[561] = sp[510] + sp[544];
    sp[562] = sp[511] + sp[545];
    sp[563] = sp[512] + sp[546];
    sp[564] = sp[513] + sp[547];
    sp[565] = sp[514] + sp[548];
    sp[566] = sp[515] + sp[549];
    sp[567] = sp[516] + sp[550];
    sp[568] = sp[517] + sp[551];
    sp[569] = sp[518] + sp[552];
    sp[570] = sp[519] + sp[553];
    sp[571] = sp[520] + sp[554];
    sp[572] = sp[521] + sp[555];
    sp[573] = sp[522] + sp[556];
    sp[574] = sp[523] + sp[557];
    sp[575] = sp[524] + sp[558];
    sp[576] = sp[525] + sp[559];
    sp[577] = w[6][4] * sp[295];
    sp[578] = sp[278] * sp[577];
    sp[579] = sp[279] * sp[577];
    sp[580] = sp[280] * sp[577];
    sp[581] = sp[281] * sp[577];
    sp[582] = sp[282] * sp[577];
    sp[583] = sp[283] * sp[577];
    sp[584] = sp[284] * sp[577];
    sp[585] = sp[285] * sp[577];
    sp[586] = sp[286] * sp[577];
    sp[587] = sp[287] * sp[577];
    sp[588] = sp[288] * sp[577];
    sp[589] = sp[289] * sp[577];
    sp[590] = sp[290] * sp[577];
    sp[591] = sp[291] * sp[577];
    sp[592] = sp[292] * sp[577];
    sp[593] = sp[293] * sp[577];
    sp[594] = sp[294] * sp[577];
    sp[595] = w[7][68] * sp[295];
    sp[596] = w[7][69] * sp[295];
    sp[597] = w[7][70] * sp[295];
    sp[598] = w[7][71] * sp[295];
    sp[599] = w[7][72] * sp[295];
    sp[600] = w[7][73] * sp[295];
    sp[601] = w[7][74] * sp[295];
    sp[602] = w[7][75] * sp[295];
    sp[603] = w[7][76] * sp[295];
    sp[604] = w[7][77] * sp[295];
    sp[605] = w[7][78] * sp[295];
    sp[606] = w[7][79] * sp[295];
    sp[607] = w[7][80] * sp[295];
    sp[608] = w[7][81] * sp[295];
    sp[609] = w[7][82] * sp[295];
    sp[610] = w[7][83] * sp[295];
    sp[611] = w[7][84] * sp[295];
    sp[612] = sp[318] * sp[595];
    sp[613] = sp[318] * sp[596];
    sp[614] = sp[318] * sp[597];
    sp[615] = sp[318] * sp[598];
    sp[616] = sp[318] * sp[599];
    sp[617] = sp[318] * sp[600];
    sp[618] = sp[318] * sp[601];
    sp[619] = sp[318] * sp[602];
    sp[620] = sp[318] * sp[603];
    sp[621] = sp[318] * sp[604];
    sp[622] = sp[318] * sp[605];
    sp[623] = sp[318] * sp[606];
    sp[624] = sp[318] * sp[607];
    sp[625] = sp[318] * sp[608];
    sp[626] = sp[318] * sp[609];
    sp[627] = sp[318] * sp[610];
    sp[628] = sp[318] * sp[611];
    sp[629] = sp[578] + sp[612];
    sp[630] = sp[579] + sp[613];
    sp[631] = sp[580] + sp[614];
    sp[632] = sp[581] + sp[615];
    sp[633] = sp[582] + sp[616];
    sp[634] = sp[583] + sp[617];
    sp[635] = sp[584] + sp[618];
    sp[636] = sp[585] + sp[619];
    sp[637] = sp[586] + sp[620];
    sp[638] = sp[587] + sp[621];
    sp[639] = sp[588] + sp[622];
    sp[640] = sp[589] + sp[623];
    sp[641] = sp[590] + sp[624];
    sp[642] = sp[591] + sp[625];
    sp[643] = sp[592] + sp[626];
    sp[644] = sp[593] + sp[627];
    sp[645] = sp[594] + sp[628];
    sp[646] = w[6][5] * sp[295];
    sp[647] = sp[278] * sp[646];
    sp[648] = sp[279] * sp[646];
    sp[649] = sp[280] * sp[646];
    sp[650] = sp[281] * sp[646];
    sp[651] = sp[282] * sp[646];
    sp[652] = sp[283] * sp[646];
    sp[653] = sp[284] * sp[646];
    sp[654] = sp[285] * sp[646];
    sp[655] = sp[286] * sp[646];
    sp[656] = sp[287] * sp[646];
    sp[657] = sp[288] * sp[646];
    sp[658] = sp[289] * sp[646];
    sp[659] = sp[290] * sp[646];
    sp[660] = sp[291] * sp[646];
    sp[661] = sp[292] * sp[646];
    sp[662] = sp[293] * sp[646];
    sp[663] = sp[294] * sp[646];
    sp[664] = w[7][85] * sp[295];
    sp[665] = w[7][86] * sp[295];
    sp[666] = w[7][87] * sp[295];
    sp[667] = w[7][88] * sp[295];
    sp[668] = w[7][89] * sp[295];
    sp[669] = w[7][90] * sp[295];
    sp[670] = w[7][91] * sp[295];
    sp[671] = w[7][92] * sp[295];
    sp[672] = w[7][93] * sp[295];
    sp[673] = w[7][94] * sp[295];
    sp[674] = w[7][95] * sp[295];
    sp[675] = w[7][96] * sp[295];
    sp[676] = w[7][97] * sp[295];
    sp[677] = w[7][98] * sp[295];
    sp[678] = w[7][99] * sp[295];
    sp[679] = w[7][100] * sp[295];
    sp[680] = w[7][101] * sp[295];
    sp[681] = sp[318] * sp[664];
    sp[682] = sp[318] * sp[665];
    sp[683] = sp[318] * sp[666];
    sp[684] = sp[318] * sp[667];
    sp[685] = sp[318] * sp[668];
    sp[686] = sp[318] * sp[669];
    sp[687] = sp[318] * sp[670];
    sp[688] = sp[318] * sp[671];
    sp[689] = sp[318] * sp[672];
    sp[690] = sp[318] * sp[673];
    sp[691] = sp[318] * sp[674];
    sp[692] = sp[318] * sp[675];
    sp[693] = sp[318] * sp[676];
    sp[694] = sp[318] * sp[677];
    sp[695] = sp[318] * sp[678];
    sp[696] = sp[318] * sp[679];
    sp[697] = sp[318] * sp[680];
    sp[698] = sp[647] + sp[681];
    sp[699] = sp[648] + sp[682];
    sp[700] = sp[649] + sp[683];
    sp[701] = sp[650] + sp[684];
    sp[702] = sp[651] + sp[685];
    sp[703] = sp[652] + sp[686];
    sp[704] = sp[653] + sp[687];
    sp[705] = sp[654] + sp[688];
    sp[706] = sp[655] + sp[689];
    sp[707] = sp[656] + sp[690];
    sp[708] = sp[657] + sp[691];
    sp[709] = sp[658] + sp[692];
    sp[710] = sp[659] + sp[693];
    sp[711] = sp[660] + sp[694];
    sp[712] = sp[661] + sp[695];
    sp[713] = sp[662] + sp[696];
    sp[714] = sp[663] + sp[697];
    sp[715] = w[7][0] * w[0][6];
    sp[716] = w[7][1] * w[0][6];
    sp[717] = w[7][2] * w[0][6];
    sp[718] = w[7][3] * w[0][6];
    sp[719] = w[7][4] * w[0][6];
    sp[720] = w[7][5] * w[0][6];
    sp[721] = w[7][6] * w[0][6];
    sp[722] = w[7][7] * w[0][6];
    sp[723] = w[7][8] * w[0][6];
    sp[724] = w[7][9] * w[0][6];
    sp[725] = w[7][10] * w[0][6];
    sp[726] = w[7][11] * w[0][6];
    sp[727] = w[7][12] * w[0][6];
    sp[728] = w[7][13] * w[0][6];
    sp[729] = w[7][14] * w[0][6];
    sp[730] = w[7][15] * w[0][6];
    sp[731] = w[7][16] * w[0][6];
    sp[732] = w[6][0] + sp[721];
    sp[733] = w[9][0] + -1 * sp[715];
    sp[734] = w[9][1] + -1 * sp[716];
    sp[735] = w[9][2] + -1 * sp[717];
    sp[736] = w[9][3] + -1 * sp[718];
    sp[737] = w[9][4] + -1 * sp[719];
    sp[738] = w[9][5] + -1 * sp[720];
    sp[739] = w[9][6] + -1 * sp[732];
    sp[740] = w[9][7] + -1 * sp[722];
    sp[741] = w[9][8] + -1 * sp[723];
    sp[742] = w[9][9] + -1 * sp[724];
    sp[743] = w[9][10] + -1 * sp[725];
    sp[744] = w[9][11] + -1 * sp[726];
    sp[745] = w[9][12] + -1 * sp[727];
    sp[746] = w[9][13] + -1 * sp[728];
    sp[747] = w[9][14] + -1 * sp[729];
    sp[748] = w[9][15] + -1 * sp[730];
    sp[749] = w[9][16] + -1 * sp[731];
    sp[750] = sp[733] * sp[295];
    sp[751] = sp[734] * sp[295];
    sp[752] = sp[735] * sp[295];
    sp[753] = sp[736] * sp[295];
    sp[754] = sp[737] * sp[295];
    sp[755] = sp[738] * sp[295];
    sp[756] = sp[739] * sp[295];
    sp[757] = sp[740] * sp[295];
    sp[758] = sp[741] * sp[295];
    sp[759] = sp[742] * sp[295];
    sp[760] = sp[743] * sp[295];
    sp[761] = sp[744] * sp[295];
    sp[762] = sp[745] * sp[295];
    sp[763] = sp[746] * sp[295];
    sp[764] = sp[747] * sp[295];
    sp[765] = sp[748] * sp[295];
    sp[766] = sp[749] * sp[295];
    sp[767] = sp[318] * sp[750];
    sp[768] = sp[318] * sp[751];
    sp[769] = sp[318] * sp[752];
    sp[770] = sp[318] * sp[753];
    sp[771] = sp[318] * sp[754];
    sp[772] = sp[318] * sp[755];
    sp[773] = sp[318] * sp[756];
    sp[774] = sp[318] * sp[757];
    sp[775] = sp[318] * sp[758];
    sp[776] = sp[318] * sp[759];
    sp[777] = sp[318] * sp[760];
    sp[778] = sp[318] * sp[761];
    sp[779] = sp[318] * sp[762];
    sp[780] = sp[318] * sp[763];
    sp[781] = sp[318] * sp[764];
    sp[782] = sp[318] * sp[765];
    sp[783] = sp[318] * sp[766];
    sp[784] = w[6][0] * w[0][6];
    sp[785] = w[8][0] + -1 * sp[784];
    sp[786] = sp[785] * sp[295];
    sp[787] = sp[278] * sp[786];
    sp[788] = sp[279] * sp[786];
    sp[789] = sp[280] * sp[786];
    sp[790] = sp[281] * sp[786];
    sp[791] = sp[282] * sp[786];
    sp[792] = sp[283] * sp[786];
    sp[793] = sp[284] * sp[786];
    sp[794] = sp[285] * sp[786];
    sp[795] = sp[286] * sp[786];
    sp[796] = sp[287] * sp[786];
    sp[797] = sp[288] * sp[786];
    sp[798] = sp[289] * sp[786];
    sp[799] = sp[290] * sp[786];
    sp[800] = sp[291] * sp[786];
    sp[801] = sp[292] * sp[786];
    sp[802] = sp[293] * sp[786];
    sp[803] = sp[294] * sp[786];
    sp[804] = sp[787] + sp[767];
    sp[805] = sp[788] + sp[768];
    sp[806] = sp[789] + sp[769];
    sp[807] = sp[790] + sp[770];
    sp[808] = sp[791] + sp[771];
    sp[809] = sp[792] + sp[772];
    sp[810] = sp[773] + sp[793];
    sp[811] = sp[794] + sp[774];
    sp[812] = sp[795] + sp[775];
    sp[813] = sp[796] + sp[776];
    sp[814] = sp[797] + sp[777];
    sp[815] = sp[798] + sp[778];
    sp[816] = sp[799] + sp[779];
    sp[817] = sp[800] + sp[780];
    sp[818] = sp[801] + sp[781];
    sp[819] = sp[802] + sp[782];
    sp[820] = sp[803] + sp[783];
    sp[821] = sp[318] * sp[786];
    sp[822] = w[0][0] + w[2][0];
    sp[823] = sp[821] / sp[822];
    sp[824] = sp[804] + -1 * sp[823];
    sp[825] = sp[824] / sp[822];
    sp[826] = sp[805] / sp[822];
    sp[827] = sp[806] / sp[822];
    sp[828] = sp[807] / sp[822];
    sp[829] = sp[808] / sp[822];
    sp[830] = sp[809] / sp[822];
    sp[831] = sp[810] / sp[822];
    sp[832] = sp[811] / sp[822];
    sp[833] = sp[812] / sp[822];
    sp[834] = sp[813] / sp[822];
    sp[835] = sp[814] / sp[822];
    sp[836] = sp[815] / sp[822];
    sp[837] = sp[816] / sp[822];
    sp[838] = sp[817] / sp[822];
    sp[839] = sp[818] / sp[822];
    sp[840] = sp[819] / sp[822];
    sp[841] = sp[820] / sp[822];
    sp[842] = w[7][0] * w[0][7];
    sp[843] = w[7][1] * w[0][7];
    sp[844] = w[7][2] * w[0][7];
    sp[845] = w[7][3] * w[0][7];
    sp[846] = w[7][4] * w[0][7];
    sp[847] = w[7][5] * w[0][7];
    sp[848] = w[7][6] * w[0][7];
    sp[849] = w[7][7] * w[0][7];
    sp[850] = w[7][8] * w[0][7];
    sp[851] = w[7][9] * w[0][7];
    sp[852] = w[7][10] * w[0][7];
    sp[853] = w[7][11] * w[0][7];
    sp[854] = w[7][12] * w[0][7];
    sp[855] = w[7][13] * w[0][7];
    sp[856] = w[7][14] * w[0][7];
    sp[857] = w[7][15] * w[0][7];
    sp[858] = w[7][16] * w[0][7];
    sp[859] = w[6][0] + sp[849];
    sp[860] = w[9][17] + -1 * sp[842];
    sp[861] = w[9][18] + -1 * sp[843];
    sp[862] = w[9][19] + -1 * sp[844];
    sp[863] = w[9][20] + -1 * sp[845];
    sp[864] = w[9][21] + -1 * sp[846];
    sp[865] = w[9][22] + -1 * sp[847];
    sp[866] = w[9][23] + -1 * sp[848];
    sp[867] = w[9][24] + -1 * sp[859];
    sp[868] = w[9][25] + -1 * sp[850];
    sp[869] = w[9][26] + -1 * sp[851];
    sp[870] = w[9][27] + -1 * sp[852];
    sp[871] = w[9][28] + -1 * sp[853];
    sp[872] = w[9][29] + -1 * sp[854];
    sp[873] = w[9][30] + -1 * sp[855];
    sp[874] = w[9][31] + -1 * sp[856];
    sp[875] = w[9][32] + -1 * sp[857];
    sp[876] = w[9][33] + -1 * sp[858];
    sp[877] = sp[860] * sp[295];
    sp[878] = sp[861] * sp[295];
    sp[879] = sp[862] * sp[295];
    sp[880] = sp[863] * sp[295];
    sp[881] = sp[864] * sp[295];
    sp[882] = sp[865] * sp[295];
    sp[883] = sp[866] * sp[295];
    sp[884] = sp[867] * sp[295];
    sp[885] = sp[868] * sp[295];
    sp[886] = sp[869] * sp[295];
    sp[887] = sp[870] * sp[295];
    sp[888] = sp[871] * sp[295];
    sp[889] = sp[872] * sp[295];
    sp[890] = sp[873] * sp[295];
    sp[891] = sp[874] * sp[295];
    sp[892] = sp[875] * sp[295];
    sp[893] = sp[876] * sp[295];
    sp[894] = sp[318] * sp[877];
    sp[895] = sp[318] * sp[878];
    sp[896] = sp[318] * sp[879];
    sp[897] = sp[318] * sp[880];
    sp[898] = sp[318] * sp[881];
    sp[899] = sp[318] * sp[882];
    sp[900] = sp[318] * sp[883];
    sp[901] = sp[318] * sp[884];
    sp[902] = sp[318] * sp[885];
    sp[903] = sp[318] * sp[886];
    sp[904] = sp[318] * sp[887];
    sp[905] = sp[318] * sp[888];
    sp[906] = sp[318] * sp[889];
    sp[907] = sp[318] * sp[890];
    sp[908] = sp[318] * sp[891];
    sp[909] = sp[318] * sp[892];
    sp[910] = sp[318] * sp[893];
    sp[911] = w[6][0] * w[0][7];
    sp[912] = w[8][1] + -1 * sp[911];
    sp[913] = sp[912] * sp[295];
    sp[914] = sp[278] * sp[913];
    sp[915] = sp[279] * sp[913];
    sp[916] = sp[280] * sp[913];
    sp[917] = sp[281] * sp[913];
    sp[918] = sp[282] * sp[913];
    sp[919] = sp[283] * sp[913];
    sp[920] = sp[284] * sp[913];
    sp[921] = sp[285] * sp[913];
    sp[922] = sp[286] * sp[913];
    sp[923] = sp[287] * sp[913];
    sp[924] = sp[288] * sp[913];
    sp[925] = sp[289] * sp[913];
    sp[926] = sp[290] * sp[913];
    sp[927] = sp[291] * sp[913];
    sp[928] = sp[292] * sp[913];
    sp[929] = sp[293] * sp[913];
    sp[930] = sp[294] * sp[913];
    sp[931] = sp[914] + sp[894];
    sp[932] = sp[915] + sp[895];
    sp[933] = sp[916] + sp[896];
    sp[934] = sp[917] + sp[897];
    sp[935] = sp[918] + sp[898];
    sp[936] = sp[919] + sp[899];
    sp[937] = sp[920] + sp[900];
    sp[938] = sp[901] + sp[921];
    sp[939] = sp[922] + sp[902];
    sp[940] = sp[923] + sp[903];
    sp[941] = sp[924] + sp[904];
    sp[942] = sp[925] + sp[905];
    sp[943] = sp[926] + sp[906];
    sp[944] = sp[927] + sp[907];
    sp[945] = sp[928] + sp[908];
    sp[946] = sp[929] + sp[909];
    sp[947] = sp[930] + sp[910];
    sp[948] = sp[318] * sp[913];
    sp[949] = sp[948] / sp[822];
    sp[950] = sp[931] + -1 * sp[949];
    sp[951] = sp[950] / sp[822];
    sp[952] = sp[932] / sp[822];
    sp[953] = sp[933] / sp[822];
    sp[954] = sp[934] / sp[822];
    sp[955] = sp[935] / sp[822];
    sp[956] = sp[936] / sp[822];
    sp[957] = sp[937] / sp[822];
    sp[958] = sp[938] / sp[822];
    sp[959] = sp[939] / sp[822];
    sp[960] = sp[940] / sp[822];
    sp[961] = sp[941] / sp[822];
    sp[962] = sp[942] / sp[822];
    sp[963] = sp[943] / sp[822];
    sp[964] = sp[944] / sp[822];
    sp[965] = sp[945] / sp[822];
    sp[966] = sp[946] / sp[822];
    sp[967] = sp[947] / sp[822];
    sp[968] = w[7][17] * w[0][8];
    sp[969] = w[7][18] * w[0][8];
    sp[970] = w[7][19] * w[0][8];
    sp[971] = w[7][20] * w[0][8];
    sp[972] = w[7][21] * w[0][8];
    sp[973] = w[7][22] * w[0][8];
    sp[974] = w[7][23] * w[0][8];
    sp[975] = w[7][24] * w[0][8];
    sp[976] = w[7][25] * w[0][8];
    sp[977] = w[7][26] * w[0][8];
    sp[978] = w[7][27] * w[0][8];
    sp[979] = w[7][28] * w[0][8];
    sp[980] = w[7][29] * w[0][8];
    sp[981] = w[7][30] * w[0][8];
    sp[982] = w[7][31] * w[0][8];
    sp[983] = w[7][32] * w[0][8];
    sp[984] = w[7][33] * w[0][8];
    sp[985] = w[6][1] + sp[976];
    sp[986] = w[9][34] + -1 * sp[968];
    sp[987] = w[9][35] + -1 * sp[969];
    sp[988] = w[9][36] + -1 * sp[970];
    sp[989] = w[9][37] + -1 * sp[971];
    sp[990] = w[9][38] + -1 * sp[972];
    sp[991] = w[9][39] + -1 * sp[973];
    sp[992] = w[9][40] + -1 * sp[974];
    sp[993] = w[9][41] + -1 * sp[975];
    sp[994] = w[9][42] + -1 * sp[985];
    sp[995] = w[9][43] + -1 * sp[977];
    sp[996] = w[9][44] + -1 * sp[978];
    sp[997] = w[9][45] + -1 * sp[979];
    sp[998] = w[9][46] + -1 * sp[980];
    sp[999] = w[9][47] + -1 * sp[981];
    sp[1000] = w[9][48] + -1 * sp[982];
    sp[1001] = w[9][49] + -1 * sp[983];
    sp[1002] = w[9][50] + -1 * sp[984];
    sp[1003] = sp[986] * sp[295];
    sp[1004] = sp[987] * sp[295];
    sp[1005] = sp[988] * sp[295];
    sp[1006] = sp[989] * sp[295];
    sp[1007] = sp[990] * sp[295];
    sp[1008] = sp[991] * sp[295];
    sp[1009] = sp[992] * sp[295];
    sp[1010] = sp[993] * sp[295];
    sp[1011] = sp[994] * sp[295];
    sp[1012] = sp[995] * sp[295];
    sp[1013] = sp[996] * sp[295];
    sp[1014] = sp[997] * sp[295];
    sp[1015] = sp[998] * sp[295];
    sp[1016] = sp[999] * sp[295];
    sp[1017] = sp[1000] * sp[295];
    sp[1018] = sp[1001] * sp[295];
    sp[1019] = sp[1002] * sp[295];
    sp[1020] = sp[318] * sp[1003];
    sp[1021] = sp[318] * sp[1004];
    sp[1022] = sp[318] * sp[1005];
    sp[1023] = sp[318] * sp[1006];
    sp[1024] = sp[318] * sp[1007];
    sp[1025] = sp[318] * sp[1008];
    sp[1026] = sp[318] * sp[1009];
    sp[1027] = sp[318] * sp[1010];
    sp[1028] = sp[318] * sp[1011];
    sp[1029] = sp[318] * sp[1012];
    sp[1030] = sp[318] * sp[1013];
    sp[1031] = sp[318] * sp[1014];
    sp[1032] = sp[318] * sp[1015];
    sp[1033] = sp[318] * sp[1016];
    sp[1034] = sp[318] * sp[1017];
    sp[1035] = sp[318] * sp[1018];
    sp[1036] = sp[318] * sp[1019];
    sp[1037] = w[6][1] * w[0][8];
    sp[1038] = w[8][2] + -1 * sp[1037];
    sp[1039] = sp[1038] * sp[295];
    sp[1040] = sp[278] * sp[1039];
    sp[1041] = sp[279] * sp[1039];
    sp[1042] = sp[280] * sp[1039];
    sp[1043] = sp[281] * sp[1039];
    sp[1044] = sp[282] * sp[1039];
    sp[1045] = sp[283] * sp[1039];
    sp[1046] = sp[284] * sp[1039];
    sp[1047] = sp[285] * sp[1039];
    sp[1048] = sp[286] * sp[1039];
    sp[1049] = sp[287] * sp[1039];
    sp[1050] = sp[288] * sp[1039];
    sp[1051] = sp[289] * sp[1039];
    sp[1052] = sp[290] * sp[1039];
    sp[1053] = sp[291] * sp[1039];
    sp[1054] = sp[292] * sp[1039];
    sp[1055] = sp[293] * sp[1039];
    sp[1056] = sp[294] * sp[1039];
    sp[1057] = sp[1040] + sp[1020];
    sp[1058] = sp[1041] + sp[1021];
    sp[1059] = sp[1042] + sp[1022];
    sp[1060] = sp[1043] + sp[1023];
    sp[1061] = sp[1044] + sp[1024];
    sp[1062] = sp[1045] + sp[1025];
    sp[1063] = sp[1046] + sp[1026];
    sp[1064] = sp[1047] + sp[1027];
    sp[1065] = sp[1028] + sp[1048];
    sp[1066] = sp[1049] + sp[1029];
    sp[1067] = sp[1050] + sp[1030];
    sp[1068] = sp[1051] + sp[1031];
    sp[1069] = sp[1052] + sp[1032];
    sp[1070] = sp[1053] + sp[1033];
    sp[1071] = sp[1054] + sp[1034];
    sp[1072] = sp[1055] + sp[1035];
    sp[1073] = sp[1056] + sp[1036];
    sp[1074] = sp[318] * sp[1039];
    sp[1075] = w[0][1] + w[2][0];
    sp[1076] = sp[1074] / sp[1075];
    sp[1077] = sp[1058] + -1 * sp[1076];
    sp[1078] = sp[1057] / sp[1075];
    sp[1079] = sp[1077] / sp[1075];
    sp[1080] = sp[1059] / sp[1075];
    sp[1081] = sp[1060] / sp[1075];
    sp[1082] = sp[1061] / sp[1075];
    sp[1083] = sp[1062] / sp[1075];
    sp[1084] = sp[1063] / sp[1075];
    sp[1085] = sp[1064] / sp[1075];
    sp[1086] = sp[1065] / sp[1075];
    sp[1087] = sp[1066] / sp[1075];
    sp[1088] = sp[1067] / sp[1075];
    sp[1089] = sp[1068] / sp[1075];
    sp[1090] = sp[1069] / sp[1075];
    sp[1091] = sp[1070] / sp[1075];
    sp[1092] = sp[1071] / sp[1075];
    sp[1093] = sp[1072] / sp[1075];
    sp[1094] = sp[1073] / sp[1075];
    sp[1095] = w[7][17] * w[0][9];
    sp[1096] = w[7][18] * w[0][9];
    sp[1097] = w[7][19] * w[0][9];
    sp[1098] = w[7][20] * w[0][9];
    sp[1099] = w[7][21] * w[0][9];
    sp[1100] = w[7][22] * w[0][9];
    sp[1101] = w[7][23] * w[0][9];
    sp[1102] = w[7][24] * w[0][9];
    sp[1103] = w[7][25] * w[0][9];
    sp[1104] = w[7][26] * w[0][9];
    sp[1105] = w[7][27] * w[0][9];
    sp[1106] = w[7][28] * w[0][9];
    sp[1107] = w[7][29] * w[0][9];
    sp[1108] = w[7][30] * w[0][9];
    sp[1109] = w[7][31] * w[0][9];
    sp[1110] = w[7][32] * w[0][9];
    sp[1111] = w[7][33] * w[0][9];
    sp[1112] = w[6][1] + sp[1104];
    sp[1113] = w[9][51] + -1 * sp[1095];
    sp[1114] = w[9][52] + -1 * sp[1096];
    sp[1115] = w[9][53] + -1 * sp[1097];
    sp[1116] = w[9][54] + -1 * sp[1098];
    sp[1117] = w[9][55] + -1 * sp[1099];
    sp[1118] = w[9][56] + -1 * sp[1100];
    sp[1119] = w[9][57] + -1 * sp[1101];
    sp[1120] = w[9][58] + -1 * sp[1102];
    sp[1121] = w[9][59] + -1 * sp[1103];
    sp[1122] = w[9][60] + -1 * sp[1112];
    sp[1123] = w[9][61] + -1 * sp[1105];
    sp[1124] = w[9][62] + -1 * sp[1106];
    sp[1125] = w[9][63] + -1 * sp[1107];
    sp[1126] = w[9][64] + -1 * sp[1108];
    sp[1127] = w[9][65] + -1 * sp[1109];
    sp[1128] = w[9][66] + -1 * sp[1110];
    sp[1129] = w[9][67] + -1 * sp[1111];
    sp[1130] = sp[1113] * sp[295];
    sp[1131] = sp[1114] * sp[295];
    sp[1132] = sp[1115] * sp[295];
    sp[1133] = sp[1116] * sp[295];
    sp[1134] = sp[1117] * sp[295];
    sp[1135] = sp[1118] * sp[295];
    sp[1136] = sp[1119] * sp[295];
    sp[1137] = sp[1120] * sp[295];
    sp[1138] = sp[1121] * sp[295];
    sp[1139] = sp[1122] * sp[295];
    sp[1140] = sp[1123] * sp[295];
    sp[1141] = sp[1124] * sp[295];
    sp[1142] = sp[1125] * sp[295];
    sp[1143] = sp[1126] * sp[295];
    sp[1144] = sp[1127] * sp[295];
    sp[1145] = sp[1128] * sp[295];
    sp[1146] = sp[1129] * sp[295];
    sp[1147] = sp[318] * sp[1130];
    sp[1148] = sp[318] * sp[1131];
    sp[1149] = sp[318] * sp[1132];
    sp[1150] = sp[318] * sp[1133];
    sp[1151] = sp[318] * sp[1134];
    sp[1152] = sp[318] * sp[1135];
    sp[1153] = sp[318] * sp[1136];
    sp[1154] = sp[318] * sp[1137];
    sp[1155] = sp[318] * sp[1138];
    sp[1156] = sp[318] * sp[1139];
    sp[1157] = sp[318] * sp[1140];
    sp[1158] = sp[318] * sp[1141];
    sp[1159] = sp[318] * sp[1142];
    sp[1160] = sp[318] * sp[1143];
    sp[1161] = sp[318] * sp[1144];
    sp[1162] = sp[318] * sp[1145];
    sp[1163] = sp[318] * sp[1146];
    sp[1164] = w[6][1] * w[0][9];
    sp[1165] = w[8][3] + -1 * sp[1164];
    sp[1166] = sp[1165] * sp[295];
    sp[1167] = sp[278] * sp[1166];
    sp[1168] = sp[279] * sp[1166];
    sp[1169] = sp[280] * sp[1166];
    sp[1170] = sp[281] * sp[1166];
    sp[1171] = sp[282] * sp[1166];
    sp[1172] = sp[283] * sp[1166];
    sp[1173] = sp[284] * sp[1166];
    sp[1174] = sp[285] * sp[1166];
    sp[1175] = sp[286] * sp[1166];
    sp[1176] = sp[287] * sp[1166];
    sp[1177] = sp[288] * sp[1166];
    sp[1178] = sp[289] * sp[1166];
    sp[1179] = sp[290] * sp[1166];
    sp[1180] = sp[291] * sp[1166];
    sp[1181] = sp[292] * sp[1166];
    sp[1182] = sp[293] * sp[1166];
    sp[1183] = sp[294] * sp[1166];
    sp[1184] = sp[1167] + sp[1147];
    sp[1185] = sp[1168] + sp[1148];
    sp[1186] = sp[1169] + sp[1149];
    sp[1187] = sp[1170] + sp[1150];
    sp[1188] = sp[1171] + sp[1151];
    sp[1189] = sp[1172] + sp[1152];
    sp[1190] = sp[1173] + sp[1153];
    sp[1191] = sp[1174] + sp[1154];
    sp[1192] = sp[1175] + sp[1155];
    sp[1193] = sp[1156] + sp[1176];
    sp[1194] = sp[1177] + sp[1157];
    sp[1195] = sp[1178] + sp[1158];
    sp[1196] = sp[1179] + sp[1159];
    sp[1197] = sp[1180] + sp[1160];
    sp[1198] = sp[1181] + sp[1161];
    sp[1199] = sp[1182] + sp[1162];
    sp[1200] = sp[1183] + sp[1163];
    sp[1201] = sp[318] * sp[1166];
    sp[1202] = sp[1201] / sp[1075];
    sp[1203] = sp[1185] + -1 * sp[1202];
    sp[1204] = sp[1184] / sp[1075];
    sp[1205] = sp[1203] / sp[1075];
    sp[1206] = sp[1186] / sp[1075];
    sp[1207] = sp[1187] / sp[1075];
    sp[1208] = sp[1188] / sp[1075];
    sp[1209] = sp[1189] / sp[1075];
    sp[1210] = sp[1190] / sp[1075];
    sp[1211] = sp[1191] / sp[1075];
    sp[1212] = sp[1192] / sp[1075];
    sp[1213] = sp[1193] / sp[1075];
    sp[1214] = sp[1194] / sp[1075];
    sp[1215] = sp[1195] / sp[1075];
    sp[1216] = sp[1196] / sp[1075];
    sp[1217] = sp[1197] / sp[1075];
    sp[1218] = sp[1198] / sp[1075];
    sp[1219] = sp[1199] / sp[1075];
    sp[1220] = sp[1200] / sp[1075];
    sp[1221] = w[7][34] * w[0][10];
    sp[1222] = w[7][35] * w[0][10];
    sp[1223] = w[7][36] * w[0][10];
    sp[1224] = w[7][37] * w[0][10];
    sp[1225] = w[7][38] * w[0][10];
    sp[1226] = w[7][39] * w[0][10];
    sp[1227] = w[7][40] * w[0][10];
    sp[1228] = w[7][41] * w[0][10];
    sp[1229] = w[7][42] * w[0][10];
    sp[1230] = w[7][43] * w[0][10];
    sp[1231] = w[7][44] * w[0][10];
    sp[1232] = w[7][45] * w[0][10];
    sp[1233] = w[7][46] * w[0][10];
    sp[1234] = w[7][47] * w[0][10];
    sp[1235] = w[7][48] * w[0][10];
    sp[1236] = w[7][49] * w[0][10];
    sp[1237] = w[7][50] * w[0][10];
    sp[1238] = w[6][2] + sp[1231];
    sp[1239] = w[9][68] + -1 * sp[1221];
    sp[1240] = w[9][69] + -1 * sp[1222];
    sp[1241] = w[9][70] + -1 * sp[1223];
    sp[1242] = w[9][71] + -1 * sp[1224];
    sp[1243] = w[9][72] + -1 * sp[1225];
    sp[1244] = w[9][73] + -1 * sp[1226];
    sp[1245] = w[9][74] + -1 * sp[1227];
    sp[1246] = w[9][75] + -1 * sp[1228];
    sp[1247] = w[9][76] + -1 * sp[1229];
    sp[1248] = w[9][77] + -1 * sp[1230];
    sp[1249] = w[9][78] + -1 * sp[1238];
    sp[1250] = w[9][79] + -1 * sp[1232];
    sp[1251] = w[9][80] + -1 * sp[1233];
    sp[1252] = w[9][81] + -1 * sp[1234];
    sp[1253] = w[9][82] + -1 * sp[1235];
    sp[1254] = w[9][83] + -1 * sp[1236];
    sp[1255] = w[9][84] + -1 * sp[1237];
    sp[1256] = sp[1239] * sp[295];
    sp[1257] = sp[1240] * sp[295];
    sp[1258] = sp[1241] * sp[295];
    sp[1259] = sp[1242] * sp[295];
    sp[1260] = sp[1243] * sp[295];
    sp[1261] = sp[1244] * sp[295];
    sp[1262] = sp[1245] * sp[295];
    sp[1263] = sp[1246] * sp[295];
    sp[1264] = sp[1247] * sp[295];
    sp[1265] = sp[1248] * sp[295];
    sp[1266] = sp[1249] * sp[295];
    sp[1267] = sp[1250] * sp[295];
    sp[1268] = sp[1251] * sp[295];
    sp[1269] = sp[1252] * sp[295];
    sp[1270] = sp[1253] * sp[295];
    sp[1271] = sp[1254] * sp[295];
    sp[1272] = sp[1255] * sp[295];
    sp[1273] = sp[318] * sp[1256];
    sp[1274] = sp[318] * sp[1257];
    sp[1275] = sp[318] * sp[1258];
    sp[1276] = sp[318] * sp[1259];
    sp[1277] = sp[318] * sp[1260];
    sp[1278] = sp[318] * sp[1261];
    sp[1279] = sp[318] * sp[1262];
    sp[1280] = sp[318] * sp[1263];
    sp[1281] = sp[318] * sp[1264];
    sp[1282] = sp[318] * sp[1265];
    sp[1283] = sp[318] * sp[1266];
    sp[1284] = sp[318] * sp[1267];
    sp[1285] = sp[318] * sp[1268];
    sp[1286] = sp[318] * sp[1269];
    sp[1287] = sp[318] * sp[1270];
    sp[1288] = sp[318] * sp[1271];
    sp[1289] = sp[318] * sp[1272];
    sp[1290] = w[6][2] * w[0][10];
    sp[1291] = w[8][4] + -1 * sp[1290];
    sp[1292] = sp[1291] * sp[295];
    sp[1293] = sp[278] * sp[1292];
    sp[1294] = sp[279] * sp[1292];
    sp[1295] = sp[280] * sp[1292];
    sp[1296] = sp[281] * sp[1292];
    sp[1297] = sp[282] * sp[1292];
    sp[1298] = sp[283] * sp[1292];
    sp[1299] = sp[284] * sp[1292];
    sp[1300] = sp[285] * sp[1292];
    sp[1301] = sp[286] * sp[1292];
    sp[1302] = sp[287] * sp[1292];
    sp[1303] = sp[288] * sp[1292];
    sp[1304] = sp[289] * sp[1292];
    sp[1305] = sp[290] * sp[1292];
    sp[1306] = sp[291] * sp[1292];
    sp[1307] = sp[292] * sp[1292];
    sp[1308] = sp[293] * sp[1292];
    sp[1309] = sp[294] * sp[1292];
    sp[1310] = sp[1293] + sp[1273];
    sp[1311] = sp[1294] + sp[1274];
    sp[1312] = sp[1295] + sp[1275];
    sp[1313] = sp[1296] + sp[1276];
    sp[1314] = sp[1297] + sp[1277];
    sp[1315] = sp[1298] + sp[1278];
    sp[1316] = sp[1299] + sp[1279];
    sp[1317] = sp[1300] + sp[1280];
    sp[1318] = sp[1301] + sp[1281];
    sp[1319] = sp[1302] + sp[1282];
    sp[1320] = sp[1283] + sp[1303];
    sp[1321] = sp[1304] + sp[1284];
    sp[1322] = sp[1305] + sp[1285];
    sp[1323] = sp[1306] + sp[1286];
    sp[1324] = sp[1307] + sp[1287];
    sp[1325] = sp[1308] + sp[1288];
    sp[1326] = sp[1309] + sp[1289];
    sp[1327] = sp[318] * sp[1292];
    sp[1328] = w[0][2] + w[2][0];
    sp[1329] = sp[1327] / sp[1328];
    sp[1330] = sp[1312] + -1 * sp[1329];
    sp[1331] = sp[1310] / sp[1328];
    sp[1332] = sp[1311] / sp[1328];
    sp[1333] = sp[1330] / sp[1328];
    sp[1334] = sp[1313] / sp[1328];
    sp[1335] = sp[1314] / sp[1328];
    sp[1336] = sp[1315] / sp[1328];
    sp[1337] = sp[1316] / sp[1328];
    sp[1338] = sp[1317] / sp[1328];
    sp[1339] = sp[1318] / sp[1328];
    sp[1340] = sp[1319] / sp[1328];
    sp[1341] = sp[1320] / sp[1328];
    sp[1342] = sp[1321] / sp[1328];
    sp[1343] = sp[1322] / sp[1328];
    sp[1344] = sp[1323] / sp[1328];
    sp[1345] = sp[1324] / sp[1328];
    sp[1346] = sp[1325] / sp[1328];
    sp[1347] = sp[1326] / sp[1328];
    sp[1348] = w[7][34] * w[0][11];
    sp[1349] = w[7][35] * w[0][11];
    sp[1350] = w[7][36] * w[0][11];
    sp[1351] = w[7][37] * w[0][11];
    sp[1352] = w[7][38] * w[0][11];
    sp[1353] = w[7][39] * w[0][11];
    sp[1354] = w[7][40] * w[0][11];
    sp[1355] = w[7][41] * w[0][11];
    sp[1356] = w[7][42] * w[0][11];
    sp[1357] = w[7][43] * w[0][11];
    sp[1358] = w[7][44] * w[0][11];
    sp[1359] = w[7][45] * w[0][11];
    sp[1360] = w[7][46] * w[0][11];
    sp[1361] = w[7][47] * w[0][11];
    sp[1362] = w[7][48] * w[0][11];
    sp[1363] = w[7][49] * w[0][11];
    sp[1364] = w[7][50] * w[0][11];
    sp[1365] = w[6][2] + sp[1359];
    sp[1366] = w[9][85] + -1 * sp[1348];
    sp[1367] = w[9][86] + -1 * sp[1349];
    sp[1368] = w[9][87] + -1 * sp[1350];
    sp[1369] = w[9][88] + -1 * sp[1351];
    sp[1370] = w[9][89] + -1 * sp[1352];
    sp[1371] = w[9][90] + -1 * sp[1353];
    sp[1372] = w[9][91] + -1 * sp[1354];
    sp[1373] = w[9][92] + -1 * sp[1355];
    sp[1374] = w[9][93] + -1 * sp[1356];
    sp[1375] = w[9][94] + -1 * sp[1357];
    sp[1376] = w[9][95] + -1 * sp[1358];
    sp[1377] = w[9][96] + -1 * sp[1365];
    sp[1378] = w[9][97] + -1 * sp[1360];
    sp[1379] = w[9][98] + -1 * sp[1361];
    sp[1380] = w[9][99] + -1 * sp[1362];
    sp[1381] = w[9][100] + -1 * sp[1363];
    sp[1382] = w[9][101] + -1 * sp[1364];
    sp[1383] = sp[1366] * sp[295];
    sp[1384] = sp[1367] * sp[295];
    sp[1385] = sp[1368] * sp[295];
    sp[1386] = sp[1369] * sp[295];
    sp[1387] = sp[1370] * sp[295];
    sp[1388] = sp[1371] * sp[295];
    sp[1389] = sp[1372] * sp[295];
    sp[1390] = sp[1373] * sp[295];
    sp[1391] = sp[1374] * sp[295];
    sp[1392] = sp[1375] * sp[295];
    sp[1393] = sp[1376] * sp[295];
    sp[1394] = sp[1377] * sp[295];
    sp[1395] = sp[1378] * sp[295];
    sp[1396] = sp[1379] * sp[295];
    sp[1397] = sp[1380] * sp[295];
    sp[1398] = sp[1381] * sp[295];
    sp[1399] = sp[1382] * sp[295];
    sp[1400] = sp[318] * sp[1383];
    sp[1401] = sp[318] * sp[1384];
    sp[1402] = sp[318] * sp[1385];
    sp[1403] = sp[318] * sp[1386];
    sp[1404] = sp[318] * sp[1387];
    sp[1405] = sp[318] * sp[1388];
    sp[1406] = sp[318] * sp[1389];
    sp[1407] = sp[318] * sp[1390];
    sp[1408] = sp[318] * sp[1391];
    sp[1409] = sp[318] * sp[1392];
    sp[1410] = sp[318] * sp[1393];
    sp[1411] = sp[318] * sp[1394];
    sp[1412] = sp[318] * sp[1395];
    sp[1413] = sp[318] * sp[1396];
    sp[1414] = sp[318] * sp[1397];
    sp[1415] = sp[318] * sp[1398];
    sp[1416] = sp[318] * sp[1399];
    sp[1417] = w[6][2] * w[0][11];
    sp[1418] = w[8][5] + -1 * sp[1417];
    sp[1419] = sp[1418] * sp[295];
    sp[1420] = sp[278] * sp[1419];
    sp[1421] = sp[279] * sp[1419];
    sp[1422] = sp[280] * sp[1419];
    sp[1423] = sp[281] * sp[1419];
    sp[1424] = sp[282] * sp[1419];
    sp[1425] = sp[283] * sp[1419];
    sp[1426] = sp[284] * sp[1419];
    sp[1427] = sp[285] * sp[1419];
    sp[1428] = sp[286] * sp[1419];
    sp[1429] = sp[287] * sp[1419];
    sp[1430] = sp[288] * sp[1419];
    sp[1431] = sp[289] * sp[1419];
    sp[1432] = sp[290] * sp[1419];
    sp[1433] = sp[291] * sp[1419];
    sp[1434] = sp[292] * sp[1419];
    sp[1435] = sp[293] * sp[1419];
    sp[1436] = sp[294] * sp[1419];
    sp[1437] = sp[1420] + sp[1400];
    sp[1438] = sp[1421] + sp[1401];
    sp[1439] = sp[1422] + sp[1402];
    sp[1440] = sp[1423] + sp[1403];
    sp[1441] = sp[1424] + sp[1404];
    sp[1442] = sp[1425] + sp[1405];
    sp[1443] = sp[1426] + sp[1406];
    sp[1444] = sp[1427] + sp[1407];
    sp[1445] = sp[1428] + sp[1408];
    sp[1446] = sp[1429] + sp[1409];
    sp[1447] = sp[1430] + sp[1410];
    sp[1448] = sp[1411] + sp[1431];
    sp[1449] = sp[1432] + sp[1412];
    sp[1450] = sp[1433] + sp[1413];
    sp[1451] = sp[1434] + sp[1414];
    sp[1452] = sp[1435] + sp[1415];
    sp[1453] = sp[1436] + sp[1416];
    sp[1454] = sp[318] * sp[1419];
    sp[1455] = sp[1454] / sp[1328];
    sp[1456] = sp[1439] + -1 * sp[1455];
    sp[1457] = sp[1437] / sp[1328];
    sp[1458] = sp[1438] / sp[1328];
    sp[1459] = sp[1456] / sp[1328];
    sp[1460] = sp[1440] / sp[1328];
    sp[1461] = sp[1441] / sp[1328];
    sp[1462] = sp[1442] / sp[1328];
    sp[1463] = sp[1443] / sp[1328];
    sp[1464] = sp[1444] / sp[1328];
    sp[1465] = sp[1445] / sp[1328];
    sp[1466] = sp[1446] / sp[1328];
    sp[1467] = sp[1447] / sp[1328];
    sp[1468] = sp[1448] / sp[1328];
    sp[1469] = sp[1449] / sp[1328];
    sp[1470] = sp[1450] / sp[1328];
    sp[1471] = sp[1451] / sp[1328];
    sp[1472] = sp[1452] / sp[1328];
    sp[1473] = sp[1453] / sp[1328];
    sp[1474] = w[7][51] * w[0][12];
    sp[1475] = w[7][52] * w[0][12];
    sp[1476] = w[7][53] * w[0][12];
    sp[1477] = w[7][54] * w[0][12];
    sp[1478] = w[7][55] * w[0][12];
    sp[1479] = w[7][56] * w[0][12];
    sp[1480] = w[7][57] * w[0][12];
    sp[1481] = w[7][58] * w[0][12];
    sp[1482] = w[7][59] * w[0][12];
    sp[1483] = w[7][60] * w[0][12];
    sp[1484] = w[7][61] * w[0][12];
    sp[1485] = w[7][62] * w[0][12];
    sp[1486] = w[7][63] * w[0][12];
    sp[1487] = w[7][64] * w[0][12];
    sp[1488] = w[7][65] * w[0][12];
    sp[1489] = w[7][66] * w[0][12];
    sp[1490] = w[7][67] * w[0][12];
    sp[1491] = w[6][3] + sp[1486];
    sp[1492] = w[9][102] + -1 * sp[1474];
    sp[1493] = w[9][103] + -1 * sp[1475];
    sp[1494] = w[9][104] + -1 * sp[1476];
    sp[1495] = w[9][105] + -1 * sp[1477];
    sp[1496] = w[9][106] + -1 * sp[1478];
    sp[1497] = w[9][107] + -1 * sp[1479];
    sp[1498] = w[9][108] + -1 * sp[1480];
    sp[1499] = w[9][109] + -1 * sp[1481];
    sp[1500] = w[9][110] + -1 * sp[1482];
    sp[1501] = w[9][111] + -1 * sp[1483];
    sp[1502] = w[9][112] + -1 * sp[1484];
    sp[1503] = w[9][113] + -1 * sp[1485];
    sp[1504] = w[9][114] + -1 * sp[1491];
    sp[1505] = w[9][115] + -1 * sp[1487];
    sp[1506] = w[9][116] + -1 * sp[1488];
    sp[1507] = w[9][117] + -1 * sp[1489];
    sp[1508] = w[9][118] + -1 * sp[1490];
    sp[1509] = sp[1492] * sp[295];
    sp[1510] = sp[1493] * sp[295];
    sp[1511] = sp[1494] * sp[295];
    sp[1512] = sp[1495] * sp[295];
    sp[1513] = sp[1496] * sp[295];
    sp[1514] = sp[1497] * sp[295];
    sp[1515] = sp[1498] * sp[295];
    sp[1516] = sp[1499] * sp[295];
    sp[1517] = sp[1500] * sp[295];
    sp[1518] = sp[1501] * sp[295];
    sp[1519] = sp[1502] * sp[295];
    sp[1520] = sp[1503] * sp[295];
    sp[1521] = sp[1504] * sp[295];
    sp[1522] = sp[1505] * sp[295];
    sp[1523] = sp[1506] * sp[295];
    sp[1524] = sp[1507] * sp[295];
    sp[1525] = sp[1508] * sp[295];
    sp[1526] = sp[318] * sp[1509];
    sp[1527] = sp[318] * sp[1510];
    sp[1528] = sp[318] * sp[1511];
    sp[1529] = sp[318] * sp[1512];
    sp[1530] = sp[318] * sp[1513];
    sp[1531] = sp[318] * sp[1514];
    sp[1532] = sp[318] * sp[1515];
    sp[1533] = sp[318] * sp[1516];
    sp[1534] = sp[318] * sp[1517];
    sp[1535] = sp[318] * sp[1518];
    sp[1536] = sp[318] * sp[1519];
    sp[1537] = sp[318] * sp[1520];
    sp[1538] = sp[318] * sp[1521];
    sp[1539] = sp[318] * sp[1522];
    sp[1540] = sp[318] * sp[1523];
    sp[1541] = sp[318] * sp[1524];
    sp[1542] = sp[318] * sp[1525];
    sp[1543] = w[6][3] * w[0][12];
    sp[1544] = w[8][6] + -1 * sp[1543];
    sp[1545] = sp[1544] * sp[295];
    sp[1546] = sp[278] * sp[1545];
    sp[1547] = sp[279] * sp[1545];
    sp[1548] = sp[280] * sp[1545];
    sp[1549] = sp[281] * sp[1545];
    sp[1550] = sp[282] * sp[1545];
    sp[1551] = sp[283] * sp[1545];
    sp[1552] = sp[284] * sp[1545];
    sp[1553] = sp[285] * sp[1545];
    sp[1554] = sp[286] * sp[1545];
    sp[1555] = sp[287] * sp[1545];
    sp[1556] = sp[288] * sp[1545];
    sp[1557] = sp[289] * sp[1545];
    sp[1558] = sp[290] * sp[1545];
    sp[1559] = sp[291] * sp[1545];
    sp[1560] = sp[292] * sp[1545];
    sp[1561] = sp[293] * sp[1545];
    sp[1562] = sp[294] * sp[1545];
    sp[1563] = sp[1546] + sp[1526];
    sp[1564] = sp[1547] + sp[1527];
    sp[1565] = sp[1548] + sp[1528];
    sp[1566] = sp[1549] + sp[1529];
    sp[1567] = sp[1550] + sp[1530];
    sp[1568] = sp[1551] + sp[1531];
    sp[1569] = sp[1552] + sp[1532];
    sp[1570] = sp[1553] + sp[1533];
    sp[1571] = sp[1554] + sp[1534];
    sp[1572] = sp[1555] + sp[1535];
    sp[1573] = sp[1556] + sp[1536];
    sp[1574] = sp[1557] + sp[1537];
    sp[1575] = sp[1538] + sp[1558];
    sp[1576] = sp[1559] + sp[1539];
    sp[1577] = sp[1560] + sp[1540];
    sp[1578] = sp[1561] + sp[1541];
    sp[1579] = sp[1562] + sp[1542];
    sp[1580] = sp[318] * sp[1545];
    sp[1581] = w[0][3] + w[2][0];
    sp[1582] = sp[1580] / sp[1581];
    sp[1583] = sp[1566] + -1 * sp[1582];
    sp[1584] = sp[1563] / sp[1581];
    sp[1585] = sp[1564] / sp[1581];
    sp[1586] = sp[1565] / sp[1581];
    sp[1587] = sp[1583] / sp[1581];
    sp[1588] = sp[1567] / sp[1581];
    sp[1589] = sp[1568] / sp[1581];
    sp[1590] = sp[1569] / sp[1581];
    sp[1591] = sp[1570] / sp[1581];
    sp[1592] = sp[1571] / sp[1581];
    sp[1593] = sp[1572] / sp[1581];
    sp[1594] = sp[1573] / sp[1581];
    sp[1595] = sp[1574] / sp[1581];
    sp[1596] = sp[1575] / sp[1581];
    sp[1597] = sp[1576] / sp[1581];
    sp[1598] = sp[1577] / sp[1581];
    sp[1599] = sp[1578] / sp[1581];
    sp[1600] = sp[1579] / sp[1581];
    sp[1601] = w[7][51] * w[0][13];
    sp[1602] = w[7][52] * w[0][13];
    sp[1603] = w[7][53] * w[0][13];
    sp[1604] = w[7][54] * w[0][13];
    sp[1605] = w[7][55] * w[0][13];
    sp[1606] = w[7][56] * w[0][13];
    sp[1607] = w[7][57] * w[0][13];
    sp[1608] = w[7][58] * w[0][13];
    sp[1609] = w[7][59] * w[0][13];
    sp[1610] = w[7][60] * w[0][13];
    sp[1611] = w[7][61] * w[0][13];
    sp[1612] = w[7][62] * w[0][13];
    sp[1613] = w[7][63] * w[0][13];
    sp[1614] = w[7][64] * w[0][13];
    sp[1615] = w[7][65] * w[0][13];
    sp[1616] = w[7][66] * w[0][13];
    sp[1617] = w[7][67] * w[0][13];
    sp[1618] = w[6][3] + sp[1614];
    sp[1619] = w[9][119] + -1 * sp[1601];
    sp[1620] = w[9][120] + -1 * sp[1602];
    sp[1621] = w[9][121] + -1 * sp[1603];
    sp[1622] = w[9][122] + -1 * sp[1604];
    sp[1623] = w[9][123] + -1 * sp[1605];
    sp[1624] = w[9][124] + -1 * sp[1606];
    sp[1625] = w[9][125] + -1 * sp[1607];
    sp[1626] = w[9][126] + -1 * sp[1608];
    sp[1627] = w[9][127] + -1 * sp[1609];
    sp[1628] = w[9][128] + -1 * sp[1610];
    sp[1629] = w[9][129] + -1 * sp[1611];
    sp[1630] = w[9][130] + -1 * sp[1612];
    sp[1631] = w[9][131] + -1 * sp[1613];
    sp[1632] = w[9][132] + -1 * sp[1618];
    sp[1633] = w[9][133] + -1 * sp[1615];
    sp[1634] = w[9][134] + -1 * sp[1616];
    sp[1635] = w[9][135] + -1 * sp[1617];
    sp[1636] = sp[1619] * sp[295];
    sp[1637] = sp[1620] * sp[295];
    sp[1638] = sp[1621] * sp[295];
    sp[1639] = sp[1622] * sp[295];
    sp[1640] = sp[1623] * sp[295];
    sp[1641] = sp[1624] * sp[295];
    sp[1642] = sp[1625] * sp[295];
    sp[1643] = sp[1626] * sp[295];
    sp[1644] = sp[1627] * sp[295];
    sp[1645] = sp[1628] * sp[295];
    sp[1646] = sp[1629] * sp[295];
    sp[1647] = sp[1630] * sp[295];
    sp[1648] = sp[1631] * sp[295];
    sp[1649] = sp[1632] * sp[295];
    sp[1650] = sp[1633] * sp[295];
    sp[1651] = sp[1634] * sp[295];
    sp[1652] = sp[1635] * sp[295];
    sp[1653] = sp[318] * sp[1636];
    sp[1654] = sp[318] * sp[1637];
    sp[1655] = sp[318] * sp[1638];
    sp[1656] = sp[318] * sp[1639];
    sp[1657] = sp[318] * sp[1640];
    sp[1658] = sp[318] * sp[1641];
    sp[1659] = sp[318] * sp[1642];
    sp[1660] = sp[318] * sp[1643];
    sp[1661] = sp[318] * sp[1644];
    sp[1662] = sp[318] * sp[1645];
    sp[1663] = sp[318] * sp[1646];
    sp[1664] = sp[318] * sp[1647];
    sp[1665] = sp[318] * sp[1648];
    sp[1666] = sp[318] * sp[1649];
    sp[1667] = sp[318] * sp[1650];
    sp[1668] = sp[318] * sp[1651];
    sp[1669] = sp[318] * sp[1652];
    sp[1670] = w[6][3] * w[0][13];
    sp[1671] = w[8][7] + -1 * sp[1670];
    sp[1672] = sp[1671] * sp[295];
    sp[1673] = sp[278] * sp[1672];
    sp[1674] = sp[279] * sp[1672];
    sp[1675] = sp[280] * sp[1672];
    sp[1676] = sp[281] * sp[1672];
    sp[1677] = sp[282] * sp[1672];
    sp[1678] = sp[283] * sp[1672];
    sp[1679] = sp[284] * sp[1672];
    sp[1680] = sp[285] * sp[1672];
    sp[1681] = sp[286] * sp[1672];
    sp[1682] = sp[287] * sp[1672];
    sp[1683] = sp[288] * sp[1672];
    sp[1684] = sp[289] * sp[1672];
    sp[1685] = sp[290] * sp[1672];
    sp[1686] = sp[291] * sp[1672];
    sp[1687] = sp[292] * sp[1672];
    sp[1688] = sp[293] * sp[1672];
    sp[1689] = sp[294] * sp[1672];
    sp[1690] = sp[1673] + sp[1653];
    sp[1691] = sp[1674] + sp[1654];
    sp[1692] = sp[1675] + sp[1655];
    sp[1693] = sp[1676] + sp[1656];
    sp[1694] = sp[1677] + sp[1657];
    sp[1695] = sp[1678] + sp[1658];
    sp[1696] = sp[1679] + sp[1659];
    sp[1697] = sp[1680] + sp[1660];
    sp[1698] = sp[1681] + sp[1661];
    sp[1699] = sp[1682] + sp[1662];
    sp[1700] = sp[1683] + sp[1663];
    sp[1701] = sp[1684] + sp[1664];
    sp[1702] = sp[1685] + sp[1665];
    sp[1703] = sp[1666] + sp[1686];
    sp[1704] = sp[1687] + sp[1667];
    sp[1705] = sp[1688] + sp[1668];
    sp[1706] = sp[1689] + sp[1669];
    sp[1707] = sp[318] * sp[1672];
    sp[1708] = sp[1707] / sp[1581];
    sp[1709] = sp[1693] + -1 * sp[1708];
    sp[1710] = sp[1690] / sp[1581];
    sp[1711] = sp[1691] / sp[1581];
    sp[1712] = sp[1692] / sp[1581];
    sp[1713] = sp[1709] / sp[1581];
    sp[1714] = sp[1694] / sp[1581];
    sp[1715] = sp[1695] / sp[1581];
    sp[1716] = sp[1696] / sp[1581];
    sp[1717] = sp[1697] / sp[1581];
    sp[1718] = sp[1698] / sp[1581];
    sp[1719] = sp[1699] / sp[1581];
    sp[1720] = sp[1700] / sp[1581];
    sp[1721] = sp[1701] / sp[1581];
    sp[1722] = sp[1702] / sp[1581];
    sp[1723] = sp[1703] / sp[1581];
    sp[1724] = sp[1704] / sp[1581];
    sp[1725] = sp[1705] / sp[1581];
    sp[1726] = sp[1706] / sp[1581];
    sp[1727] = w[7][68] * w[0][14];
    sp[1728] = w[7][69] * w[0][14];
    sp[1729] = w[7][70] * w[0][14];
    sp[1730] = w[7][71] * w[0][14];
    sp[1731] = w[7][72] * w[0][14];
    sp[1732] = w[7][73] * w[0][14];
    sp[1733] = w[7][74] * w[0][14];
    sp[1734] = w[7][75] * w[0][14];
    sp[1735] = w[7][76] * w[0][14];
    sp[1736] = w[7][77] * w[0][14];
    sp[1737] = w[7][78] * w[0][14];
    sp[1738] = w[7][79] * w[0][14];
    sp[1739] = w[7][80] * w[0][14];
    sp[1740] = w[7][81] * w[0][14];
    sp[1741] = w[7][82] * w[0][14];
    sp[1742] = w[7][83] * w[0][14];
    sp[1743] = w[7][84] * w[0][14];
    sp[1744] = w[6][4] + sp[1741];
    sp[1745] = w[9][136] + -1 * sp[1727];
    sp[1746] = w[9][137] + -1 * sp[1728];
    sp[1747] = w[9][138] + -1 * sp[1729];
    sp[1748] = w[9][139] + -1 * sp[1730];
    sp[1749] = w[9][140] + -1 * sp[1731];
    sp[1750] = w[9][141] + -1 * sp[1732];
    sp[1751] = w[9][142] + -1 * sp[1733];
    sp[1752] = w[9][143] + -1 * sp[1734];
    sp[1753] = w[9][144] + -1 * sp[1735];
    sp[1754] = w[9][145] + -1 * sp[1736];
    sp[1755] = w[9][146] + -1 * sp[1737];
    sp[1756] = w[9][147] + -1 * sp[1738];
    sp[1757] = w[9][148] + -1 * sp[1739];
    sp[1758] = w[9][149] + -1 * sp[1740];
    sp[1759] = w[9][150] + -1 * sp[1744];
    sp[1760] = w[9][151] + -1 * sp[1742];
    sp[1761] = w[9][152] + -1 * sp[1743];
    sp[1762] = sp[1745] * sp[295];
    sp[1763] = sp[1746] * sp[295];
    sp[1764] = sp[1747] * sp[295];
    sp[1765] = sp[1748] * sp[295];
    sp[1766] = sp[1749] * sp[295];
    sp[1767] = sp[1750] * sp[295];
    sp[1768] = sp[1751] * sp[295];
    sp[1769] = sp[1752] * sp[295];
    sp[1770] = sp[1753] * sp[295];
    sp[1771] = sp[1754] * sp[295];
    sp[1772] = sp[1755] * sp[295];
    sp[1773] = sp[1756] * sp[295];
    sp[1774] = sp[1757] * sp[295];
    sp[1775] = sp[1758] * sp[295];
    sp[1776] = sp[1759] * sp[295];
    sp[1777] = sp[1760] * sp[295];
    sp[1778] = sp[1761] * sp[295];
    sp[1779] = sp[318] * sp[1762];
    sp[1780] = sp[318] * sp[1763];
    sp[1781] = sp[318] * sp[1764];
    sp[1782] = sp[318] * sp[1765];
    sp[1783] = sp[318] * sp[1766];
    sp[1784] = sp[318] * sp[1767];
    sp[1785] = sp[318] * sp[1768];
    sp[1786] = sp[318] * sp[1769];
    sp[1787] = sp[318] * sp[1770];
    sp[1788] = sp[318] * sp[1771];
    sp[1789] = sp[318] * sp[1772];
    sp[1790] = sp[318] * sp[1773];
    sp[1791] = sp[318] * sp[1774];
    sp[1792] = sp[318] * sp[1775];
    sp[1793] = sp[318] * sp[1776];
    sp[1794] = sp[318] * sp[1777];
    sp[1795] = sp[318] * sp[1778];
    sp[1796] = w[6][4] * w[0][14];
    sp[1797] = w[8][8] + -1 * sp[1796];
    sp[1798] = sp[1797] * sp[295];
    sp[1799] = sp[278] * sp[1798];
    sp[1800] = sp[279] * sp[1798];
    sp[1801] = sp[280] * sp[1798];
    sp[1802] = sp[281] * sp[1798];
    sp[1803] = sp[282] * sp[1798];
    sp[1804] = sp[283] * sp[1798];
    sp[1805] = sp[284] * sp[1798];
    sp[1806] = sp[285] * sp[1798];
    sp[1807] = sp[286] * sp[1798];
    sp[1808] = sp[287] * sp[1798];
    sp[1809] = sp[288] * sp[1798];
    sp[1810] = sp[289] * sp[1798];
    sp[1811] = sp[290] * sp[1798];
    sp[1812] = sp[291] * sp[1798];
    sp[1813] = sp[292] * sp[1798];
    sp[1814] = sp[293] * sp[1798];
    sp[1815] = sp[294] * sp[1798];
    sp[1816] = sp[1799] + sp[1779];
    sp[1817] = sp[1800] + sp[1780];
    sp[1818] = sp[1801] + sp[1781];
    sp[1819] = sp[1802] + sp[1782];
    sp[1820] = sp[1803] + sp[1783];
    sp[1821] = sp[1804] + sp[1784];
    sp[1822] = sp[1805] + sp[1785];
    sp[1823] = sp[1806] + sp[1786];
    sp[1824] = sp[1807] + sp[1787];
    sp[1825] = sp[1808] + sp[1788];
    sp[1826] = sp[1809] + sp[1789];
    sp[1827] = sp[1810] + sp[1790];
    sp[1828] = sp[1811] + sp[1791];
    sp[1829] = sp[1812] + sp[1792];
    sp[1830] = sp[1793] + sp[1813];
    sp[1831] = sp[1814] + sp[1794];
    sp[1832] = sp[1815] + sp[1795];
    sp[1833] = sp[318] * sp[1798];
    sp[1834] = w[0][4] + w[2][0];
    sp[1835] = sp[1833] / sp[1834];
    sp[1836] = sp[1820] + -1 * sp[1835];
    sp[1837] = sp[1816] / sp[1834];
    sp[1838] = sp[1817] / sp[1834];
    sp[1839] = sp[1818] / sp[1834];
    sp[1840] = sp[1819] / sp[1834];
    sp[1841] = sp[1836] / sp[1834];
    sp[1842] = sp[1821] / sp[1834];
    sp[1843] = sp[1822] / sp[1834];
    sp[1844] = sp[1823] / sp[1834];
    sp[1845] = sp[1824] / sp[1834];
    sp[1846] = sp[1825] / sp[1834];
    sp[1847] = sp[1826] / sp[1834];
    sp[1848] = sp[1827] / sp[1834];
    sp[1849] = sp[1828] / sp[1834];
    sp[1850] = sp[1829] / sp[1834];
    sp[1851] = sp[1830] / sp[1834];
    sp[1852] = sp[1831] / sp[1834];
    sp[1853] = sp[1832] / sp[1834];
    sp[1854] = w[7][68] * w[0][15];
    sp[1855] = w[7][69] * w[0][15];
    sp[1856] = w[7][70] * w[0][15];
    sp[1857] = w[7][71] * w[0][15];
    sp[1858] = w[7][72] * w[0][15];
    sp[1859] = w[7][73] * w[0][15];
    sp[1860] = w[7][74] * w[0][15];
    sp[1861] = w[7][75] * w[0][15];
    sp[1862] = w[7][76] * w[0][15];
    sp[1863] = w[7][77] * w[0][15];
    sp[1864] = w[7][78] * w[0][15];
    sp[1865] = w[7][79] * w[0][15];
    sp[1866] = w[7][80] * w[0][15];
    sp[1867] = w[7][81] * w[0][15];
    sp[1868] = w[7][82] * w[0][15];
    sp[1869] = w[7][83] * w[0][15];
    sp[1870] = w[7][84] * w[0][15];
    sp[1871] = w[6][4] + sp[1869];
    sp[1872] = w[9][153] + -1 * sp[1854];
    sp[1873] = w[9][154] + -1 * sp[1855];
    sp[1874] = w[9][155] + -1 * sp[1856];
    sp[1875] = w[9][156] + -1 * sp[1857];
    sp[1876] = w[9][157] + -1 * sp[1858];
    sp[1877] = w[9][158] + -1 * sp[1859];
    sp[1878] = w[9][159] + -1 * sp[1860];
    sp[1879] = w[9][160] + -1 * sp[1861];
    sp[1880] = w[9][161] + -1 * sp[1862];
    sp[1881] = w[9][162] + -1 * sp[1863];
    sp[1882] = w[9][163] + -1 * sp[1864];
    sp[1883] = w[9][164] + -1 * sp[1865];
    sp[1884] = w[9][165] + -1 * sp[1866];
    sp[1885] = w[9][166] + -1 * sp[1867];
    sp[1886] = w[9][167] + -1 * sp[1868];
    sp[1887] = w[9][168] + -1 * sp[1871];
    sp[1888] = w[9][169] + -1 * sp[1870];
    sp[1889] = sp[1872] * sp[295];
    sp[1890] = sp[1873] * sp[295];
    sp[1891] = sp[1874] * sp[295];
    sp[1892] = sp[1875] * sp[295];
    sp[1893] = sp[1876] * sp[295];
    sp[1894] = sp[1877] * sp[295];
    sp[1895] = sp[1878] * sp[295];
    sp[1896] = sp[1879] * sp[295];
    sp[1897] = sp[1880] * sp[295];
    sp[1898] = sp[1881] * sp[295];
    sp[1899] = sp[1882] * sp[295];
    sp[1900] = sp[1883] * sp[295];
    sp[1901] = sp[1884] * sp[295];
    sp[1902] = sp[1885] * sp[295];
    sp[1903] = sp[1886] * sp[295];
    sp[1904] = sp[1887] * sp[295];
    sp[1905] = sp[1888] * sp[295];
    sp[1906] = sp[318] * sp[1889];
    sp[1907] = sp[318] * sp[1890];
    sp[1908] = sp[318] * sp[1891];
    sp[1909] = sp[318] * sp[1892];
    sp[1910] = sp[318] * sp[1893];
    sp[1911] = sp[318] * sp[1894];
    sp[1912] = sp[318] * sp[1895];
    sp[1913] = sp[318] * sp[1896];
    sp[1914] = sp[318] * sp[1897];
    sp[1915] = sp[318] * sp[1898];
    sp[1916] = sp[318] * sp[1899];
    sp[1917] = sp[318] * sp[1900];
    sp[1918] = sp[318] * sp[1901];
    sp[1919] = sp[318] * sp[1902];
    sp[1920] = sp[318] * sp[1903];
    sp[1921] = sp[318] * sp[1904];
    sp[1922] = sp[318] * sp[1905];
    sp[1923] = w[6][4] * w[0][15];
    sp[1924] = w[8][9] + -1 * sp[1923];
    sp[1925] = sp[1924] * sp[295];
    sp[1926] = sp[278] * sp[1925];
    sp[1927] = sp[279] * sp[1925];
    sp[1928] = sp[280] * sp[1925];
    sp[1929] = sp[281] * sp[1925];
    sp[1930] = sp[282] * sp[1925];
    sp[1931] = sp[283] * sp[1925];
    sp[1932] = sp[284] * sp[1925];
    sp[1933] = sp[285] * sp[1925];
    sp[1934] = sp[286] * sp[1925];
    sp[1935] = sp[287] * sp[1925];
    sp[1936] = sp[288] * sp[1925];
    sp[1937] = sp[289] * sp[1925];
    sp[1938] = sp[290] * sp[1925];
    sp[1939] = sp[291] * sp[1925];
    sp[1940] = sp[292] * sp[1925];
    sp[1941] = sp[293] * sp[1925];
    sp[1942] = sp[294] * sp[1925];
    sp[1943] = sp[1926] + sp[1906];
    sp[1944] = sp[1927] + sp[1907];
    sp[1945] = sp[1928] + sp[1908];
    sp[1946] = sp[1929] + sp[1909];
    sp[1947] = sp[1930] + sp[1910];
    sp[1948] = sp[1931] + sp[1911];
    sp[1949] = sp[1932] + sp[1912];
    sp[1950] = sp[1933] + sp[1913];
    sp[1951] = sp[1934] + sp[1914];
    sp[1952] = sp[1935] + sp[1915];
    sp[1953] = sp[1936] + sp[1916];
    sp[1954] = sp[1937] + sp[1917];
    sp[1955] = sp[1938] + sp[1918];
    sp[1956] = sp[1939] + sp[1919];
    sp[1957] = sp[1940] + sp[1920];
    sp[1958] = sp[1921] + sp[1941];
    sp[1959] = sp[1942] + sp[1922];
    sp[1960] = sp[318] * sp[1925];
    sp[1961] = sp[1960] / sp[1834];
    sp[1962] = sp[1947] + -1 * sp[1961];
    sp[1963] = sp[1943] / sp[1834];
    sp[1964] = sp[1944] / sp[1834];
    sp[1965] = sp[1945] / sp[1834];
    sp[1966] = sp[1946] / sp[1834];
    sp[1967] = sp[1962] / sp[1834];
    sp[1968] = sp[1948] / sp[1834];
    sp[1969] = sp[1949] / sp[1834];
    sp[1970] = sp[1950] / sp[1834];
    sp[1971] = sp[1951] / sp[1834];
    sp[1972] = sp[1952] / sp[1834];
    sp[1973] = sp[1953] / sp[1834];
    sp[1974] = sp[1954] / sp[1834];
    sp[1975] = sp[1955] / sp[1834];
    sp[1976] = sp[1956] / sp[1834];
    sp[1977] = sp[1957] / sp[1834];
    sp[1978] = sp[1958] / sp[1834];
    sp[1979] = sp[1959] / sp[1834];
    sp[1980] = w[7][85] * w[0][16];
    sp[1981] = w[7][86] * w[0][16];
    sp[1982] = w[7][87] * w[0][16];
    sp[1983] = w[7][88] * w[0][16];
    sp[1984] = w[7][89] * w[0][16];
    sp[1985] = w[7][90] * w[0][16];
    sp[1986] = w[7][91] * w[0][16];
    sp[1987] = w[7][92] * w[0][16];
    sp[1988] = w[7][93] * w[0][16];
    sp[1989] = w[7][94] * w[0][16];
    sp[1990] = w[7][95] * w[0][16];
    sp[1991] = w[7][96] * w[0][16];
    sp[1992] = w[7][97] * w[0][16];
    sp[1993] = w[7][98] * w[0][16];
    sp[1994] = w[7][99] * w[0][16];
    sp[1995] = w[7][100] * w[0][16];
    sp[1996] = w[7][101] * w[0][16];
    sp[1997] = w[6][5] + sp[1996];
    sp[1998] = w[9][170] + -1 * sp[1980];
    sp[1999] = w[9][171] + -1 * sp[1981];
    sp[2000] = w[9][172] + -1 * sp[1982];
    sp[2001] = w[9][173] + -1 * sp[1983];
    sp[2002] = w[9][174] + -1 * sp[1984];
    sp[2003] = w[9][175] + -1 * sp[1985];
    sp[2004] = w[9][176] + -1 * sp[1986];
    sp[2005] = w[9][177] + -1 * sp[1987];
    sp[2006] = w[9][178] + -1 * sp[1988];
    sp[2007] = w[9][179] + -1 * sp[1989];
    sp[2008] = w[9][180] + -1 * sp[1990];
    sp[2009] = w[9][181] + -1 * sp[1991];
    sp[2010] = w[9][182] + -1 * sp[1992];
    sp[2011] = w[9][183] + -1 * sp[1993];
    sp[2012] = w[9][184] + -1 * sp[1994];
    sp[2013] = w[9][185] + -1 * sp[1995];
    sp[2014] = w[9][186] + -1 * sp[1997];
    sp[2015] = sp[1998] * sp[295];
    sp[2016] = sp[1999] * sp[295];
    sp[2017] = sp[2000] * sp[295];
    sp[2018] = sp[2001] * sp[295];
    sp[2019] = sp[2002] * sp[295];
    sp[2020] = sp[2003] * sp[295];
    sp[2021] = sp[2004] * sp[295];
    sp[2022] = sp[2005] * sp[295];
    sp[2023] = sp[2006] * sp[295];
    sp[2024] = sp[2007] * sp[295];
    sp[2025] = sp[2008] * sp[295];
    sp[2026] = sp[2009] * sp[295];
    sp[2027] = sp[2010] * sp[295];
    sp[2028] = sp[2011] * sp[295];
    sp[2029] = sp[2012] * sp[295];
    sp[2030] = sp[2013] * sp[295];
    sp[2031] = sp[2014] * sp[295];
    sp[2032] = sp[318] * sp[2015];
    sp[2033] = sp[318] * sp[2016];
    sp[2034] = sp[318] * sp[2017];
    sp[2035] = sp[318] * sp[2018];
    sp[2036] = sp[318] * sp[2019];
    sp[2037] = sp[318] * sp[2020];
    sp[2038] = sp[318] * sp[2021];
    sp[2039] = sp[318] * sp[2022];
    sp[2040] = sp[318] * sp[2023];
    sp[2041] = sp[318] * sp[2024];
    sp[2042] = sp[318] * sp[2025];
    sp[2043] = sp[318] * sp[2026];
    sp[2044] = sp[318] * sp[2027];
    sp[2045] = sp[318] * sp[2028];
    sp[2046] = sp[318] * sp[2029];
    sp[2047] = sp[318] * sp[2030];
    sp[2048] = sp[318] * sp[2031];
    sp[2049] = w[6][5] * w[0][16];
    sp[2050] = w[8][10] + -1 * sp[2049];
    sp[2051] = sp[2050] * sp[295];
    sp[2052] = sp[278] * sp[2051];
    sp[2053] = sp[279] * sp[2051];
    sp[2054] = sp[280] * sp[2051];
    sp[2055] = sp[281] * sp[2051];
    sp[2056] = sp[282] * sp[2051];
    sp[2057] = sp[283] * sp[2051];
    sp[2058] = sp[284] * sp[2051];
    sp[2059] = sp[285] * sp[2051];
    sp[2060] = sp[286] * sp[2051];
    sp[2061] = sp[287] * sp[2051];
    sp[2062] = sp[288] * sp[2051];
    sp[2063] = sp[289] * sp[2051];
    sp[2064] = sp[290] * sp[2051];
    sp[2065] = sp[291] * sp[2051];
    sp[2066] = sp[292] * sp[2051];
    sp[2067] = sp[293] * sp[2051];
    sp[2068] = sp[294] * sp[2051];
    sp[2069] = sp[2052] + sp[2032];
    sp[2070] = sp[2053] + sp[2033];
    sp[2071] = sp[2054] + sp[2034];
    sp[2072] = sp[2055] + sp[2035];
    sp[2073] = sp[2056] + sp[2036];
    sp[2074] = sp[2057] + sp[2037];
    sp[2075] = sp[2058] + sp[2038];
    sp[2076] = sp[2059] + sp[2039];
    sp[2077] = sp[2060] + sp[2040];
    sp[2078] = sp[2061] + sp[2041];
    sp[2079] = sp[2062] + sp[2042];
    sp[2080] = sp[2063] + sp[2043];
    sp[2081] = sp[2064] + sp[2044];
    sp[2082] = sp[2065] + sp[2045];
    sp[2083] = sp[2066] + sp[2046];
    sp[2084] = sp[2067] + sp[2047];
    sp[2085] = sp[2048] + sp[2068];
    sp[2086] = sp[318] * sp[2051];
    sp[2087] = w[0][5] + w[2][0];
    sp[2088] = sp[2086] / sp[2087];
    sp[2089] = sp[2074] + -1 * sp[2088];
    sp[2090] = sp[2069] / sp[2087];
    sp[2091] = sp[2070] / sp[2087];
    sp[2092] = sp[2071] / sp[2087];
    sp[2093] = sp[2072] / sp[2087];
    sp[2094] = sp[2073] / sp[2087];
    sp[2095] = sp[2089] / sp[2087];
    sp[2096] = sp[2075] / sp[2087];
    sp[2097] = sp[2076] / sp[2087];
    sp[2098] = sp[2077] / sp[2087];
    sp[2099] = sp[2078] / sp[2087];
    sp[2100] = sp[2079] / sp[2087];
    sp[2101] = sp[2080] / sp[2087];
    sp[2102] = sp[2081] / sp[2087];
    sp[2103] = sp[2082] / sp[2087];
    sp[2104] = sp[2083] / sp[2087];
    sp[2105] = sp[2084] / sp[2087];
    sp[2106] = sp[2085] / sp[2087];
    sp[2107] = std::abs(J_c0);
    sp[2108] = sp[353] * sp[2107];
    sp[2109] = sp[422] * sp[2107];
    sp[2110] = sp[491] * sp[2107];
    sp[2111] = sp[560] * sp[2107];
    sp[2112] = sp[629] * sp[2107];
    sp[2113] = sp[698] * sp[2107];
    sp[2114] = sp[825] * sp[2107];
    sp[2115] = sp[951] * sp[2107];
    sp[2116] = sp[1078] * sp[2107];
    sp[2117] = sp[1204] * sp[2107];
    sp[2118] = sp[1331] * sp[2107];
    sp[2119] = sp[1457] * sp[2107];
    sp[2120] = sp[1584] * sp[2107];
    sp[2121] = sp[1710] * sp[2107];
    sp[2122] = sp[1837] * sp[2107];
    sp[2123] = sp[1963] * sp[2107];
    sp[2124] = sp[2090] * sp[2107];
    sp[2125] = sp[354] * sp[2107];
    sp[2126] = sp[423] * sp[2107];
    sp[2127] = sp[492] * sp[2107];
    sp[2128] = sp[561] * sp[2107];
    sp[2129] = sp[630] * sp[2107];
    sp[2130] = sp[699] * sp[2107];
    sp[2131] = sp[826] * sp[2107];
    sp[2132] = sp[952] * sp[2107];
    sp[2133] = sp[1079] * sp[2107];
    sp[2134] = sp[1205] * sp[2107];
    sp[2135] = sp[1332] * sp[2107];
    sp[2136] = sp[1458] * sp[2107];
    sp[2137] = sp[1585] * sp[2107];
    sp[2138] = sp[1711] * sp[2107];
    sp[2139] = sp[1838] * sp[2107];
    sp[2140] = sp[1964] * sp[2107];
    sp[2141] = sp[2091] * sp[2107];
    sp[2142] = sp[355] * sp[2107];
    sp[2143] = sp[424] * sp[2107];
    sp[2144] = sp[493] * sp[2107];
    sp[2145] = sp[562] * sp[2107];
    sp[2146] = sp[631] * sp[2107];
    sp[2147] = sp[700] * sp[2107];
    sp[2148] = sp[827] * sp[2107];
    sp[2149] = sp[953] * sp[2107];
    sp[2150] = sp[1080] * sp[2107];
    sp[2151] = sp[1206] * sp[2107];
    sp[2152] = sp[1333] * sp[2107];
    sp[2153] = sp[1459] * sp[2107];
    sp[2154] = sp[1586] * sp[2107];
    sp[2155] = sp[1712] * sp[2107];
    sp[2156] = sp[1839] * sp[2107];
    sp[2157] = sp[1965] * sp[2107];
    sp[2158] = sp[2092] * sp[2107];
    sp[2159] = sp[356] * sp[2107];
    sp[2160] = sp[425] * sp[2107];
    sp[2161] = sp[494] * sp[2107];
    sp[2162] = sp[563] * sp[2107];
    sp[2163] = sp[632] * sp[2107];
    sp[2164] = sp[701] * sp[2107];
    sp[2165] = sp[828] * sp[2107];
    sp[2166] = sp[954] * sp[2107];
    sp[2167] = sp[1081] * sp[2107];
    sp[2168] = sp[1207] * sp[2107];
    sp[2169] = sp[1334] * sp[2107];
    sp[2170] = sp[1460] * sp[2107];
    sp[2171] = sp[1587] * sp[2107];
    sp[2172] = sp[1713] * sp[2107];
    sp[2173] = sp[1840] * sp[2107];
    sp[2174] = sp[1966] * sp[2107];
    sp[2175] = sp[2093] * sp[2107];
    sp[2176] = sp[357] * sp[2107];
    sp[2177] = sp[426] * sp[2107];
    sp[2178] = sp[495] * sp[2107];
    sp[2179] = sp[564] * sp[2107];
    sp[2180] = sp[633] * sp[2107];
    sp[2181] = sp[702] * sp[2107];
    sp[2182] = sp[829] * sp[2107];
    sp[2183] = sp[955] * sp[2107];
    sp[2184] = sp[1082] * sp[2107];
    sp[2185] = sp[1208] * sp[2107];
    sp[2186] = sp[1335] * sp[2107];
    sp[2187] = sp[1461] * sp[2107];
    sp[2188] = sp[1588] * sp[2107];
    sp[2189] = sp[1714] * sp[2107];
    sp[2190] = sp[1841] * sp[2107];
    sp[2191] = sp[1967] * sp[2107];
    sp[2192] = sp[2094] * sp[2107];
    sp[2193] = sp[358] * sp[2107];
    sp[2194] = sp[427] * sp[2107];
    sp[2195] = sp[496] * sp[2107];
    sp[2196] = sp[565] * sp[2107];
    sp[2197] = sp[634] * sp[2107];
    sp[2198] = sp[703] * sp[2107];
    sp[2199] = sp[830] * sp[2107];
    sp[2200] = sp[956] * sp[2107];
    sp[2201] = sp[1083] * sp[2107];
    sp[2202] = sp[1209] * sp[2107];
    sp[2203] = sp[1336] * sp[2107];
    sp[2204] = sp[1462] * sp[2107];
    sp[2205] = sp[1589] * sp[2107];
    sp[2206] = sp[1715] * sp[2107];
    sp[2207] = sp[1842] * sp[2107];
    sp[2208] = sp[1968] * sp[2107];
    sp[2209] = sp[2095] * sp[2107];
    sp[2210] = sp[359] * sp[2107];
    sp[2211] = sp[428] * sp[2107];
    sp[2212] = sp[497] * sp[2107];
    sp[2213] = sp[566] * sp[2107];
    sp[2214] = sp[635] * sp[2107];
    sp[2215] = sp[704] * sp[2107];
    sp[2216] = sp[831] * sp[2107];
    sp[2217] = sp[957] * sp[2107];
    sp[2218] = sp[1084] * sp[2107];
    sp[2219] = sp[1210] * sp[2107];
    sp[2220] = sp[1337] * sp[2107];
    sp[2221] = sp[1463] * sp[2107];
    sp[2222] = sp[1590] * sp[2107];
    sp[2223] = sp[1716] * sp[2107];
    sp[2224] = sp[1843] * sp[2107];
    sp[2225] = sp[1969] * sp[2107];
    sp[2226] = sp[2096] * sp[2107];
    sp[2227] = sp[360] * sp[2107];
    sp[2228] = sp[429] * sp[2107];
    sp[2229] = sp[498] * sp[2107];
    sp[2230] = sp[567] * sp[2107];
    sp[2231] = sp[636] * sp[2107];
    sp[2232] = sp[705] * sp[2107];
    sp[2233] = sp[832] * sp[2107];
    sp[2234] = sp[958] * sp[2107];
    sp[2235] = sp[1085] * sp[2107];
    sp[2236] = sp[1211] * sp[2107];
    sp[2237] = sp[1338] * sp[2107];
    sp[2238] = sp[1464] * sp[2107];
    sp[2239] = sp[1591] * sp[2107];
    sp[2240] = sp[1717] * sp[2107];
    sp[2241] = sp[1844] * sp[2107];
    sp[2242] = sp[1970] * sp[2107];
    sp[2243] = sp[2097] * sp[2107];
    sp[2244] = sp[361] * sp[2107];
    sp[2245] = sp[430] * sp[2107];
    sp[2246] = sp[499] * sp[2107];
    sp[2247] = sp[568] * sp[2107];
    sp[2248] = sp[637] * sp[2107];
    sp[2249] = sp[706] * sp[2107];
    sp[2250] = sp[833] * sp[2107];
    sp[2251] = sp[959] * sp[2107];
    sp[2252] = sp[1086] * sp[2107];
    sp[2253] = sp[1212] * sp[2107];
    sp[2254] = sp[1339] * sp[2107];
    sp[2255] = sp[1465] * sp[2107];
    sp[2256] = sp[1592] * sp[2107];
    sp[2257] = sp[1718] * sp[2107];
    sp[2258] = sp[1845] * sp[2107];
    sp[2259] = sp[1971] * sp[2107];
    sp[2260] = sp[2098] * sp[2107];
    sp[2261] = sp[362] * sp[2107];
    sp[2262] = sp[431] * sp[2107];
    sp[2263] = sp[500] * sp[2107];
    sp[2264] = sp[569] * sp[2107];
    sp[2265] = sp[638] * sp[2107];
    sp[2266] = sp[707] * sp[2107];
    sp[2267] = sp[834] * sp[2107];
    sp[2268] = sp[960] * sp[2107];
    sp[2269] = sp[1087] * sp[2107];
    sp[2270] = sp[1213] * sp[2107];
    sp[2271] = sp[1340] * sp[2107];
    sp[2272] = sp[1466] * sp[2107];
    sp[2273] = sp[1593] * sp[2107];
    sp[2274] = sp[1719] * sp[2107];
    sp[2275] = sp[1846] * sp[2107];
    sp[2276] = sp[1972] * sp[2107];
    sp[2277] = sp[2099] * sp[2107];
    sp[2278] = sp[363] * sp[2107];
    sp[2279] = sp[432] * sp[2107];
    sp[2280] = sp[501] * sp[2107];
    sp[2281] = sp[570] * sp[2107];
    sp[2282] = sp[639] * sp[2107];
    sp[2283] = sp[708] * sp[2107];
    sp[2284] = sp[835] * sp[2107];
    sp[2285] = sp[961] * sp[2107];
    sp[2286] = sp[1088] * sp[2107];
    sp[2287] = sp[1214] * sp[2107];
    sp[2288] = sp[1341] * sp[2107];
    sp[2289] = sp[1467] * sp[2107];
    sp[2290] = sp[1594] * sp[2107];
    sp[2291] = sp[1720] * sp[2107];
    sp[2292] = sp[1847] * sp[2107];
    sp[2293] = sp[1973] * sp[2107];
    sp[2294] = sp[2100] * sp[2107];
    sp[2295] = sp[364] * sp[2107];
    sp[2296] = sp[433] * sp[2107];
    sp[2297] = sp[502] * sp[2107];
    sp[2298] = sp[571] * sp[2107];
    sp[2299] = sp[640] * sp[2107];
    sp[2300] = sp[709] * sp[2107];
    sp[2301] = sp[836] * sp[2107];
    sp[2302] = sp[962] * sp[2107];
    sp[2303] = sp[1089] * sp[2107];
    sp[2304] = sp[1215] * sp[2107];
    sp[2305] = sp[1342] * sp[2107];
    sp[2306] = sp[1468] * sp[2107];
    sp[2307] = sp[1595] * sp[2107];
    sp[2308] = sp[1721] * sp[2107];
    sp[2309] = sp[1848] * sp[2107];
    sp[2310] = sp[1974] * sp[2107];
    sp[2311] = sp[2101] * sp[2107];
    sp[2312] = sp[365] * sp[2107];
    sp[2313] = sp[434] * sp[2107];
    sp[2314] = sp[503] * sp[2107];
    sp[2315] = sp[572] * sp[2107];
    sp[2316] = sp[641] * sp[2107];
    sp[2317] = sp[710] * sp[2107];
    sp[2318] = sp[837] * sp[2107];
    sp[2319] = sp[963] * sp[2107];
    sp[2320] = sp[1090] * sp[2107];
    sp[2321] = sp[1216] * sp[2107];
    sp[2322] = sp[1343] * sp[2107];
    sp[2323] = sp[1469] * sp[2107];
    sp[2324] = sp[1596] * sp[2107];
    sp[2325] = sp[1722] * sp[2107];
    sp[2326] = sp[1849] * sp[2107];
    sp[2327] = sp[1975] * sp[2107];
    sp[2328] = sp[2102] * sp[2107];
    sp[2329] = sp[366] * sp[2107];
    sp[2330] = sp[435] * sp[2107];
    sp[2331] = sp[504] * sp[2107];
    sp[2332] = sp[573] * sp[2107];
    sp[2333] = sp[642] * sp[2107];
    sp[2334] = sp[711] * sp[2107];
    sp[2335] = sp[838] * sp[2107];
    sp[2336] = sp[964] * sp[2107];
    sp[2337] = sp[1091] * sp[2107];
    sp[2338] = sp[1217] * sp[2107];
    sp[2339] = sp[1344] * sp[2107];
    sp[2340] = sp[1470] * sp[2107];
    sp[2341] = sp[1597] * sp[2107];
    sp[2342] = sp[1723] * sp[2107];
    sp[2343] = sp[1850] * sp[2107];
    sp[2344] = sp[1976] * sp[2107];
    sp[2345] = sp[2103] * sp[2107];
    sp[2346] = sp[367] * sp[2107];
    sp[2347] = sp[436] * sp[2107];
    sp[2348] = sp[505] * sp[2107];
    sp[2349] = sp[574] * sp[2107];
    sp[2350] = sp[643] * sp[2107];
    sp[2351] = sp[712] * sp[2107];
    sp[2352] = sp[839] * sp[2107];
    sp[2353] = sp[965] * sp[2107];
    sp[2354] = sp[1092] * sp[2107];
    sp[2355] = sp[1218] * sp[2107];
    sp[2356] = sp[1345] * sp[2107];
    sp[2357] = sp[1471] * sp[2107];
    sp[2358] = sp[1598] * sp[2107];
    sp[2359] = sp[1724] * sp[2107];
    sp[2360] = sp[1851] * sp[2107];
    sp[2361] = sp[1977] * sp[2107];
    sp[2362] = sp[2104] * sp[2107];
    sp[2363] = sp[368] * sp[2107];
    sp[2364] = sp[437] * sp[2107];
    sp[2365] = sp[506] * sp[2107];
    sp[2366] = sp[575] * sp[2107];
    sp[2367] = sp[644] * sp[2107];
    sp[2368] = sp[713] * sp[2107];
    sp[2369] = sp[840] * sp[2107];
    sp[2370] = sp[966] * sp[2107];
    sp[2371] = sp[1093] * sp[2107];
    sp[2372] = sp[1219] * sp[2107];
    sp[2373] = sp[1346] * sp[2107];
    sp[2374] = sp[1472] * sp[2107];
    sp[2375] = sp[1599] * sp[2107];
    sp[2376] = sp[1725] * sp[2107];
    sp[2377] = sp[1852] * sp[2107];
    sp[2378] = sp[1978] * sp[2107];
    sp[2379] = sp[2105] * sp[2107];
    sp[2380] = sp[369] * sp[2107];
    sp[2381] = sp[438] * sp[2107];
    sp[2382] = sp[507] * sp[2107];
    sp[2383] = sp[576] * sp[2107];
    sp[2384] = sp[645] * sp[2107];
    sp[2385] = sp[714] * sp[2107];
    sp[2386] = sp[841] * sp[2107];
    sp[2387] = sp[967] * sp[2107];
    sp[2388] = sp[1094] * sp[2107];
    sp[2389] = sp[1220] * sp[2107];
    sp[2390] = sp[1347] * sp[2107];
    sp[2391] = sp[1473] * sp[2107];
    sp[2392] = sp[1600] * sp[2107];
    sp[2393] = sp[1726] * sp[2107];
    sp[2394] = sp[1853] * sp[2107];
    sp[2395] = sp[1979] * sp[2107];
    sp[2396] = sp[2106] * sp[2107];
    A[0] = sp[2108];
    A[1] = sp[2125];
    A[2] = sp[2142];
    A[3] = sp[2159];
    A[4] = sp[2176];
    A[5] = sp[2193];
    A[6] = sp[2210];
    A[7] = sp[2227];
    A[8] = sp[2244];
    A[9] = sp[2261];
    A[10] = sp[2278];
    A[11] = sp[2295];
    A[12] = sp[2312];
    A[13] = sp[2329];
    A[14] = sp[2346];
    A[15] = sp[2363];
    A[16] = sp[2380];
    A[17] = sp[2109];
    A[18] = sp[2126];
    A[19] = sp[2143];
    A[20] = sp[2160];
    A[21] = sp[2177];
    A[22] = sp[2194];
    A[23] = sp[2211];
    A[24] = sp[2228];
    A[25] = sp[2245];
    A[26] = sp[2262];
    A[27] = sp[2279];
    A[28] = sp[2296];
    A[29] = sp[2313];
    A[30] = sp[2330];
    A[31] = sp[2347];
    A[32] = sp[2364];
    A[33] = sp[2381];
    A[34] = sp[2110];
    A[35] = sp[2127];
    A[36] = sp[2144];
    A[37] = sp[2161];
    A[38] = sp[2178];
    A[39] = sp[2195];
    A[40] = sp[2212];
    A[41] = sp[2229];
    A[42] = sp[2246];
    A[43] = sp[2263];
    A[44] = sp[2280];
    A[45] = sp[2297];
    A[46] = sp[2314];
    A[47] = sp[2331];
    A[48] = sp[2348];
    A[49] = sp[2365];
    A[50] = sp[2382];
    A[51] = sp[2111];
    A[52] = sp[2128];
    A[53] = sp[2145];
    A[54] = sp[2162];
    A[55] = sp[2179];
    A[56] = sp[2196];
    A[57] = sp[2213];
    A[58] = sp[2230];
    A[59] = sp[2247];
    A[60] = sp[2264];
    A[61] = sp[2281];
    A[62] = sp[2298];
    A[63] = sp[2315];
    A[64] = sp[2332];
    A[65] = sp[2349];
    A[66] = sp[2366];
    A[67] = sp[2383];
    A[68] = sp[2112];
    A[69] = sp[2129];
    A[70] = sp[2146];
    A[71] = sp[2163];
    A[72] = sp[2180];
    A[73] = sp[2197];
    A[74] = sp[2214];
    A[75] = sp[2231];
    A[76] = sp[2248];
    A[77] = sp[2265];
    A[78] = sp[2282];
    A[79] = sp[2299];
    A[80] = sp[2316];
    A[81] = sp[2333];
    A[82] = sp[2350];
    A[83] = sp[2367];
    A[84] = sp[2384];
    A[85] = sp[2113];
    A[86] = sp[2130];
    A[87] = sp[2147];
    A[88] = sp[2164];
    A[89] = sp[2181];
    A[90] = sp[2198];
    A[91] = sp[2215];
    A[92] = sp[2232];
    A[93] = sp[2249];
    A[94] = sp[2266];
    A[95] = sp[2283];
    A[96] = sp[2300];
    A[97] = sp[2317];
    A[98] = sp[2334];
    A[99] = sp[2351];
    A[100] = sp[2368];
    A[101] = sp[2385];
    A[102] = sp[2114];
    A[103] = sp[2131];
    A[104] = sp[2148];
    A[105] = sp[2165];
    A[106] = sp[2182];
    A[107] = sp[2199];
    A[108] = sp[2216];
    A[109] = sp[2233];
    A[110] = sp[2250];
    A[111] = sp[2267];
    A[112] = sp[2284];
    A[113] = sp[2301];
    A[114] = sp[2318];
    A[115] = sp[2335];
    A[116] = sp[2352];
    A[117] = sp[2369];
    A[118] = sp[2386];
    A[119] = sp[2115];
    A[120] = sp[2132];
    A[121] = sp[2149];
    A[122] = sp[2166];
    A[123] = sp[2183];
    A[124] = sp[2200];
    A[125] = sp[2217];
    A[126] = sp[2234];
    A[127] = sp[2251];
    A[128] = sp[2268];
    A[129] = sp[2285];
    A[130] = sp[2302];
    A[131] = sp[2319];
    A[132] = sp[2336];
    A[133] = sp[2353];
    A[134] = sp[2370];
    A[135] = sp[2387];
    A[136] = sp[2116];
    A[137] = sp[2133];
    A[138] = sp[2150];
    A[139] = sp[2167];
    A[140] = sp[2184];
    A[141] = sp[2201];
    A[142] = sp[2218];
    A[143] = sp[2235];
    A[144] = sp[2252];
    A[145] = sp[2269];
    A[146] = sp[2286];
    A[147] = sp[2303];
    A[148] = sp[2320];
    A[149] = sp[2337];
    A[150] = sp[2354];
    A[151] = sp[2371];
    A[152] = sp[2388];
    A[153] = sp[2117];
    A[154] = sp[2134];
    A[155] = sp[2151];
    A[156] = sp[2168];
    A[157] = sp[2185];
    A[158] = sp[2202];
    A[159] = sp[2219];
    A[160] = sp[2236];
    A[161] = sp[2253];
    A[162] = sp[2270];
    A[163] = sp[2287];
    A[164] = sp[2304];
    A[165] = sp[2321];
    A[166] = sp[2338];
    A[167] = sp[2355];
    A[168] = sp[2372];
    A[169] = sp[2389];
    A[170] = sp[2118];
    A[171] = sp[2135];
    A[172] = sp[2152];
    A[173] = sp[2169];
    A[174] = sp[2186];
    A[175] = sp[2203];
    A[176] = sp[2220];
    A[177] = sp[2237];
    A[178] = sp[2254];
    A[179] = sp[2271];
    A[180] = sp[2288];
    A[181] = sp[2305];
    A[182] = sp[2322];
    A[183] = sp[2339];
    A[184] = sp[2356];
    A[185] = sp[2373];
    A[186] = sp[2390];
    A[187] = sp[2119];
    A[188] = sp[2136];
    A[189] = sp[2153];
    A[190] = sp[2170];
    A[191] = sp[2187];
    A[192] = sp[2204];
    A[193] = sp[2221];
    A[194] = sp[2238];
    A[195] = sp[2255];
    A[196] = sp[2272];
    A[197] = sp[2289];
    A[198] = sp[2306];
    A[199] = sp[2323];
    A[200] = sp[2340];
    A[201] = sp[2357];
    A[202] = sp[2374];
    A[203] = sp[2391];
    A[204] = sp[2120];
    A[205] = sp[2137];
    A[206] = sp[2154];
    A[207] = sp[2171];
    A[208] = sp[2188];
    A[209] = sp[2205];
    A[210] = sp[2222];
    A[211] = sp[2239];
    A[212] = sp[2256];
    A[213] = sp[2273];
    A[214] = sp[2290];
    A[215] = sp[2307];
    A[216] = sp[2324];
    A[217] = sp[2341];
    A[218] = sp[2358];
    A[219] = sp[2375];
    A[220] = sp[2392];
    A[221] = sp[2121];
    A[222] = sp[2138];
    A[223] = sp[2155];
    A[224] = sp[2172];
    A[225] = sp[2189];
    A[226] = sp[2206];
    A[227] = sp[2223];
    A[228] = sp[2240];
    A[229] = sp[2257];
    A[230] = sp[2274];
    A[231] = sp[2291];
    A[232] = sp[2308];
    A[233] = sp[2325];
    A[234] = sp[2342];
    A[235] = sp[2359];
    A[236] = sp[2376];
    A[237] = sp[2393];
    A[238] = sp[2122];
    A[239] = sp[2139];
    A[240] = sp[2156];
    A[241] = sp[2173];
    A[242] = sp[2190];
    A[243] = sp[2207];
    A[244] = sp[2224];
    A[245] = sp[2241];
    A[246] = sp[2258];
    A[247] = sp[2275];
    A[248] = sp[2292];
    A[249] = sp[2309];
    A[250] = sp[2326];
    A[251] = sp[2343];
    A[252] = sp[2360];
    A[253] = sp[2377];
    A[254] = sp[2394];
    A[255] = sp[2123];
    A[256] = sp[2140];
    A[257] = sp[2157];
    A[258] = sp[2174];
    A[259] = sp[2191];
    A[260] = sp[2208];
    A[261] = sp[2225];
    A[262] = sp[2242];
    A[263] = sp[2259];
    A[264] = sp[2276];
    A[265] = sp[2293];
    A[266] = sp[2310];
    A[267] = sp[2327];
    A[268] = sp[2344];
    A[269] = sp[2361];
    A[270] = sp[2378];
    A[271] = sp[2395];
    A[272] = sp[2124];
    A[273] = sp[2141];
    A[274] = sp[2158];
    A[275] = sp[2175];
    A[276] = sp[2192];
    A[277] = sp[2209];
    A[278] = sp[2226];
    A[279] = sp[2243];
    A[280] = sp[2260];
    A[281] = sp[2277];
    A[282] = sp[2294];
    A[283] = sp[2311];
    A[284] = sp[2328];
    A[285] = sp[2345];
    A[286] = sp[2362];
    A[287] = sp[2379];
    A[288] = sp[2396];
  }

};


class phasediagramts_form_0: public ufc::form
{
public:

  phasediagramts_form_0() : ufc::form()
  {
    // Do nothing
  }

  ~phasediagramts_form_0() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "8fc188d803984c11b2cfd408094e158074494f0528d759a08bb49ad9ac40d4bdda0d04849996180c73f3fac2512a90c55ae2489afac6072dddf39fc3abd3ec01";
  }

  std::size_t rank() const final override
  {
    return 1;
  }

  std::size_t num_coefficients() const final override
  {
    return 1;
  }

  std::size_t original_coefficient_position(std::size_t i) const final override
  {
    if (i >= 1)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0};
    return position[i];
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new phasediagramts_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new phasediagramts_dofmap_1();
   }

  ufc::coordinate_mapping * create_coordinate_mapping() const final override
  {
    return new phasediagramts_coordinate_mapping_1();
  }

  ufc::finite_element * create_finite_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_finite_element_9();
    case 1:
        return new phasediagramts_finite_element_9();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_dofmap_9();
    case 1:
        return new phasediagramts_dofmap_9();
    default:
        return nullptr;
    }
  }

  std::size_t max_cell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_exterior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_vertex_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_custom_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_cutcell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interface_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_overlap_subdomain_id() const final override
  {
    return 0;
  }

  bool has_cell_integrals() const final override
  {
    return true;
  }

  bool has_exterior_facet_integrals() const final override
  {
    return false;
  }

  bool has_interior_facet_integrals() const final override
  {
    return false;
  }

  bool has_vertex_integrals() const final override
  {
    return false;
  }

  bool has_custom_integrals() const final override
  {
    return false;
  }

  bool has_cutcell_integrals() const final override
  {
    return false;
  }

  bool has_interface_integrals() const final override
  {
    return false;
  }

  bool has_overlap_integrals() const final override
  {
    return false;
  }

  ufc::cell_integral * create_cell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::exterior_facet_integral * create_exterior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_interior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_vertex_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_custom_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_cutcell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_interface_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_overlap_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cell_integral * create_default_cell_integral() const final override
  {
    return new phasediagramts_cell_integral_0_otherwise();
  }

  ufc::exterior_facet_integral * create_default_exterior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_default_interior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_default_vertex_integral() const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_default_custom_integral() const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_default_cutcell_integral() const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_default_interface_integral() const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_default_overlap_integral() const final override
  {
    return nullptr;
  }

};


class phasediagramts_form_1: public ufc::form
{
public:

  phasediagramts_form_1() : ufc::form()
  {
    // Do nothing
  }

  ~phasediagramts_form_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "31b3ae4058c82168c6d9ac0632ddc1ef688e92b8bf0d3b1b073c565aca1b4aa284ba50c34e5107ea1fb1d16f585a3fb1f18f5f4afbdb063e1fef2c0c54155414";
  }

  std::size_t rank() const final override
  {
    return 1;
  }

  std::size_t num_coefficients() const final override
  {
    return 7;
  }

  std::size_t original_coefficient_position(std::size_t i) const final override
  {
    if (i >= 7)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2, 3, 4, 5, 6};
    return position[i];
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new phasediagramts_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new phasediagramts_dofmap_1();
   }

  ufc::coordinate_mapping * create_coordinate_mapping() const final override
  {
    return new phasediagramts_coordinate_mapping_1();
  }

  ufc::finite_element * create_finite_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_finite_element_9();
    case 1:
        return new phasediagramts_finite_element_9();
    case 2:
        return new phasediagramts_finite_element_10();
    case 3:
        return new phasediagramts_finite_element_10();
    case 4:
        return new phasediagramts_finite_element_10();
    case 5:
        return new phasediagramts_finite_element_3();
    case 6:
        return new phasediagramts_finite_element_3();
    case 7:
        return new phasediagramts_finite_element_4();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_dofmap_9();
    case 1:
        return new phasediagramts_dofmap_9();
    case 2:
        return new phasediagramts_dofmap_10();
    case 3:
        return new phasediagramts_dofmap_10();
    case 4:
        return new phasediagramts_dofmap_10();
    case 5:
        return new phasediagramts_dofmap_3();
    case 6:
        return new phasediagramts_dofmap_3();
    case 7:
        return new phasediagramts_dofmap_4();
    default:
        return nullptr;
    }
  }

  std::size_t max_cell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_exterior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_vertex_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_custom_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_cutcell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interface_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_overlap_subdomain_id() const final override
  {
    return 0;
  }

  bool has_cell_integrals() const final override
  {
    return true;
  }

  bool has_exterior_facet_integrals() const final override
  {
    return false;
  }

  bool has_interior_facet_integrals() const final override
  {
    return false;
  }

  bool has_vertex_integrals() const final override
  {
    return false;
  }

  bool has_custom_integrals() const final override
  {
    return false;
  }

  bool has_cutcell_integrals() const final override
  {
    return false;
  }

  bool has_interface_integrals() const final override
  {
    return false;
  }

  bool has_overlap_integrals() const final override
  {
    return false;
  }

  ufc::cell_integral * create_cell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::exterior_facet_integral * create_exterior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_interior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_vertex_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_custom_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_cutcell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_interface_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_overlap_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cell_integral * create_default_cell_integral() const final override
  {
    return new phasediagramts_cell_integral_1_otherwise();
  }

  ufc::exterior_facet_integral * create_default_exterior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_default_interior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_default_vertex_integral() const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_default_custom_integral() const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_default_cutcell_integral() const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_default_interface_integral() const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_default_overlap_integral() const final override
  {
    return nullptr;
  }

};


class phasediagramts_form_2: public ufc::form
{
public:

  phasediagramts_form_2() : ufc::form()
  {
    // Do nothing
  }

  ~phasediagramts_form_2() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "015e8f943363efaef7983aed65982c3d054f3227dab939b5cf0dc7408137195aa0618c890885da943653817f819ab651c59b03952be9309f3453c7a6f1114a0c";
  }

  std::size_t rank() const final override
  {
    return 2;
  }

  std::size_t num_coefficients() const final override
  {
    return 1;
  }

  std::size_t original_coefficient_position(std::size_t i) const final override
  {
    if (i >= 1)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {2};
    return position[i];
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new phasediagramts_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new phasediagramts_dofmap_1();
   }

  ufc::coordinate_mapping * create_coordinate_mapping() const final override
  {
    return new phasediagramts_coordinate_mapping_1();
  }

  ufc::finite_element * create_finite_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_finite_element_9();
    case 1:
        return new phasediagramts_finite_element_9();
    case 2:
        return new phasediagramts_finite_element_10();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_dofmap_9();
    case 1:
        return new phasediagramts_dofmap_9();
    case 2:
        return new phasediagramts_dofmap_10();
    default:
        return nullptr;
    }
  }

  std::size_t max_cell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_exterior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_vertex_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_custom_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_cutcell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interface_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_overlap_subdomain_id() const final override
  {
    return 0;
  }

  bool has_cell_integrals() const final override
  {
    return true;
  }

  bool has_exterior_facet_integrals() const final override
  {
    return false;
  }

  bool has_interior_facet_integrals() const final override
  {
    return false;
  }

  bool has_vertex_integrals() const final override
  {
    return false;
  }

  bool has_custom_integrals() const final override
  {
    return false;
  }

  bool has_cutcell_integrals() const final override
  {
    return false;
  }

  bool has_interface_integrals() const final override
  {
    return false;
  }

  bool has_overlap_integrals() const final override
  {
    return false;
  }

  ufc::cell_integral * create_cell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::exterior_facet_integral * create_exterior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_interior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_vertex_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_custom_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_cutcell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_interface_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_overlap_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cell_integral * create_default_cell_integral() const final override
  {
    return new phasediagramts_cell_integral_2_otherwise();
  }

  ufc::exterior_facet_integral * create_default_exterior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_default_interior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_default_vertex_integral() const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_default_custom_integral() const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_default_cutcell_integral() const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_default_interface_integral() const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_default_overlap_integral() const final override
  {
    return nullptr;
  }

};


class phasediagramts_form_3: public ufc::form
{
public:

  phasediagramts_form_3() : ufc::form()
  {
    // Do nothing
  }

  ~phasediagramts_form_3() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "ca01e97f1030b852313e0ba853d90d8c87a71f679d2e030f9c0058819e5957ff14ec83e42e880c177dbfa2ecf72a18fae059741b6c3beb6a9bafceccd62ccdbe";
  }

  std::size_t rank() const final override
  {
    return 2;
  }

  std::size_t num_coefficients() const final override
  {
    return 10;
  }

  std::size_t original_coefficient_position(std::size_t i) const final override
  {
    if (i >= 10)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    return position[i];
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new phasediagramts_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new phasediagramts_dofmap_1();
   }

  ufc::coordinate_mapping * create_coordinate_mapping() const final override
  {
    return new phasediagramts_coordinate_mapping_1();
  }

  ufc::finite_element * create_finite_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_finite_element_9();
    case 1:
        return new phasediagramts_finite_element_9();
    case 2:
        return new phasediagramts_finite_element_9();
    case 3:
        return new phasediagramts_finite_element_10();
    case 4:
        return new phasediagramts_finite_element_10();
    case 5:
        return new phasediagramts_finite_element_10();
    case 6:
        return new phasediagramts_finite_element_3();
    case 7:
        return new phasediagramts_finite_element_5();
    case 8:
        return new phasediagramts_finite_element_3();
    case 9:
        return new phasediagramts_finite_element_5();
    case 10:
        return new phasediagramts_finite_element_4();
    case 11:
        return new phasediagramts_finite_element_6();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new phasediagramts_dofmap_9();
    case 1:
        return new phasediagramts_dofmap_9();
    case 2:
        return new phasediagramts_dofmap_9();
    case 3:
        return new phasediagramts_dofmap_10();
    case 4:
        return new phasediagramts_dofmap_10();
    case 5:
        return new phasediagramts_dofmap_10();
    case 6:
        return new phasediagramts_dofmap_3();
    case 7:
        return new phasediagramts_dofmap_5();
    case 8:
        return new phasediagramts_dofmap_3();
    case 9:
        return new phasediagramts_dofmap_5();
    case 10:
        return new phasediagramts_dofmap_4();
    case 11:
        return new phasediagramts_dofmap_6();
    default:
        return nullptr;
    }
  }

  std::size_t max_cell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_exterior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_vertex_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_custom_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_cutcell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interface_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_overlap_subdomain_id() const final override
  {
    return 0;
  }

  bool has_cell_integrals() const final override
  {
    return true;
  }

  bool has_exterior_facet_integrals() const final override
  {
    return false;
  }

  bool has_interior_facet_integrals() const final override
  {
    return false;
  }

  bool has_vertex_integrals() const final override
  {
    return false;
  }

  bool has_custom_integrals() const final override
  {
    return false;
  }

  bool has_cutcell_integrals() const final override
  {
    return false;
  }

  bool has_interface_integrals() const final override
  {
    return false;
  }

  bool has_overlap_integrals() const final override
  {
    return false;
  }

  ufc::cell_integral * create_cell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::exterior_facet_integral * create_exterior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_interior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_vertex_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_custom_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_cutcell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_interface_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_overlap_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cell_integral * create_default_cell_integral() const final override
  {
    return new phasediagramts_cell_integral_3_otherwise();
  }

  ufc::exterior_facet_integral * create_default_exterior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_default_interior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_default_vertex_integral() const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_default_custom_integral() const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_default_cutcell_integral() const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_default_interface_integral() const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_default_overlap_integral() const final override
  {
    return nullptr;
  }

};

// DOLFIN wrappers

// Standard library includes
#include <string>

// DOLFIN includes
#include <dolfin/common/NoDeleter.h>
#include <dolfin/mesh/Mesh.h>
#include <dolfin/mesh/MultiMesh.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/fem/MultiMeshForm.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/MultiMeshFunctionSpace.h>
#include <dolfin/function/GenericFunction.h>
#include <dolfin/function/CoefficientAssigner.h>
#include <dolfin/function/MultiMeshCoefficientAssigner.h>
#include <dolfin/adaptivity/ErrorControl.h>
#include <dolfin/adaptivity/GoalFunctional.h>
#include <dolfin/la/GenericVector.h>

namespace PhaseDiagramTS
{

class CoefficientSpace_Da: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_Da(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_10>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_10>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_Da(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_10>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_10>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_Da(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_10>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_10>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class CoefficientSpace_Gammai_i: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_Gammai_i(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_3>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_3>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_Gammai_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_3>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_3>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_Gammai_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_3>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_3>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class CoefficientSpace_Gammaik_i: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_Gammaik_i(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_4>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_4>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_Gammaik_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_4>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_4>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_Gammaik_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_4>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_4>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class CoefficientSpace_a: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_a(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_10>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_10>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_a(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_10>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_10>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_a(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_10>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_10>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class CoefficientSpace_dGammaidus_i: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_dGammaidus_i(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_5>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_5>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_dGammaidus_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_5>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_5>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_dGammaidus_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_5>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_5>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class CoefficientSpace_dGammaikdus_i: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_dGammaikdus_i(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_6>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_6>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_dGammaikdus_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_6>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_6>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_dGammaikdus_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_6>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_6>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class CoefficientSpace_drhoidus_i: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_drhoidus_i(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_5>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_5>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_drhoidus_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_5>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_5>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_drhoidus_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_5>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_5>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class CoefficientSpace_eps: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_eps(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_10>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_10>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_eps(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_10>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_10>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_eps(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_10>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_10>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class CoefficientSpace_rho0: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_rho0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_10>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_10>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_rho0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_10>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_10>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_rho0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_10>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_10>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class CoefficientSpace_rhoi_i: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_rhoi_i(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_3>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_3>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_rhoi_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_3>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_3>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_rhoi_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_3>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_3>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class CoefficientSpace_us_dot: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_us_dot(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_us_dot(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_us_dot(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class CoefficientSpace_us_i: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_us_i(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_us_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_us_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class Form_F_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_F_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_F_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_F_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class Form_F_MultiMeshFunctionSpace_0: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_F_MultiMeshFunctionSpace_0(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_F_FunctionSpace_0(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

typedef CoefficientSpace_us_dot Form_F_FunctionSpace_1;

class Form_F: public dolfin::Form
{
public:

  // Constructor
  Form_F(std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 1), us_dot(*this, 0)
  {
    _function_spaces[0] = V0;

    _ufc_form = std::make_shared<const phasediagramts_form_0>();
  }

  // Constructor
  Form_F(std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> us_dot):
    dolfin::Form(1, 1), us_dot(*this, 0)
  {
    _function_spaces[0] = V0;

    this->us_dot = us_dot;

    _ufc_form = std::make_shared<const phasediagramts_form_0>();
  }

  // Destructor
  ~Form_F()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "us_dot")
      return 0;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "us_dot";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_F_FunctionSpace_0 TestSpace;
  typedef Form_F_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_F_FunctionSpace_1 CoefficientSpace_us_dot;

  // Coefficients
  dolfin::CoefficientAssigner us_dot;
};

class MultiMeshForm_F: public dolfin::MultiMeshForm
{
public:

  // Constructor
  MultiMeshForm_F(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0):
    dolfin::MultiMeshForm(V0), us_dot(*this, 0)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_F(V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients

  }

  // Constructor
  MultiMeshForm_F(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> us_dot):
    dolfin::MultiMeshForm(V0), us_dot(*this, 0)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_F(V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients
    this->us_dot = us_dot;

  }

  // Destructor
  ~MultiMeshForm_F()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "us_dot")
      return 0;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "us_dot";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_F_FunctionSpace_0 TestSpace;
  typedef Form_F_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_F_FunctionSpace_1 CoefficientSpace_us_dot;

  // Coefficients
  dolfin::MultiMeshCoefficientAssigner us_dot;
};

class Form_G_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_G_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_G_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_G_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class Form_G_MultiMeshFunctionSpace_0: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_G_MultiMeshFunctionSpace_0(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_G_FunctionSpace_0(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

typedef CoefficientSpace_us_i Form_G_FunctionSpace_1;

typedef CoefficientSpace_Da Form_G_FunctionSpace_2;

typedef CoefficientSpace_eps Form_G_FunctionSpace_3;

typedef CoefficientSpace_rho0 Form_G_FunctionSpace_4;

typedef CoefficientSpace_rhoi_i Form_G_FunctionSpace_5;

typedef CoefficientSpace_Gammai_i Form_G_FunctionSpace_6;

typedef CoefficientSpace_Gammaik_i Form_G_FunctionSpace_7;

class Form_G: public dolfin::Form
{
public:

  // Constructor
  Form_G(std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 7), us_i(*this, 0), Da(*this, 1), eps(*this, 2), rho0(*this, 3), rhoi_i(*this, 4), Gammai_i(*this, 5), Gammaik_i(*this, 6)
  {
    _function_spaces[0] = V0;

    _ufc_form = std::make_shared<const phasediagramts_form_1>();
  }

  // Constructor
  Form_G(std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> us_i, std::shared_ptr<const dolfin::GenericFunction> Da, std::shared_ptr<const dolfin::GenericFunction> eps, std::shared_ptr<const dolfin::GenericFunction> rho0, std::shared_ptr<const dolfin::GenericFunction> rhoi_i, std::shared_ptr<const dolfin::GenericFunction> Gammai_i, std::shared_ptr<const dolfin::GenericFunction> Gammaik_i):
    dolfin::Form(1, 7), us_i(*this, 0), Da(*this, 1), eps(*this, 2), rho0(*this, 3), rhoi_i(*this, 4), Gammai_i(*this, 5), Gammaik_i(*this, 6)
  {
    _function_spaces[0] = V0;

    this->us_i = us_i;
    this->Da = Da;
    this->eps = eps;
    this->rho0 = rho0;
    this->rhoi_i = rhoi_i;
    this->Gammai_i = Gammai_i;
    this->Gammaik_i = Gammaik_i;

    _ufc_form = std::make_shared<const phasediagramts_form_1>();
  }

  // Destructor
  ~Form_G()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "us_i")
      return 0;
    else if (name == "Da")
      return 1;
    else if (name == "eps")
      return 2;
    else if (name == "rho0")
      return 3;
    else if (name == "rhoi_i")
      return 4;
    else if (name == "Gammai_i")
      return 5;
    else if (name == "Gammaik_i")
      return 6;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "us_i";
    case 1:
      return "Da";
    case 2:
      return "eps";
    case 3:
      return "rho0";
    case 4:
      return "rhoi_i";
    case 5:
      return "Gammai_i";
    case 6:
      return "Gammaik_i";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_G_FunctionSpace_0 TestSpace;
  typedef Form_G_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_G_FunctionSpace_1 CoefficientSpace_us_i;
  typedef Form_G_FunctionSpace_2 CoefficientSpace_Da;
  typedef Form_G_FunctionSpace_3 CoefficientSpace_eps;
  typedef Form_G_FunctionSpace_4 CoefficientSpace_rho0;
  typedef Form_G_FunctionSpace_5 CoefficientSpace_rhoi_i;
  typedef Form_G_FunctionSpace_6 CoefficientSpace_Gammai_i;
  typedef Form_G_FunctionSpace_7 CoefficientSpace_Gammaik_i;

  // Coefficients
  dolfin::CoefficientAssigner us_i;
  dolfin::CoefficientAssigner Da;
  dolfin::CoefficientAssigner eps;
  dolfin::CoefficientAssigner rho0;
  dolfin::CoefficientAssigner rhoi_i;
  dolfin::CoefficientAssigner Gammai_i;
  dolfin::CoefficientAssigner Gammaik_i;
};

class MultiMeshForm_G: public dolfin::MultiMeshForm
{
public:

  // Constructor
  MultiMeshForm_G(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0):
    dolfin::MultiMeshForm(V0), us_i(*this, 0), Da(*this, 1), eps(*this, 2), rho0(*this, 3), rhoi_i(*this, 4), Gammai_i(*this, 5), Gammaik_i(*this, 6)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_G(V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients

  }

  // Constructor
  MultiMeshForm_G(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> us_i, std::shared_ptr<const dolfin::GenericFunction> Da, std::shared_ptr<const dolfin::GenericFunction> eps, std::shared_ptr<const dolfin::GenericFunction> rho0, std::shared_ptr<const dolfin::GenericFunction> rhoi_i, std::shared_ptr<const dolfin::GenericFunction> Gammai_i, std::shared_ptr<const dolfin::GenericFunction> Gammaik_i):
    dolfin::MultiMeshForm(V0), us_i(*this, 0), Da(*this, 1), eps(*this, 2), rho0(*this, 3), rhoi_i(*this, 4), Gammai_i(*this, 5), Gammaik_i(*this, 6)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_G(V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients
    this->us_i = us_i;
    this->Da = Da;
    this->eps = eps;
    this->rho0 = rho0;
    this->rhoi_i = rhoi_i;
    this->Gammai_i = Gammai_i;
    this->Gammaik_i = Gammaik_i;

  }

  // Destructor
  ~MultiMeshForm_G()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "us_i")
      return 0;
    else if (name == "Da")
      return 1;
    else if (name == "eps")
      return 2;
    else if (name == "rho0")
      return 3;
    else if (name == "rhoi_i")
      return 4;
    else if (name == "Gammai_i")
      return 5;
    else if (name == "Gammaik_i")
      return 6;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "us_i";
    case 1:
      return "Da";
    case 2:
      return "eps";
    case 3:
      return "rho0";
    case 4:
      return "rhoi_i";
    case 5:
      return "Gammai_i";
    case 6:
      return "Gammaik_i";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_G_FunctionSpace_0 TestSpace;
  typedef Form_G_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_G_FunctionSpace_1 CoefficientSpace_us_i;
  typedef Form_G_FunctionSpace_2 CoefficientSpace_Da;
  typedef Form_G_FunctionSpace_3 CoefficientSpace_eps;
  typedef Form_G_FunctionSpace_4 CoefficientSpace_rho0;
  typedef Form_G_FunctionSpace_5 CoefficientSpace_rhoi_i;
  typedef Form_G_FunctionSpace_6 CoefficientSpace_Gammai_i;
  typedef Form_G_FunctionSpace_7 CoefficientSpace_Gammaik_i;

  // Coefficients
  dolfin::MultiMeshCoefficientAssigner us_i;
  dolfin::MultiMeshCoefficientAssigner Da;
  dolfin::MultiMeshCoefficientAssigner eps;
  dolfin::MultiMeshCoefficientAssigner rho0;
  dolfin::MultiMeshCoefficientAssigner rhoi_i;
  dolfin::MultiMeshCoefficientAssigner Gammai_i;
  dolfin::MultiMeshCoefficientAssigner Gammaik_i;
};

class Form_JF_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_JF_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_JF_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_JF_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class Form_JF_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_JF_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_JF_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_JF_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class Form_JF_MultiMeshFunctionSpace_0: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_JF_MultiMeshFunctionSpace_0(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_JF_FunctionSpace_0(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

class Form_JF_MultiMeshFunctionSpace_1: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_JF_MultiMeshFunctionSpace_1(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_JF_FunctionSpace_1(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

typedef CoefficientSpace_a Form_JF_FunctionSpace_2;

class Form_JF: public dolfin::Form
{
public:

  // Constructor
  Form_JF(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 1), a(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = std::make_shared<const phasediagramts_form_2>();
  }

  // Constructor
  Form_JF(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> a):
    dolfin::Form(2, 1), a(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->a = a;

    _ufc_form = std::make_shared<const phasediagramts_form_2>();
  }

  // Destructor
  ~Form_JF()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "a")
      return 0;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "a";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_JF_FunctionSpace_0 TestSpace;
  typedef Form_JF_FunctionSpace_1 TrialSpace;
  typedef Form_JF_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_JF_MultiMeshFunctionSpace_1 MultiMeshTrialSpace;
  typedef Form_JF_FunctionSpace_2 CoefficientSpace_a;

  // Coefficients
  dolfin::CoefficientAssigner a;
};

class MultiMeshForm_JF: public dolfin::MultiMeshForm
{
public:

  // Constructor
  MultiMeshForm_JF(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V1, std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0):
    dolfin::MultiMeshForm(V1, V0), a(*this, 0)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_JF(V1->part(part), V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients

  }

  // Constructor
  MultiMeshForm_JF(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V1, std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> a):
    dolfin::MultiMeshForm(V1, V0), a(*this, 0)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_JF(V1->part(part), V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients
    this->a = a;

  }

  // Destructor
  ~MultiMeshForm_JF()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "a")
      return 0;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "a";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_JF_FunctionSpace_0 TestSpace;
  typedef Form_JF_FunctionSpace_1 TrialSpace;
  typedef Form_JF_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_JF_MultiMeshFunctionSpace_1 MultiMeshTrialSpace;
  typedef Form_JF_FunctionSpace_2 CoefficientSpace_a;

  // Coefficients
  dolfin::MultiMeshCoefficientAssigner a;
};

class Form_JG_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_JG_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_JG_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_JG_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class Form_JG_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_JG_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_JG_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_JG_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<phasediagramts_finite_element_9>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<phasediagramts_dofmap_9>(), *mesh, constrained_domain, 
                          sub_domains, master_domains, slave_domains))
  {
    // Do nothing
  }

};

class Form_JG_MultiMeshFunctionSpace_0: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_JG_MultiMeshFunctionSpace_0(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_JG_FunctionSpace_0(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

class Form_JG_MultiMeshFunctionSpace_1: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_JG_MultiMeshFunctionSpace_1(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_JG_FunctionSpace_1(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

typedef CoefficientSpace_us_i Form_JG_FunctionSpace_2;

typedef CoefficientSpace_Da Form_JG_FunctionSpace_3;

typedef CoefficientSpace_eps Form_JG_FunctionSpace_4;

typedef CoefficientSpace_rho0 Form_JG_FunctionSpace_5;

typedef CoefficientSpace_rhoi_i Form_JG_FunctionSpace_6;

typedef CoefficientSpace_drhoidus_i Form_JG_FunctionSpace_7;

typedef CoefficientSpace_Gammai_i Form_JG_FunctionSpace_8;

typedef CoefficientSpace_dGammaidus_i Form_JG_FunctionSpace_9;

typedef CoefficientSpace_Gammaik_i Form_JG_FunctionSpace_10;

typedef CoefficientSpace_dGammaikdus_i Form_JG_FunctionSpace_11;

class Form_JG: public dolfin::Form
{
public:

  // Constructor
  Form_JG(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 10), us_i(*this, 0), Da(*this, 1), eps(*this, 2), rho0(*this, 3), rhoi_i(*this, 4), drhoidus_i(*this, 5), Gammai_i(*this, 6), dGammaidus_i(*this, 7), Gammaik_i(*this, 8), dGammaikdus_i(*this, 9)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = std::make_shared<const phasediagramts_form_3>();
  }

  // Constructor
  Form_JG(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> us_i, std::shared_ptr<const dolfin::GenericFunction> Da, std::shared_ptr<const dolfin::GenericFunction> eps, std::shared_ptr<const dolfin::GenericFunction> rho0, std::shared_ptr<const dolfin::GenericFunction> rhoi_i, std::shared_ptr<const dolfin::GenericFunction> drhoidus_i, std::shared_ptr<const dolfin::GenericFunction> Gammai_i, std::shared_ptr<const dolfin::GenericFunction> dGammaidus_i, std::shared_ptr<const dolfin::GenericFunction> Gammaik_i, std::shared_ptr<const dolfin::GenericFunction> dGammaikdus_i):
    dolfin::Form(2, 10), us_i(*this, 0), Da(*this, 1), eps(*this, 2), rho0(*this, 3), rhoi_i(*this, 4), drhoidus_i(*this, 5), Gammai_i(*this, 6), dGammaidus_i(*this, 7), Gammaik_i(*this, 8), dGammaikdus_i(*this, 9)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->us_i = us_i;
    this->Da = Da;
    this->eps = eps;
    this->rho0 = rho0;
    this->rhoi_i = rhoi_i;
    this->drhoidus_i = drhoidus_i;
    this->Gammai_i = Gammai_i;
    this->dGammaidus_i = dGammaidus_i;
    this->Gammaik_i = Gammaik_i;
    this->dGammaikdus_i = dGammaikdus_i;

    _ufc_form = std::make_shared<const phasediagramts_form_3>();
  }

  // Destructor
  ~Form_JG()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "us_i")
      return 0;
    else if (name == "Da")
      return 1;
    else if (name == "eps")
      return 2;
    else if (name == "rho0")
      return 3;
    else if (name == "rhoi_i")
      return 4;
    else if (name == "drhoidus_i")
      return 5;
    else if (name == "Gammai_i")
      return 6;
    else if (name == "dGammaidus_i")
      return 7;
    else if (name == "Gammaik_i")
      return 8;
    else if (name == "dGammaikdus_i")
      return 9;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "us_i";
    case 1:
      return "Da";
    case 2:
      return "eps";
    case 3:
      return "rho0";
    case 4:
      return "rhoi_i";
    case 5:
      return "drhoidus_i";
    case 6:
      return "Gammai_i";
    case 7:
      return "dGammaidus_i";
    case 8:
      return "Gammaik_i";
    case 9:
      return "dGammaikdus_i";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_JG_FunctionSpace_0 TestSpace;
  typedef Form_JG_FunctionSpace_1 TrialSpace;
  typedef Form_JG_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_JG_MultiMeshFunctionSpace_1 MultiMeshTrialSpace;
  typedef Form_JG_FunctionSpace_2 CoefficientSpace_us_i;
  typedef Form_JG_FunctionSpace_3 CoefficientSpace_Da;
  typedef Form_JG_FunctionSpace_4 CoefficientSpace_eps;
  typedef Form_JG_FunctionSpace_5 CoefficientSpace_rho0;
  typedef Form_JG_FunctionSpace_6 CoefficientSpace_rhoi_i;
  typedef Form_JG_FunctionSpace_7 CoefficientSpace_drhoidus_i;
  typedef Form_JG_FunctionSpace_8 CoefficientSpace_Gammai_i;
  typedef Form_JG_FunctionSpace_9 CoefficientSpace_dGammaidus_i;
  typedef Form_JG_FunctionSpace_10 CoefficientSpace_Gammaik_i;
  typedef Form_JG_FunctionSpace_11 CoefficientSpace_dGammaikdus_i;

  // Coefficients
  dolfin::CoefficientAssigner us_i;
  dolfin::CoefficientAssigner Da;
  dolfin::CoefficientAssigner eps;
  dolfin::CoefficientAssigner rho0;
  dolfin::CoefficientAssigner rhoi_i;
  dolfin::CoefficientAssigner drhoidus_i;
  dolfin::CoefficientAssigner Gammai_i;
  dolfin::CoefficientAssigner dGammaidus_i;
  dolfin::CoefficientAssigner Gammaik_i;
  dolfin::CoefficientAssigner dGammaikdus_i;
};

class MultiMeshForm_JG: public dolfin::MultiMeshForm
{
public:

  // Constructor
  MultiMeshForm_JG(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V1, std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0):
    dolfin::MultiMeshForm(V1, V0), us_i(*this, 0), Da(*this, 1), eps(*this, 2), rho0(*this, 3), rhoi_i(*this, 4), drhoidus_i(*this, 5), Gammai_i(*this, 6), dGammaidus_i(*this, 7), Gammaik_i(*this, 8), dGammaikdus_i(*this, 9)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_JG(V1->part(part), V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients

  }

  // Constructor
  MultiMeshForm_JG(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V1, std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> us_i, std::shared_ptr<const dolfin::GenericFunction> Da, std::shared_ptr<const dolfin::GenericFunction> eps, std::shared_ptr<const dolfin::GenericFunction> rho0, std::shared_ptr<const dolfin::GenericFunction> rhoi_i, std::shared_ptr<const dolfin::GenericFunction> drhoidus_i, std::shared_ptr<const dolfin::GenericFunction> Gammai_i, std::shared_ptr<const dolfin::GenericFunction> dGammaidus_i, std::shared_ptr<const dolfin::GenericFunction> Gammaik_i, std::shared_ptr<const dolfin::GenericFunction> dGammaikdus_i):
    dolfin::MultiMeshForm(V1, V0), us_i(*this, 0), Da(*this, 1), eps(*this, 2), rho0(*this, 3), rhoi_i(*this, 4), drhoidus_i(*this, 5), Gammai_i(*this, 6), dGammaidus_i(*this, 7), Gammaik_i(*this, 8), dGammaikdus_i(*this, 9)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_JG(V1->part(part), V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients
    this->us_i = us_i;
    this->Da = Da;
    this->eps = eps;
    this->rho0 = rho0;
    this->rhoi_i = rhoi_i;
    this->drhoidus_i = drhoidus_i;
    this->Gammai_i = Gammai_i;
    this->dGammaidus_i = dGammaidus_i;
    this->Gammaik_i = Gammaik_i;
    this->dGammaikdus_i = dGammaikdus_i;

  }

  // Destructor
  ~MultiMeshForm_JG()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "us_i")
      return 0;
    else if (name == "Da")
      return 1;
    else if (name == "eps")
      return 2;
    else if (name == "rho0")
      return 3;
    else if (name == "rhoi_i")
      return 4;
    else if (name == "drhoidus_i")
      return 5;
    else if (name == "Gammai_i")
      return 6;
    else if (name == "dGammaidus_i")
      return 7;
    else if (name == "Gammaik_i")
      return 8;
    else if (name == "dGammaikdus_i")
      return 9;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "us_i";
    case 1:
      return "Da";
    case 2:
      return "eps";
    case 3:
      return "rho0";
    case 4:
      return "rhoi_i";
    case 5:
      return "drhoidus_i";
    case 6:
      return "Gammai_i";
    case 7:
      return "dGammaidus_i";
    case 8:
      return "Gammaik_i";
    case 9:
      return "dGammaikdus_i";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_JG_FunctionSpace_0 TestSpace;
  typedef Form_JG_FunctionSpace_1 TrialSpace;
  typedef Form_JG_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_JG_MultiMeshFunctionSpace_1 MultiMeshTrialSpace;
  typedef Form_JG_FunctionSpace_2 CoefficientSpace_us_i;
  typedef Form_JG_FunctionSpace_3 CoefficientSpace_Da;
  typedef Form_JG_FunctionSpace_4 CoefficientSpace_eps;
  typedef Form_JG_FunctionSpace_5 CoefficientSpace_rho0;
  typedef Form_JG_FunctionSpace_6 CoefficientSpace_rhoi_i;
  typedef Form_JG_FunctionSpace_7 CoefficientSpace_drhoidus_i;
  typedef Form_JG_FunctionSpace_8 CoefficientSpace_Gammai_i;
  typedef Form_JG_FunctionSpace_9 CoefficientSpace_dGammaidus_i;
  typedef Form_JG_FunctionSpace_10 CoefficientSpace_Gammaik_i;
  typedef Form_JG_FunctionSpace_11 CoefficientSpace_dGammaikdus_i;

  // Coefficients
  dolfin::MultiMeshCoefficientAssigner us_i;
  dolfin::MultiMeshCoefficientAssigner Da;
  dolfin::MultiMeshCoefficientAssigner eps;
  dolfin::MultiMeshCoefficientAssigner rho0;
  dolfin::MultiMeshCoefficientAssigner rhoi_i;
  dolfin::MultiMeshCoefficientAssigner drhoidus_i;
  dolfin::MultiMeshCoefficientAssigner Gammai_i;
  dolfin::MultiMeshCoefficientAssigner dGammaidus_i;
  dolfin::MultiMeshCoefficientAssigner Gammaik_i;
  dolfin::MultiMeshCoefficientAssigner dGammaikdus_i;
};

// Class typedefs
typedef Form_F::TestSpace FunctionSpace;
typedef Form_F::MultiMeshTestSpace MultiMeshFunctionSpace;

}

#endif
